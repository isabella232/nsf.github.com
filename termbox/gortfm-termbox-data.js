var gortfmData = {html:"<p>\nTermbox library provides facilities for terminal input/output manipulation\nin a pseudo-GUI style.\n</p>\n",name:"termbox",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cell!\">Cell</a></h2>\n<pre>type Cell struct {\n\tCh uint32\n\tFg uint16\n\tBg uint16\n}</pre>\n<p>\nA cell, single conceptual entity on the screen. The screen is basically a 2d\narray of cells. &#39;Ch&#39; is a unicode character, &#39;Fg&#39; and &#39;Bg&#39; are foreground\nand background attributes respectively.\n</p>\n\n",name:"Cell","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Event!\">Event</a></h2>\n<pre>type Event struct {\n\tType uint8  // one of EVENT_ constants\n\tMod  uint8  // one of MOD_ constants or 0\n\tKey  uint16 // one of KEY_ constants, invalid if &#39;Ch&#39; is not 0\n\tCh   uint32 // a unicode character\n\tW    int32  // width of the screen\n\tH    int32  // height of the screen\n}</pre>\n<p>\nThis type represents termbox event. &#39;Mod&#39;, &#39;Key&#39; and &#39;Ch&#39; fields are valid\nif &#39;Type&#39; is EVENT_KEY. &#39;W&#39; and &#39;H&#39; are valid if &#39;Type&#39; is EVENT_RESIZE.\n</p>\n\n",name:"Event","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Event\">func (*Event)</a> <a href=\"?m:Event.Peek!\">Peek</a></h2>\n<code>func (e *Event) Peek(timeout int) int</code>\n<p>\nShortcut for termbox.PeekEvent(e, timeout).\n</p>\n\n",name:"Peek"},{html:"\n<h2><a class=\"black\" href=\"?m:Event\">func (*Event)</a> <a href=\"?m:Event.Poll!\">Poll</a></h2>\n<code>func (e *Event) Poll() int</code>\n<p>\nShortcut for termbox.PollEvent(e).\n</p>\n\n",name:"Poll"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Blit!\">Blit</a></h2>\n<code>func Blit(x, y, w int, cells []Cell)</code>\n<p>\n&#39;Blit&#39; function copies the &#39;cells&#39; buffer to the internal back buffer at the\nposition specified by &#39;x&#39; and &#39;y&#39;. Blit doesn&#39;t perform any kind of cuts and\nif contents of the cells buffer cannot be placed without crossing back\nbuffer&#39;s boundaries, the operation is discarded. Parameter &#39;w&#39; must be &gt; 0,\notherwise it will cause &#34;division by zero&#34; panic.\n</p>\n<p>\nThe width and the height of the &#39;cells&#39; buffer are calculated that way:\n</p>\n<pre>w := w\nh := len(cells) / w\n</pre>\n\n",name:"Blit"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ChangeCell!\">ChangeCell</a></h2>\n<code>func ChangeCell(x int, y int, ch int, fg uint16, bg uint16)</code>\n<p>\nChanges cell&#39;s parameters in the internal back buffer at the specified\nposition.\n</p>\n\n",name:"ChangeCell"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Clear!\">Clear</a></h2>\n<code>func Clear()</code>\n<p>\nClears the internal back buffer.\n</p>\n\n",name:"Clear"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Height!\">Height</a></h2>\n<code>func Height() int</code>\n<p>\nReturns the height of the internal back buffer (which is the same as\nterminal&#39;s window height in characters).\n</p>\n\n",name:"Height"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HideCursor!\">HideCursor</a></h2>\n<code>func HideCursor()</code>\n<p>\nThe shortcut for SetCursor(HIDE_CURSOR, HIDE_CURSOR).\n</p>\n\n",name:"HideCursor"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Init!\">Init</a></h2>\n<code>func Init() os.Error</code>\n<p>\nInitializes termbox library. This function should be called before any other functions.\nAfter successful initialization, the library must be finalized using &#39;Shutdown&#39; function.\n</p>\n<p>\nExample usage:\n</p>\n<pre>err := termbox.Init()\nif err != nil {\n\tpanic(err.String())\n}\ndefer termbox.Shutdown()\n</pre>\n\n",name:"Init"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PeekEvent!\">PeekEvent</a></h2>\n<code>func PeekEvent(e *Event, timeout int) int</code>\n<p>\nWait for an event &#39;timeout&#39; milliseconds. If no event occurs, returns 0. If\nan error occurs, returns -1. Otherwise the return value is one of EVENT_\nconsts.\n</p>\n\n",name:"PeekEvent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PollEvent!\">PollEvent</a></h2>\n<code>func PollEvent(e *Event) int</code>\n<p>\nWait for an event. This is a blocking function call. If an error occurs,\nreturns -1. Otherwise the return value is one of EVENT_ consts.\n</p>\n\n",name:"PollEvent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Present!\">Present</a></h2>\n<code>func Present()</code>\n<p>\nSynchronizes the internal back buffer with the terminal.\n</p>\n\n",name:"Present"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PutCell!\">PutCell</a></h2>\n<code>func PutCell(x, y int, cell *Cell)</code>\n<p>\nPuts the &#39;cell&#39; into the internal back buffer at the specified position.\n</p>\n\n",name:"PutCell"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SelectInputMode!\">SelectInputMode</a></h2>\n<code>func SelectInputMode(mode int)</code>\n<p>\nSelects termbox input mode. Termbox has two input modes:\n</p>\n<p>\n1. ESC input mode. When ESC sequence is in the buffer and it doesn&#39;t\nmatch any known sequence. ESC means KEY_ESC.\n</p>\n<p>\n2. ALT input mode. When ESC sequence is in the buffer and it doesn&#39;t match\nany known sequence. ESC enables MOD_ALT modifier for the next keyboard\nevent.\n</p>\n<p>\nIf &#39;mode&#39; is 0, returns the current input mode. See also INPUT_ constants.\n</p>\n<p>\nNote: INPUT_ALT mode may not work with PeekEvent.\n</p>\n\n",name:"SelectInputMode"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SetCursor!\">SetCursor</a></h2>\n<code>func SetCursor(x int, y int)</code>\n<p>\nSets the position of the cursor. See also HIDE_CURSOR and HideCursor().\n</p>\n\n",name:"SetCursor"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Shutdown!\">Shutdown</a></h2>\n<code>func Shutdown()</code>\n<p>\nFinalizes termbox library, should be called after successful initialization\nwhen termbox&#39;s functionality isn&#39;t required anymore.\n</p>\n\n",name:"Shutdown"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Width!\">Width</a></h2>\n<code>func Width() int</code>\n<p>\nReturns the width of the internal back buffer (which is the same as\nterminal&#39;s window width in characters).\n</p>\n\n",name:"Width"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:KEY_F1!\"><em>group</em></a></h2>\n<pre>const (\n\tKEY_F1          = (0xFFFF - 0)\n\tKEY_F2          = (0xFFFF - 1)\n\tKEY_F3          = (0xFFFF - 2)\n\tKEY_F4          = (0xFFFF - 3)\n\tKEY_F5          = (0xFFFF - 4)\n\tKEY_F6          = (0xFFFF - 5)\n\tKEY_F7          = (0xFFFF - 6)\n\tKEY_F8          = (0xFFFF - 7)\n\tKEY_F9          = (0xFFFF - 8)\n\tKEY_F10         = (0xFFFF - 9)\n\tKEY_F11         = (0xFFFF - 10)\n\tKEY_F12         = (0xFFFF - 11)\n\tKEY_INSERT      = (0xFFFF - 12)\n\tKEY_DELETE      = (0xFFFF - 13)\n\tKEY_HOME        = (0xFFFF - 14)\n\tKEY_END         = (0xFFFF - 15)\n\tKEY_PGUP        = (0xFFFF - 16)\n\tKEY_PGDN        = (0xFFFF - 17)\n\tKEY_ARROW_UP    = (0xFFFF - 18)\n\tKEY_ARROW_DOWN  = (0xFFFF - 19)\n\tKEY_ARROW_LEFT  = (0xFFFF - 20)\n\tKEY_ARROW_RIGHT = (0xFFFF - 21)\n\n\tKEY_CTRL_TILDE       = 0x00\n\tKEY_CTRL_2           = 0x00\n\tKEY_CTRL_A           = 0x01\n\tKEY_CTRL_B           = 0x02\n\tKEY_CTRL_C           = 0x03\n\tKEY_CTRL_D           = 0x04\n\tKEY_CTRL_E           = 0x05\n\tKEY_CTRL_F           = 0x06\n\tKEY_CTRL_G           = 0x07\n\tKEY_BACKSPACE        = 0x08\n\tKEY_CTRL_H           = 0x08\n\tKEY_TAB              = 0x09\n\tKEY_CTRL_I           = 0x09\n\tKEY_CTRL_J           = 0x0A\n\tKEY_CTRL_K           = 0x0B\n\tKEY_CTRL_L           = 0x0C\n\tKEY_ENTER            = 0x0D\n\tKEY_CTRL_M           = 0x0D\n\tKEY_CTRL_N           = 0x0E\n\tKEY_CTRL_O           = 0x0F\n\tKEY_CTRL_P           = 0x10\n\tKEY_CTRL_Q           = 0x11\n\tKEY_CTRL_R           = 0x12\n\tKEY_CTRL_S           = 0x13\n\tKEY_CTRL_T           = 0x14\n\tKEY_CTRL_U           = 0x15\n\tKEY_CTRL_V           = 0x16\n\tKEY_CTRL_W           = 0x17\n\tKEY_CTRL_X           = 0x18\n\tKEY_CTRL_Y           = 0x19\n\tKEY_CTRL_Z           = 0x1A\n\tKEY_ESC              = 0x1B\n\tKEY_CTRL_LSQ_BRACKET = 0x1B\n\tKEY_CTRL_3           = 0x1B\n\tKEY_CTRL_4           = 0x1C\n\tKEY_CTRL_BACKSLASH   = 0x1C\n\tKEY_CTRL_5           = 0x1D\n\tKEY_CTRL_RSQ_BRACKET = 0x1D\n\tKEY_CTRL_6           = 0x1E\n\tKEY_CTRL_7           = 0x1F\n\tKEY_CTRL_SLASH       = 0x1F\n\tKEY_CTRL_UNDERSCORE  = 0x1F\n\tKEY_SPACE            = 0x20\n\tKEY_BACKSPACE2       = 0x7F\n\tKEY_CTRL_8           = 0x7F\n)</pre>\n<p>\nKey constants, see Event.Key field.\n</p>\n\n",names:["KEY_F1","KEY_F2","KEY_F3","KEY_F4","KEY_F5","KEY_F6","KEY_F7","KEY_F8","KEY_F9","KEY_F10","KEY_F11","KEY_F12","KEY_INSERT","KEY_DELETE","KEY_HOME","KEY_END","KEY_PGUP","KEY_PGDN","KEY_ARROW_UP","KEY_ARROW_DOWN","KEY_ARROW_LEFT","KEY_ARROW_RIGHT","KEY_CTRL_TILDE","KEY_CTRL_2","KEY_CTRL_A","KEY_CTRL_B","KEY_CTRL_C","KEY_CTRL_D","KEY_CTRL_E","KEY_CTRL_F","KEY_CTRL_G","KEY_BACKSPACE","KEY_CTRL_H","KEY_TAB","KEY_CTRL_I","KEY_CTRL_J","KEY_CTRL_K","KEY_CTRL_L","KEY_ENTER","KEY_CTRL_M","KEY_CTRL_N","KEY_CTRL_O","KEY_CTRL_P","KEY_CTRL_Q","KEY_CTRL_R","KEY_CTRL_S","KEY_CTRL_T","KEY_CTRL_U","KEY_CTRL_V","KEY_CTRL_W","KEY_CTRL_X","KEY_CTRL_Y","KEY_CTRL_Z","KEY_ESC","KEY_CTRL_LSQ_BRACKET","KEY_CTRL_3","KEY_CTRL_4","KEY_CTRL_BACKSLASH","KEY_CTRL_5","KEY_CTRL_RSQ_BRACKET","KEY_CTRL_6","KEY_CTRL_7","KEY_CTRL_SLASH","KEY_CTRL_UNDERSCORE","KEY_SPACE","KEY_BACKSPACE2","KEY_CTRL_8"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:MOD_ALT!\">MOD_ALT</a></h2>\n<pre>const MOD_ALT = 0x01</pre>\n<p>\nAlt modifier constant, see Event.Mod field and SetInputMode function.\n</p>\n\n",names:["MOD_ALT"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:BLACK!\"><em>group</em></a></h2>\n<pre>const (\n\tBLACK   = 0x00\n\tRED     = 0x01\n\tGREEN   = 0x02\n\tYELLOW  = 0x03\n\tBLUE    = 0x04\n\tMAGENTA = 0x05\n\tCYAN    = 0x06\n\tWHITE   = 0x07\n\n\tBOLD      = 0x10\n\tUNDERLINE = 0x20\n)</pre>\n<p>\nCell attributes, it is possible to use multiple attributes by combining them\nusing bitwise OR (&#39;|&#39;). Although, colors cannot be combined. But you can\ncombine attributes and a single color.\n</p>\n\n",names:["BLACK","RED","GREEN","YELLOW","BLUE","MAGENTA","CYAN","WHITE","BOLD","UNDERLINE"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:HIDE_CURSOR!\">HIDE_CURSOR</a></h2>\n<pre>const HIDE_CURSOR = -1</pre>\n<p>\nSpecial coordinate for SetCursor. If you call:\n</p>\n<pre>SetCursor(HIDE_CURSOR, HIDE_CURSOR)\n</pre>\n<p>\nThis function call hides the cursor.\n</p>\n\n",names:["HIDE_CURSOR"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:INPUT_ESC!\"><em>group</em></a></h2>\n<pre>const (\n\tINPUT_ESC = 1\n\tINPUT_ALT = 2\n)</pre>\n<p>\nInput mode. See SelectInputMode function.\n</p>\n\n",names:["INPUT_ESC","INPUT_ALT"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EVENT_KEY!\"><em>group</em></a></h2>\n<pre>const (\n\tEVENT_KEY    = 1\n\tEVENT_RESIZE = 2\n)</pre>\n<p>\nEvent type. See Event.Type field.\n</p>\n\n",names:["EVENT_KEY","EVENT_RESIZE"],type:""}],vars:[]}