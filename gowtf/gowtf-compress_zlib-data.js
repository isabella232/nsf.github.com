var gowtfData = {"html":"<p>\u000aThe zlib package implements reading and writing of zlib\u000aformat compressed data, as specified in RFC 1950.\u000a</p>\u000a<p>\u000aThe implementation provides filters that uncompress during reading\u000aand compress during writing.  For example, to write compressed data\u000ato a buffer:\u000a</p>\u000a<pre>var b bytes.Buffer\u000aw, err := zlib.NewWriter(&amp;b)\u000aw.Write([]byte(&#34;hello, world\\n&#34;))\u000aw.Close()\u000a</pre>\u000a<p>\u000aand to read that data back:\u000a</p>\u000a<pre>r, err := zlib.NewReader(&amp;b)\u000aio.Copy(os.Stdout, r)\u000ar.Close()\u000a</pre>\u000a","name":"zlib","filenames":["/home/nsf/go/src/pkg/compress/zlib/reader.go","/home/nsf/go/src/pkg/compress/zlib/writer.go"],"types":[],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\u000a<code>func NewReader(r io.Reader) (io.ReadCloser, os.Error)</code>\u000a<p>\u000aNewReader creates a new io.ReadCloser that satisfies reads by decompressing data read from r.\u000aThe implementation buffers input and may read more data than necessary from r.\u000aIt is the caller&#39;s responsibility to call Close on the ReadCloser when done.\u000a</p>\u000a\u000a","name":"NewReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(w io.Writer) (io.WriteCloser, os.Error)</code>\u000a<p>\u000aNewWriter calls NewWriterLevel with the default compression level.\u000a</p>\u000a\u000a","name":"NewWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriterLevel!\">NewWriterLevel</a></h2>\u000a<code>func NewWriterLevel(w io.Writer, level int) (io.WriteCloser, os.Error)</code>\u000a<p>\u000aNewWriterLevel creates a new io.WriteCloser that satisfies writes by compressing data written to w.\u000aIt is the caller&#39;s responsibility to call Close on the WriteCloser when done.\u000alevel is the compression level, which can be DefaultCompression, NoCompression,\u000aor any integer value between BestSpeed and BestCompression (inclusive).\u000a</p>\u000a\u000a","name":"NewWriterLevel"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:NoCompression!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009NoCompression      = flate.NoCompression\u000a\u0009BestSpeed          = flate.BestSpeed\u000a\u0009BestCompression    = flate.BestCompression\u000a\u0009DefaultCompression = flate.DefaultCompression\u000a)</pre>\u000a<p>\u000aThese constants are copied from the flate package, so that code that imports\u000a&#34;compress/zlib&#34; does not also have to import &#34;compress/flate&#34;.\u000a</p>\u000a\u000a","names":["NoCompression","BestSpeed","BestCompression","DefaultCompression"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ChecksumError!\">ChecksumError</a></h2>\u000a<pre>var ChecksumError os.Error = os.ErrorString(&#34;zlib checksum error&#34;)</pre>\u000a\u000a","names":["ChecksumError"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:HeaderError!\">HeaderError</a></h2>\u000a<pre>var HeaderError os.Error = os.ErrorString(&#34;invalid zlib header&#34;)</pre>\u000a\u000a","names":["HeaderError"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:UnsupportedError!\">UnsupportedError</a></h2>\u000a<pre>var UnsupportedError os.Error = os.ErrorString(&#34;unsupported zlib format&#34;)</pre>\u000a\u000a","names":["UnsupportedError"],"type":""}]}