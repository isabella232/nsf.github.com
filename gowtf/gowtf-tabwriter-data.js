var gowtfData = {"index":"index.html","html":"<p>\u000aThe tabwriter package implements a write filter (tabwriter.Writer)\u000athat translates tabbed columns in input into properly aligned text.\u000a</p>\u000a<p>\u000aThe package is using the Elastic Tabstops algorithm described at\u000a<a href=\"http://nickgravgaard.com/elastictabstops/index.html\">http://nickgravgaard.com/elastictabstops/index.html</a>.\u000a</p>\u000a","name":"tabwriter","filenames":["/home/nsf/go/src/pkg/tabwriter/tabwriter.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\u000a<pre>type Writer struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Writer is a filter that inserts padding around tab-delimited\u000acolumns in its input to align them in the output.\u000a</p>\u000a<p>\u000aThe Writer treats incoming bytes as UTF-8 encoded text consisting\u000aof cells terminated by (horizontal or vertical) tabs or line\u000abreaks (newline or formfeed characters). Cells in adjacent lines\u000aconstitute a column. The Writer inserts padding as needed to\u000amake all cells in a column have the same width, effectively\u000aaligning the columns. It assumes that all characters have the\u000asame width except for tabs for which a tabwidth must be specified.\u000aNote that cells are tab-terminated, not tab-separated: trailing\u000anon-tab text at the end of a line does not form a column cell.\u000a</p>\u000a<p>\u000aThe Writer assumes that all Unicode code points have the same width;\u000athis may not be true in some fonts.\u000a</p>\u000a<p>\u000aIf DiscardEmptyColumns is set, empty columns that are terminated\u000aentirely by vertical (or &#34;soft&#34;) tabs are discarded. Columns\u000aterminated by horizontal (or &#34;hard&#34;) tabs are not affected by\u000athis flag.\u000a</p>\u000a<p>\u000aIf a Writer is configured to filter HTML, HTML tags and entities\u000aare simply passed through. The widths of tags and entities are\u000aassumed to be zero (tags) and one (entities) for formatting purposes.\u000a</p>\u000a<p>\u000aA segment of text may be escaped by bracketing it with Escape\u000acharacters. The tabwriter passes escaped text segments through\u000aunchanged. In particular, it does not interpret any tabs or line\u000abreaks within the segment. If the StripEscape flag is set, the\u000aEscape characters are stripped from the output; otherwise they\u000aare passed through as well. For the purpose of formatting, the\u000awidth of the escaped text is always computed excluding the Escape\u000acharacters.\u000a</p>\u000a<p>\u000aThe formfeed character (&#39;\\f&#39;) acts like a newline but it also\u000aterminates all columns in the current line (effectively calling\u000aFlush). Cells in the next line start new columns. Unless found\u000ainside an HTML tag or inside an escaped text segment, formfeed\u000acharacters appear as newlines in the output.\u000a</p>\u000a<p>\u000aThe Writer must buffer input internally, because proper spacing\u000aof one line may depend on the cells in future lines. Clients must\u000acall Flush when done calling Write.\u000a</p>\u000a\u000a","name":"Writer","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Flush!\">Flush</a></h2>\u000a<code>func (b *Writer) Flush() (err os.Error)</code>\u000a<p>\u000aFlush should be called after the last call to Write to ensure\u000athat any data buffered in the Writer is written to output. Any\u000aincomplete escape sequence at the end is simply considered\u000acomplete for formatting purposes.\u000a</p>\u000a\u000a","name":"Flush"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Init!\">Init</a></h2>\u000a<code>func (b *Writer) Init(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</code>\u000a<p>\u000aA Writer must be initialized with a call to Init. The first parameter (output)\u000aspecifies the filter output. The remaining parameters control the formatting:\u000a</p>\u000a<pre>minwidth\u0009minimal cell width including any padding\u000atabwidth\u0009width of tab characters (equivalent number of spaces)\u000apadding\u0009\u0009padding added to a cell before computing its width\u000apadchar\u0009\u0009ASCII char used for padding\u000a\u0009\u0009if padchar == &#39;\\t&#39;, the Writer will assume that the\u000a\u0009\u0009width of a &#39;\\t&#39; in the formatted output is tabwidth,\u000a\u0009\u0009and cells are left-aligned independent of align_left\u000a\u0009\u0009(for correct-looking results, tabwidth must correspond\u000a\u0009\u0009to the tab width in the viewer displaying the result)\u000aflags\u0009\u0009formatting control\u000a</pre>\u000a<p>\u000aTo format in tab-separated columns with a tab stop of 8:\u000a</p>\u000a<pre>b.Init(w, 8, 1, 8, &#39;\\t&#39;, 0);\u000a</pre>\u000a<p>\u000aTo format in space-separated columns with at least 4 spaces between columns:\u000a</p>\u000a<pre>b.Init(w, 0, 4, 8, &#39; &#39;, 0);\u000a</pre>\u000a\u000a","name":"Init"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Write!\">Write</a></h2>\u000a<code>func (b *Writer) Write(buf []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite writes buf to the writer b.\u000aThe only errors returned are ones encountered\u000awhile writing to the underlying output stream.\u000a</p>\u000a\u000a","name":"Write"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(output io.Writer, minwidth, tabwidth, padding int, padchar byte, flags uint) *Writer</code>\u000a<p>\u000aNewWriter allocates and initializes a new tabwriter.Writer.\u000aThe parameters are the same as for the the Init function.\u000a</p>\u000a\u000a","name":"NewWriter"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:FilterHTML!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009// Ignore html tags and treat entities (starting with &#39;&amp;&#39;\u000a\u0009// and ending in &#39;;&#39;) as single characters (width = 1).\u000a\u0009FilterHTML uint = 1 &lt;&lt; iota\u000a\u000a\u0009// Strip Escape characters bracketing escaped text segments\u000a\u0009// instead of passing them through unchanged with the text.\u000a\u0009StripEscape\u000a\u000a\u0009// Force right-alignment of cell content.\u000a\u0009// Default is left-alignment.\u000a\u0009AlignRight\u000a\u000a\u0009// Handle empty columns as if they were not present in\u000a\u0009// the input in the first place.\u000a\u0009DiscardEmptyColumns\u000a\u000a\u0009// Always use tabs for indentation columns (i.e., padding of\u000a\u0009// leading empty cells on the left) independent of padchar.\u000a\u0009TabIndent\u000a\u000a\u0009// Print a vertical bar (&#39;|&#39;) between columns (after formatting).\u000a\u0009// Discarded colums appear as zero-width columns (&#34;||&#34;).\u000a\u0009Debug\u000a)</pre>\u000a<p>\u000aFormatting can be controlled with these flags.\u000a</p>\u000a\u000a","names":["FilterHTML","StripEscape","AlignRight","DiscardEmptyColumns","TabIndent","Debug"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Escape!\">Escape</a></h2>\u000a<pre>const Escape = &#39;\\xff&#39;</pre>\u000a<p>\u000aTo escape a text segment, bracket it with Escape characters.\u000aFor instance, the tab in this string &#34;Ignore this tab: \\xff\\t\\xff&#34;\u000adoes not terminate a cell and constitutes a single character of\u000awidth one for formatting purposes.\u000a</p>\u000a<p>\u000aThe value 0xff was chosen because it cannot appear in a valid UTF-8 sequence.\u000a</p>\u000a\u000a","names":["Escape"],"type":""}],"vars":[]}