var gowtfData = {"index":"index.html","html":"<p>\u000aThe os package provides a platform-independent interface to operating\u000asystem functionality.  The design is Unix-like.\u000a</p>\u000a","name":"os","filenames":["/home/nsf/go/src/pkg/os/sys_linux.go","/home/nsf/go/src/pkg/os/getwd.go","/home/nsf/go/src/pkg/os/exec.go","/home/nsf/go/src/pkg/os/file.go","/home/nsf/go/src/pkg/os/stat_linux.go","/home/nsf/go/src/pkg/os/types.go","/home/nsf/go/src/pkg/os/error.go","/home/nsf/go/src/pkg/os/env_unix.go","/home/nsf/go/src/pkg/os/path.go","/home/nsf/go/src/pkg/os/time.go","/home/nsf/go/src/pkg/os/dir_linux.go","/home/nsf/go/src/pkg/os/proc.go","/home/nsf/go/src/pkg/os/file_unix.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Errno!\">Errno</a></h2>\u000a<pre>type Errno int64</pre>\u000a<p>\u000aErrno is the Unix error number.  Names such as EINVAL are simple\u000awrappers to convert the error number into an Error.\u000a</p>\u000a\u000a","name":"Errno","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Errno\">func (Errno)</a> <a href=\"?m:Errno.String!\">String</a></h2>\u000a<code>func (e Errno) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Errno\">func (Errno)</a> <a href=\"?m:Errno.Temporary!\">Temporary</a></h2>\u000a<code>func (e Errno) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Errno\">func (Errno)</a> <a href=\"?m:Errno.Timeout!\">Timeout</a></h2>\u000a<code>func (e Errno) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error interface {\u000a\u0009String() string\u000a}</pre>\u000a<p>\u000aAn Error can represent any printable error condition.\u000a</p>\u000a\u000a","name":"Error","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ErrorString!\">ErrorString</a></h2>\u000a<pre>type ErrorString string</pre>\u000a<p>\u000aA helper type that can be embedded or wrapped to simplify satisfying\u000aError.\u000a</p>\u000a\u000a","name":"ErrorString","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorString\">func (ErrorString)</a> <a href=\"?m:ErrorString.String!\">String</a></h2>\u000a<code>func (e ErrorString) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorString\">func (ErrorString)</a> <a href=\"?m:ErrorString.Temporary!\">Temporary</a></h2>\u000a<code>func (e ErrorString) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorString\">func (ErrorString)</a> <a href=\"?m:ErrorString.Timeout!\">Timeout</a></h2>\u000a<code>func (e ErrorString) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\u000a<pre>type File struct {\u000a\u0009fd      int\u000a\u0009name    string\u000a\u0009dirinfo *dirInfo // nil unless directory being read\u000a\u0009nepipe  int      // number of consecutive EPIPE in Write\u000a}</pre>\u000a<p>\u000aFile represents an open file descriptor.\u000a</p>\u000a\u000a","name":"File","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Chdir!\">Chdir</a></h2>\u000a<code>func (f *File) Chdir() Error</code>\u000a<p>\u000aChdir changes the current working directory to the file,\u000awhich must be a directory.\u000a</p>\u000a\u000a","name":"Chdir"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Chmod!\">Chmod</a></h2>\u000a<code>func (f *File) Chmod(mode uint32) Error</code>\u000a<p>\u000aChmod changes the mode of the file to mode.\u000a</p>\u000a\u000a","name":"Chmod"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Chown!\">Chown</a></h2>\u000a<code>func (f *File) Chown(uid, gid int) Error</code>\u000a<p>\u000aChown changes the numeric uid and gid of the named file.\u000a</p>\u000a\u000a","name":"Chown"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Close!\">Close</a></h2>\u000a<code>func (file *File) Close() Error</code>\u000a<p>\u000aClose closes the File, rendering it unusable for I/O.\u000aIt returns an Error, if any.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Fd!\">Fd</a></h2>\u000a<code>func (file *File) Fd() int</code>\u000a<p>\u000aFd returns the integer Unix file descriptor referencing the open file.\u000a</p>\u000a\u000a","name":"Fd"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Name!\">Name</a></h2>\u000a<code>func (file *File) Name() string</code>\u000a<p>\u000aName returns the name of the file as presented to Open.\u000a</p>\u000a\u000a","name":"Name"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Read!\">Read</a></h2>\u000a<code>func (file *File) Read(b []byte) (n int, err Error)</code>\u000a<p>\u000aRead reads up to len(b) bytes from the File.\u000aIt returns the number of bytes read and an Error, if any.\u000aEOF is signaled by a zero count with err set to EOF.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.ReadAt!\">ReadAt</a></h2>\u000a<code>func (file *File) ReadAt(b []byte, off int64) (n int, err Error)</code>\u000a<p>\u000aReadAt reads len(b) bytes from the File starting at byte offset off.\u000aIt returns the number of bytes read and the Error, if any.\u000aEOF is signaled by a zero count with err set to EOF.\u000aReadAt always returns a non-nil Error when n != len(b).\u000a</p>\u000a\u000a","name":"ReadAt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Readdir!\">Readdir</a></h2>\u000a<code>func (file *File) Readdir(count int) (fi []FileInfo, err Error)</code>\u000a<p>\u000aReaddir reads the contents of the directory associated with file and\u000areturns an array of up to count FileInfo structures, as would be returned\u000aby Lstat, in directory order.  Subsequent calls on the same file will yield\u000afurther FileInfos.\u000aA negative count means to read until EOF.\u000aReaddir returns the array and an Error, if any.\u000a</p>\u000a\u000a","name":"Readdir"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Readdirnames!\">Readdirnames</a></h2>\u000a<code>func (file *File) Readdirnames(count int) (names []string, err Error)</code>\u000a\u000a","name":"Readdirnames"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Seek!\">Seek</a></h2>\u000a<code>func (file *File) Seek(offset int64, whence int) (ret int64, err Error)</code>\u000a<p>\u000aSeek sets the offset for the next Read or Write on file to offset, interpreted\u000aaccording to whence: 0 means relative to the origin of the file, 1 means\u000arelative to the current offset, and 2 means relative to the end.\u000aIt returns the new offset and an Error, if any.\u000a</p>\u000a\u000a","name":"Seek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Stat!\">Stat</a></h2>\u000a<code>func (file *File) Stat() (fi *FileInfo, err Error)</code>\u000a<p>\u000aStat returns the FileInfo structure describing file.\u000aIt returns the FileInfo and an error, if any.\u000a</p>\u000a\u000a","name":"Stat"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Truncate!\">Truncate</a></h2>\u000a<code>func (f *File) Truncate(size int64) Error</code>\u000a<p>\u000aTruncate changes the size of the file.\u000aIt does not change the I/O offset.\u000a</p>\u000a\u000a","name":"Truncate"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Write!\">Write</a></h2>\u000a<code>func (file *File) Write(b []byte) (n int, err Error)</code>\u000a<p>\u000aWrite writes len(b) bytes to the File.\u000aIt returns the number of bytes written and an Error, if any.\u000aWrite returns a non-nil Error when n != len(b).\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.WriteAt!\">WriteAt</a></h2>\u000a<code>func (file *File) WriteAt(b []byte, off int64) (n int, err Error)</code>\u000a<p>\u000aWriteAt writes len(b) bytes to the File starting at byte offset off.\u000aIt returns the number of bytes written and an Error, if any.\u000aWriteAt returns a non-nil Error when n != len(b).\u000a</p>\u000a\u000a","name":"WriteAt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.WriteString!\">WriteString</a></h2>\u000a<code>func (file *File) WriteString(s string) (ret int, err Error)</code>\u000a<p>\u000aWriteString is like Write, but writes the contents of string s rather than\u000aan array of bytes.\u000a</p>\u000a\u000a","name":"WriteString"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FileInfo!\">FileInfo</a></h2>\u000a<pre>type FileInfo struct {\u000a\u0009Dev             uint64 // device number of file system holding file.\u000a\u0009Ino             uint64 // inode number.\u000a\u0009Nlink           uint64 // number of hard links.\u000a\u0009Mode            uint32 // permission and mode bits.\u000a\u0009Uid             int    // user id of owner.\u000a\u0009Gid             int    // group id of owner.\u000a\u0009Rdev            uint64 // device type for special file.\u000a\u0009Size            int64  // length in bytes.\u000a\u0009Blksize         int64  // size of blocks, in bytes.\u000a\u0009Blocks          int64  // number of blocks allocated for file.\u000a\u0009Atime_ns        int64  // access time; nanoseconds since epoch.\u000a\u0009Mtime_ns        int64  // modified time; nanoseconds since epoch.\u000a\u0009Ctime_ns        int64  // status change time; nanoseconds since epoch.\u000a\u0009Name            string // name of file as presented to Open.\u000a\u0009FollowedSymlink bool   // followed a symlink to get this information\u000a}</pre>\u000a<p>\u000aA FileInfo describes a file and is returned by Stat, Fstat, and Lstat\u000a</p>\u000a\u000a","name":"FileInfo","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsBlock!\">IsBlock</a></h2>\u000a<code>func (f *FileInfo) IsBlock() bool</code>\u000a<p>\u000aIsBlock reports whether the FileInfo describes a block special file.\u000a</p>\u000a\u000a","name":"IsBlock"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsChar!\">IsChar</a></h2>\u000a<code>func (f *FileInfo) IsChar() bool</code>\u000a<p>\u000aIsChar reports whether the FileInfo describes a character special file.\u000a</p>\u000a\u000a","name":"IsChar"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsDirectory!\">IsDirectory</a></h2>\u000a<code>func (f *FileInfo) IsDirectory() bool</code>\u000a<p>\u000aIsDirectory reports whether the FileInfo describes a directory.\u000a</p>\u000a\u000a","name":"IsDirectory"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsFifo!\">IsFifo</a></h2>\u000a<code>func (f *FileInfo) IsFifo() bool</code>\u000a<p>\u000aIsFifo reports whether the FileInfo describes a FIFO file.\u000a</p>\u000a\u000a","name":"IsFifo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsRegular!\">IsRegular</a></h2>\u000a<code>func (f *FileInfo) IsRegular() bool</code>\u000a<p>\u000aIsRegular reports whether the FileInfo describes a regular file.\u000a</p>\u000a\u000a","name":"IsRegular"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsSocket!\">IsSocket</a></h2>\u000a<code>func (f *FileInfo) IsSocket() bool</code>\u000a<p>\u000aIsSocket reports whether the FileInfo describes a socket.\u000a</p>\u000a\u000a","name":"IsSocket"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.IsSymlink!\">IsSymlink</a></h2>\u000a<code>func (f *FileInfo) IsSymlink() bool</code>\u000a<p>\u000aIsSymlink reports whether the FileInfo describes a symbolic link.\u000a</p>\u000a\u000a","name":"IsSymlink"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FileInfo\">func (*FileInfo)</a> <a href=\"?m:FileInfo.Permission!\">Permission</a></h2>\u000a<code>func (f *FileInfo) Permission() uint32</code>\u000a<p>\u000aPermission returns the file permission bits.\u000a</p>\u000a\u000a","name":"Permission"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LinkError!\">LinkError</a></h2>\u000a<pre>type LinkError struct {\u000a\u0009Op    string\u000a\u0009Old   string\u000a\u0009New   string\u000a\u0009Error Error\u000a}</pre>\u000a<p>\u000aLinkError records an error during a link or symlink or rename\u000asystem call and the paths that caused it.\u000a</p>\u000a\u000a","name":"LinkError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:LinkError\">func (*LinkError)</a> <a href=\"?m:LinkError.String!\">String</a></h2>\u000a<code>func (e *LinkError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PathError!\">PathError</a></h2>\u000a<pre>type PathError struct {\u000a\u0009Op    string\u000a\u0009Path  string\u000a\u0009Error Error\u000a}</pre>\u000a<p>\u000aPathError records an error and the operation and file path that caused it.\u000a</p>\u000a\u000a","name":"PathError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PathError\">func (*PathError)</a> <a href=\"?m:PathError.String!\">String</a></h2>\u000a<code>func (e *PathError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SyscallError!\">SyscallError</a></h2>\u000a<pre>type SyscallError struct {\u000a\u0009Syscall string\u000a\u0009Errno   Errno\u000a}</pre>\u000a<p>\u000aSyscallError records an error from a specific system call.\u000a</p>\u000a\u000a","name":"SyscallError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SyscallError\">func (*SyscallError)</a> <a href=\"?m:SyscallError.String!\">String</a></h2>\u000a<code>func (e *SyscallError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Waitmsg!\">Waitmsg</a></h2>\u000a<pre>type Waitmsg struct {\u000a\u0009Pid                int             // The process&#39;s id.\u000a\u0009syscall.WaitStatus                 // System-dependent status info.\u000a\u0009Rusage             *syscall.Rusage // System-dependent resource usage info.\u000a}</pre>\u000a<p>\u000aWaitmsg stores the information about an exited process as reported by Wait.\u000a</p>\u000a\u000a","name":"Waitmsg","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Waitmsg\">func (Waitmsg)</a> <a href=\"?m:Waitmsg.String!\">String</a></h2>\u000a<code>func (w Waitmsg) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Chdir!\">Chdir</a></h2>\u000a<code>func Chdir(dir string) Error</code>\u000a<p>\u000aChdir changes the current working directory to the named directory.\u000a</p>\u000a\u000a","name":"Chdir"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Chmod!\">Chmod</a></h2>\u000a<code>func Chmod(name string, mode uint32) Error</code>\u000a<p>\u000aChmod changes the mode of the named file to mode.\u000aIf the file is a symbolic link, it changes the mode of the link&#39;s target.\u000a</p>\u000a\u000a","name":"Chmod"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Chown!\">Chown</a></h2>\u000a<code>func Chown(name string, uid, gid int) Error</code>\u000a<p>\u000aChown changes the numeric uid and gid of the named file.\u000aIf the file is a symbolic link, it changes the uid and gid of the link&#39;s target.\u000a</p>\u000a\u000a","name":"Chown"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Chtimes!\">Chtimes</a></h2>\u000a<code>func Chtimes(name string, atime_ns int64, mtime_ns int64) Error</code>\u000a<p>\u000aChtimes changes the access and modification times of the named\u000afile, similar to the Unix utime() or utimes() functions.\u000a</p>\u000a<p>\u000aThe argument times are in nanoseconds, although the underlying\u000afilesystem may truncate or round the values to a more\u000acoarse time unit.\u000a</p>\u000a\u000a","name":"Chtimes"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Clearenv!\">Clearenv</a></h2>\u000a<code>func Clearenv()</code>\u000a<p>\u000aClearenv deletes all environment variables.\u000a</p>\u000a\u000a","name":"Clearenv"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Environ!\">Environ</a></h2>\u000a<code>func Environ() []string</code>\u000a<p>\u000aEnviron returns an array of strings representing the environment,\u000ain the form &#34;key=value&#34;.\u000a</p>\u000a\u000a","name":"Environ"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Exec!\">Exec</a></h2>\u000a<code>func Exec(name string, argv []string, envv []string) Error</code>\u000a<p>\u000aExec replaces the current process with an execution of the\u000anamed binary, with arguments argv and environment envv.\u000aIf successful, Exec never returns.  If it fails, it returns an Error.\u000aForkExec is almost always a better way to execute a program.\u000a</p>\u000a\u000a","name":"Exec"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Exit!\">Exit</a></h2>\u000a<code>func Exit(code int)</code>\u000a<p>\u000aExit causes the current program to exit with the given status code.\u000aConventionally, code zero indicates success, non-zero an error.\u000a</p>\u000a\u000a","name":"Exit"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ForkExec!\">ForkExec</a></h2>\u000a<code>func ForkExec(name string, argv []string, envv []string, dir string, fd []*File) (pid int, err Error)</code>\u000a<p>\u000aForkExec forks the current process and invokes Exec with the program, arguments,\u000aand environment specified by name, argv, and envv.  It returns the process\u000aid of the forked process and an Error, if any.  The fd array specifies the\u000afile descriptors to be set up in the new process: fd[0] will be Unix file\u000adescriptor 0 (standard input), fd[1] descriptor 1, and so on.  A nil entry\u000awill cause the child to have no open file descriptor with that index.\u000aIf dir is not empty, the child chdirs into the directory before execing the program.\u000a</p>\u000a\u000a","name":"ForkExec"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getegid!\">Getegid</a></h2>\u000a<code>func Getegid() int</code>\u000a<p>\u000aGetegid returns the numeric effective group id of the caller.\u000a</p>\u000a\u000a","name":"Getegid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getenv!\">Getenv</a></h2>\u000a<code>func Getenv(key string) string</code>\u000a<p>\u000aGetenv retrieves the value of the environment variable named by the key.\u000aIt returns the value, which will be empty if the variable is not present.\u000a</p>\u000a\u000a","name":"Getenv"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getenverror!\">Getenverror</a></h2>\u000a<code>func Getenverror(key string) (value string, err Error)</code>\u000a<p>\u000aGetenverror retrieves the value of the environment variable named by the key.\u000aIt returns the value and an error, if any.\u000a</p>\u000a\u000a","name":"Getenverror"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Geteuid!\">Geteuid</a></h2>\u000a<code>func Geteuid() int</code>\u000a<p>\u000aGeteuid returns the numeric effective user id of the caller.\u000a</p>\u000a\u000a","name":"Geteuid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getgid!\">Getgid</a></h2>\u000a<code>func Getgid() int</code>\u000a<p>\u000aGetgid returns the numeric group id of the caller.\u000a</p>\u000a\u000a","name":"Getgid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getgroups!\">Getgroups</a></h2>\u000a<code>func Getgroups() ([]int, Error)</code>\u000a<p>\u000aGetgroups returns a list of the numeric ids of groups that the caller belongs to.\u000a</p>\u000a\u000a","name":"Getgroups"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getpagesize!\">Getpagesize</a></h2>\u000a<code>func Getpagesize() int</code>\u000a<p>\u000aGetpagesize returns the underlying system&#39;s memory page size.\u000a</p>\u000a\u000a","name":"Getpagesize"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getpid!\">Getpid</a></h2>\u000a<code>func Getpid() int</code>\u000a<p>\u000aGetpid returns the process id of the caller.\u000a</p>\u000a\u000a","name":"Getpid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getppid!\">Getppid</a></h2>\u000a<code>func Getppid() int</code>\u000a<p>\u000aGetppid returns the process id of the caller&#39;s parent.\u000a</p>\u000a\u000a","name":"Getppid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getuid!\">Getuid</a></h2>\u000a<code>func Getuid() int</code>\u000a<p>\u000aGetuid returns the numeric user id of the caller.\u000a</p>\u000a\u000a","name":"Getuid"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Getwd!\">Getwd</a></h2>\u000a<code>func Getwd() (string, Error)</code>\u000a<p>\u000aGetwd returns a rooted path name corresponding to the\u000acurrent directory.  If the current directory can be\u000areached via multiple paths (due to symbolic links),\u000aGetwd may return any one of them.\u000a</p>\u000a\u000a","name":"Getwd"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Hostname!\">Hostname</a></h2>\u000a<code>func Hostname() (name string, err Error)</code>\u000a<p>\u000aHostname returns the host name reported by the kernel.\u000a</p>\u000a\u000a","name":"Hostname"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lchown!\">Lchown</a></h2>\u000a<code>func Lchown(name string, uid, gid int) Error</code>\u000a<p>\u000aLchown changes the numeric uid and gid of the named file.\u000aIf the file is a symbolic link, it changes the uid and gid of the link itself.\u000a</p>\u000a\u000a","name":"Lchown"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Link!\">Link</a></h2>\u000a<code>func Link(oldname, newname string) Error</code>\u000a<p>\u000aLink creates a hard link.\u000a</p>\u000a\u000a","name":"Link"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lstat!\">Lstat</a></h2>\u000a<code>func Lstat(name string) (fi *FileInfo, err Error)</code>\u000a<p>\u000aLstat returns the FileInfo structure describing the named file and an\u000aerror, if any.  If the file is a symbolic link, the returned FileInfo\u000adescribes the symbolic link.  Lstat makes no attempt to follow the link.\u000a</p>\u000a\u000a","name":"Lstat"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Mkdir!\">Mkdir</a></h2>\u000a<code>func Mkdir(name string, perm uint32) Error</code>\u000a<p>\u000aMkdir creates a new directory with the specified name and permission bits.\u000aIt returns an error, if any.\u000a</p>\u000a\u000a","name":"Mkdir"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MkdirAll!\">MkdirAll</a></h2>\u000a<code>func MkdirAll(path string, perm uint32) Error</code>\u000a<p>\u000aMkdirAll creates a directory named path,\u000aalong with any necessary parents, and returns nil,\u000aor else returns an error.\u000aThe permission bits perm are used for all\u000adirectories that MkdirAll creates.\u000aIf path is already a directory, MkdirAll does nothing\u000aand returns nil.\u000a</p>\u000a\u000a","name":"MkdirAll"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewError!\">NewError</a></h2>\u000a<code>func NewError(s string) Error</code>\u000a<p>\u000aNewError converts s to an ErrorString, which satisfies the Error interface.\u000a</p>\u000a\u000a","name":"NewError"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewFile!\">NewFile</a></h2>\u000a<code>func NewFile(fd int, name string) *File</code>\u000a<p>\u000aNewFile returns a new File with the given file descriptor and name.\u000a</p>\u000a\u000a","name":"NewFile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewSyscallError!\">NewSyscallError</a></h2>\u000a<code>func NewSyscallError(syscall string, errno int) Error</code>\u000a<p>\u000aNewSyscallError returns, as an Error, a new SyscallError\u000awith the given system call name and error number.\u000aAs a convenience, if errno is 0, NewSyscallError returns nil.\u000a</p>\u000a\u000a","name":"NewSyscallError"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Open!\">Open</a></h2>\u000a<code>func Open(name string, flag int, perm uint32) (file *File, err Error)</code>\u000a<p>\u000aOpen opens the named file with specified flag (O_RDONLY etc.) and perm, (0666 etc.)\u000aif applicable.  If successful, methods on the returned File can be used for I/O.\u000aIt returns the File and an Error, if any.\u000a</p>\u000a\u000a","name":"Open"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pipe!\">Pipe</a></h2>\u000a<code>func Pipe() (r *File, w *File, err Error)</code>\u000a<p>\u000aPipe returns a connected pair of Files; reads from r return bytes written to w.\u000aIt returns the files and an Error, if any.\u000a</p>\u000a\u000a","name":"Pipe"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Readlink!\">Readlink</a></h2>\u000a<code>func Readlink(name string) (string, Error)</code>\u000a<p>\u000aReadlink reads the contents of a symbolic link: the destination of\u000athe link.  It returns the contents and an Error, if any.\u000a</p>\u000a\u000a","name":"Readlink"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Remove!\">Remove</a></h2>\u000a<code>func Remove(name string) Error</code>\u000a<p>\u000aRemove removes the named file or directory.\u000a</p>\u000a\u000a","name":"Remove"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RemoveAll!\">RemoveAll</a></h2>\u000a<code>func RemoveAll(path string) Error</code>\u000a<p>\u000aRemoveAll removes path and any children it contains.\u000aIt removes everything it can but returns the first error\u000ait encounters.  If the path does not exist, RemoveAll\u000areturns nil (no error).\u000a</p>\u000a\u000a","name":"RemoveAll"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Rename!\">Rename</a></h2>\u000a<code>func Rename(oldname, newname string) Error</code>\u000a<p>\u000aRename renames a file.\u000a</p>\u000a\u000a","name":"Rename"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Setenv!\">Setenv</a></h2>\u000a<code>func Setenv(key, value string) Error</code>\u000a<p>\u000aSetenv sets the value of the environment variable named by the key.\u000aIt returns an Error, if any.\u000a</p>\u000a\u000a","name":"Setenv"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Stat!\">Stat</a></h2>\u000a<code>func Stat(name string) (fi *FileInfo, err Error)</code>\u000a<p>\u000aStat returns a FileInfo structure describing the named file and an error, if any.\u000aIf name names a valid symbolic link, the returned FileInfo describes\u000athe file pointed at by the link and has fi.FollowedSymlink set to true.\u000aIf name names an invalid symbolic link, the returned FileInfo describes\u000athe link itself and has fi.FollowedSymlink set to false.\u000a</p>\u000a\u000a","name":"Stat"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Symlink!\">Symlink</a></h2>\u000a<code>func Symlink(oldname, newname string) Error</code>\u000a<p>\u000aSymlink creates a symbolic link.\u000a</p>\u000a\u000a","name":"Symlink"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TempDir!\">TempDir</a></h2>\u000a<code>func TempDir() string</code>\u000a<p>\u000aTempDir returns the default directory to use for temporary files.\u000a</p>\u000a\u000a","name":"TempDir"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Time!\">Time</a></h2>\u000a<code>func Time() (sec int64, nsec int64, err Error)</code>\u000a<p>\u000aTime returns the current time, in whole seconds and\u000afractional nanoseconds, plus an Error if any. The current\u000atime is thus 1e9*sec+nsec, in nanoseconds.  The zero of\u000atime is the Unix epoch.\u000a</p>\u000a\u000a","name":"Time"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Truncate!\">Truncate</a></h2>\u000a<code>func Truncate(name string, size int64) Error</code>\u000a<p>\u000aTruncate changes the size of the named file.\u000aIf the file is a symbolic link, it changes the size of the link&#39;s target.\u000a</p>\u000a\u000a","name":"Truncate"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Wait!\">Wait</a></h2>\u000a<code>func Wait(pid int, options int) (w *Waitmsg, err Error)</code>\u000a<p>\u000aWait waits for process pid to exit or stop, and then returns a\u000aWaitmsg describing its status and an Error, if any. The options\u000a(WNOHANG etc.) affect the behavior of the Wait call.\u000a</p>\u000a\u000a","name":"Wait"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:WNOHANG!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009WNOHANG   = syscall.WNOHANG  // Don&#39;t wait if no process has exited.\u000a\u0009WSTOPPED  = syscall.WSTOPPED // If set, status of stopped subprocesses is also reported.\u000a\u0009WUNTRACED = WSTOPPED\u000a\u0009WRUSAGE   = 1 &lt;&lt; 20 // Record resource usage.\u000a)</pre>\u000a<p>\u000aOptions for Wait.\u000a</p>\u000a\u000a","names":["WNOHANG","WSTOPPED","WUNTRACED","WRUSAGE"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:O_RDONLY!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009O_RDONLY   int = syscall.O_RDONLY   // open the file read-only.\u000a\u0009O_WRONLY   int = syscall.O_WRONLY   // open the file write-only.\u000a\u0009O_RDWR     int = syscall.O_RDWR     // open the file read-write.\u000a\u0009O_APPEND   int = syscall.O_APPEND   // append data to the file when writing.\u000a\u0009O_ASYNC    int = syscall.O_ASYNC    // generate a signal when I/O is available.\u000a\u0009O_CREAT    int = syscall.O_CREAT    // create a new file if none exists.\u000a\u0009O_EXCL     int = syscall.O_EXCL     // used with O_CREAT, file must not exist\u000a\u0009O_NOCTTY   int = syscall.O_NOCTTY   // do not make file the controlling tty.\u000a\u0009O_NONBLOCK int = syscall.O_NONBLOCK // open in non-blocking mode.\u000a\u0009O_NDELAY   int = O_NONBLOCK         // synonym for O_NONBLOCK\u000a\u0009O_SYNC     int = syscall.O_SYNC     // open for synchronous I/O.\u000a\u0009O_TRUNC    int = syscall.O_TRUNC    // if possible, truncate file when opened.\u000a\u0009O_CREATE   int = O_CREAT            // create a new file if none exists.\u000a)</pre>\u000a<p>\u000aFlags to Open wrapping those of the underlying system. Not all flags\u000amay be implemented on a given system.\u000a</p>\u000a\u000a","names":["O_RDONLY","O_WRONLY","O_RDWR","O_APPEND","O_ASYNC","O_CREAT","O_EXCL","O_NOCTTY","O_NONBLOCK","O_NDELAY","O_SYNC","O_TRUNC","O_CREATE"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DevNull!\">DevNull</a></h2>\u000a<pre>const DevNull = &#34;/dev/null&#34;</pre>\u000a<p>\u000aDevNull is the name of the operating system&#39;s &ldquo;null device.&rdquo;\u000aOn Unix-like systems, it is &#34;/dev/null&#34;; on Windows, &#34;NUL&#34;.\u000a</p>\u000a\u000a","names":["DevNull"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Stdin!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009Stdin  = NewFile(syscall.Stdin, &#34;/dev/stdin&#34;)\u000a\u0009Stdout = NewFile(syscall.Stdout, &#34;/dev/stdout&#34;)\u000a\u0009Stderr = NewFile(syscall.Stderr, &#34;/dev/stderr&#34;)\u000a)</pre>\u000a<p>\u000aStdin, Stdout, and Stderr are open Files pointing to the standard input,\u000astandard output, and standard error file descriptors.\u000a</p>\u000a\u000a","names":["Stdin","Stdout","Stderr"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:EOF!\">EOF</a></h2>\u000a<pre>var EOF Error = eofError(0)</pre>\u000a<p>\u000aEOF is the Error returned by Read when no more input is available.\u000aFunctions should return EOF only to signal a graceful end of input.\u000aIf the EOF occurs unexpectedly in a structured data stream,\u000athe appropriate error is either io.ErrUnexpectedEOF or some other error\u000agiving more detail.\u000a</p>\u000a\u000a","names":["EOF"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:EPERM!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009EPERM        Error = Errno(syscall.EPERM)\u000a\u0009ENOENT       Error = Errno(syscall.ENOENT)\u000a\u0009ESRCH        Error = Errno(syscall.ESRCH)\u000a\u0009EINTR        Error = Errno(syscall.EINTR)\u000a\u0009EIO          Error = Errno(syscall.EIO)\u000a\u0009ENXIO        Error = Errno(syscall.ENXIO)\u000a\u0009E2BIG        Error = Errno(syscall.E2BIG)\u000a\u0009ENOEXEC      Error = Errno(syscall.ENOEXEC)\u000a\u0009EBADF        Error = Errno(syscall.EBADF)\u000a\u0009ECHILD       Error = Errno(syscall.ECHILD)\u000a\u0009EDEADLK      Error = Errno(syscall.EDEADLK)\u000a\u0009ENOMEM       Error = Errno(syscall.ENOMEM)\u000a\u0009EACCES       Error = Errno(syscall.EACCES)\u000a\u0009EFAULT       Error = Errno(syscall.EFAULT)\u000a\u0009EBUSY        Error = Errno(syscall.EBUSY)\u000a\u0009EEXIST       Error = Errno(syscall.EEXIST)\u000a\u0009EXDEV        Error = Errno(syscall.EXDEV)\u000a\u0009ENODEV       Error = Errno(syscall.ENODEV)\u000a\u0009ENOTDIR      Error = Errno(syscall.ENOTDIR)\u000a\u0009EISDIR       Error = Errno(syscall.EISDIR)\u000a\u0009EINVAL       Error = Errno(syscall.EINVAL)\u000a\u0009ENFILE       Error = Errno(syscall.ENFILE)\u000a\u0009EMFILE       Error = Errno(syscall.EMFILE)\u000a\u0009ENOTTY       Error = Errno(syscall.ENOTTY)\u000a\u0009EFBIG        Error = Errno(syscall.EFBIG)\u000a\u0009ENOSPC       Error = Errno(syscall.ENOSPC)\u000a\u0009ESPIPE       Error = Errno(syscall.ESPIPE)\u000a\u0009EROFS        Error = Errno(syscall.EROFS)\u000a\u0009EMLINK       Error = Errno(syscall.EMLINK)\u000a\u0009EPIPE        Error = Errno(syscall.EPIPE)\u000a\u0009EAGAIN       Error = Errno(syscall.EAGAIN)\u000a\u0009EDOM         Error = Errno(syscall.EDOM)\u000a\u0009ERANGE       Error = Errno(syscall.ERANGE)\u000a\u0009EADDRINUSE   Error = Errno(syscall.EADDRINUSE)\u000a\u0009ECONNREFUSED Error = Errno(syscall.ECONNREFUSED)\u000a\u0009ENAMETOOLONG Error = Errno(syscall.ENAMETOOLONG)\u000a\u0009EAFNOSUPPORT Error = Errno(syscall.EAFNOSUPPORT)\u000a)</pre>\u000a<p>\u000aCommonly known Unix errors.\u000a</p>\u000a\u000a","names":["EPERM","ENOENT","ESRCH","EINTR","EIO","ENXIO","E2BIG","ENOEXEC","EBADF","ECHILD","EDEADLK","ENOMEM","EACCES","EFAULT","EBUSY","EEXIST","EXDEV","ENODEV","ENOTDIR","EISDIR","EINVAL","ENFILE","EMFILE","ENOTTY","EFBIG","ENOSPC","ESPIPE","EROFS","EMLINK","EPIPE","EAGAIN","EDOM","ERANGE","EADDRINUSE","ECONNREFUSED","ENAMETOOLONG","EAFNOSUPPORT"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ENOENV!\">ENOENV</a></h2>\u000a<pre>var ENOENV = NewError(&#34;no such environment variable&#34;)</pre>\u000a<p>\u000aENOENV is the Error indicating that an environment variable does not exist.\u000a</p>\u000a\u000a","names":["ENOENV"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Args!\">Args</a></h2>\u000a<pre>var Args []string // provided by runtime\u000a</pre>\u000a\u000a","names":["Args"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Envs!\">Envs</a></h2>\u000a<pre>var Envs []string // provided by runtime\u000a</pre>\u000a\u000a","names":["Envs"],"type":""}]}