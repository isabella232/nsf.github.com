var gowtfData = {"index":"index.html","html":"<p>\u000aThis package implements multi-precision arithmetic (big numbers).\u000aThe following numeric types are supported:\u000a</p>\u000a<pre>- Int\u0009signed integers\u000a- Rat\u0009rational numbers\u000a</pre>\u000a<p>\u000aAll methods on Int take the result as the receiver; if it is one\u000aof the operands it may be overwritten (and its memory reused).\u000aTo enable chaining of operations, the result is also returned.\u000a</p>\u000a","name":"big","filenames":["/home/nsf/go/src/pkg/big/nat.go","/home/nsf/go/src/pkg/big/arith.go","/home/nsf/go/src/pkg/big/rat.go","/home/nsf/go/src/pkg/big/arith_decl.go","/home/nsf/go/src/pkg/big/int.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Int!\">Int</a></h2>\u000a<pre>type Int struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aAn Int represents a signed multi-precision integer.\u000aThe zero value for an Int represents the value 0.\u000a</p>\u000a\u000a","name":"Int","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Abs!\">Abs</a></h2>\u000a<code>func (z *Int) Abs(x *Int) *Int</code>\u000a<p>\u000aAbs sets z to |x| (the absolute value of x) and returns z.\u000a</p>\u000a\u000a","name":"Abs"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Add!\">Add</a></h2>\u000a<code>func (z *Int) Add(x, y *Int) *Int</code>\u000a<p>\u000aAdd sets z to the sum x+y and returns z.\u000a</p>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.And!\">And</a></h2>\u000a<code>func (z *Int) And(x, y *Int) *Int</code>\u000a<p>\u000aAnd sets z = x &amp; y and returns z.\u000a</p>\u000a\u000a","name":"And"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.AndNot!\">AndNot</a></h2>\u000a<code>func (z *Int) AndNot(x, y *Int) *Int</code>\u000a<p>\u000aAndNot sets z = x &amp;^ y and returns z.\u000a</p>\u000a\u000a","name":"AndNot"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Binomial!\">Binomial</a></h2>\u000a<code>func (z *Int) Binomial(n, k int64) *Int</code>\u000a<p>\u000aBinomial sets z to the binomial coefficient of (n, k) and returns z.\u000a</p>\u000a\u000a","name":"Binomial"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.BitLen!\">BitLen</a></h2>\u000a<code>func (z *Int) BitLen() int</code>\u000a<p>\u000aBitLen returns the length of the absolute value of z in bits.\u000aThe bit length of 0 is 0.\u000a</p>\u000a\u000a","name":"BitLen"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Bytes!\">Bytes</a></h2>\u000a<code>func (z *Int) Bytes() []byte</code>\u000a<p>\u000aBytes returns the absolute value of x as a big-endian byte array.\u000a</p>\u000a\u000a","name":"Bytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Cmp!\">Cmp</a></h2>\u000a<code>func (x *Int) Cmp(y *Int) (r int)</code>\u000a<p>\u000aCmp compares x and y and returns:\u000a</p>\u000a<pre>-1 if x &lt;  y\u000a 0 if x == y\u000a+1 if x &gt;  y\u000a</pre>\u000a\u000a","name":"Cmp"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Div!\">Div</a></h2>\u000a<code>func (z *Int) Div(x, y *Int) *Int</code>\u000a<p>\u000aDiv sets z to the quotient x/y for y != 0 and returns z.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000aSee DivMod for more details.\u000a</p>\u000a\u000a","name":"Div"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.DivMod!\">DivMod</a></h2>\u000a<code>func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)</code>\u000a<p>\u000aDivMod sets z to the quotient x div y and m to the modulus x mod y\u000aand returns the pair (z, m) for y != 0.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000a</p>\u000a<p>\u000aDivMod implements Euclidean division and modulus (unlike Go):\u000a</p>\u000a<pre>q = x div y  such that\u000am = x - y*q  with 0 &lt;= m &lt; |q|\u000a</pre>\u000a<p>\u000a(See Raymond T. Boute, &ldquo;The Euclidean definition of the functions\u000adiv and mod&rdquo;. ACM Transactions on Programming Languages and\u000aSystems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.\u000aACM press.)\u000a</p>\u000a\u000a","name":"DivMod"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Exp!\">Exp</a></h2>\u000a<code>func (z *Int) Exp(x, y, m *Int) *Int</code>\u000a<p>\u000aExp sets z = x**y mod m. If m is nil, z = x**y.\u000aSee Knuth, volume 2, section 4.6.3.\u000a</p>\u000a\u000a","name":"Exp"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Format!\">Format</a></h2>\u000a<code>func (x *Int) Format(s fmt.State, ch int)</code>\u000a<p>\u000aFormat is a support routine for fmt.Formatter. It accepts\u000athe formats &#39;b&#39; (binary), &#39;o&#39; (octal), &#39;d&#39; (decimal) and\u000a&#39;x&#39; (hexadecimal).\u000a</p>\u000a\u000a","name":"Format"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Int64!\">Int64</a></h2>\u000a<code>func (x *Int) Int64() int64</code>\u000a<p>\u000aInt64 returns the int64 representation of z.\u000aIf z cannot be represented in an int64, the result is undefined.\u000a</p>\u000a\u000a","name":"Int64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Lsh!\">Lsh</a></h2>\u000a<code>func (z *Int) Lsh(x *Int, n uint) *Int</code>\u000a<p>\u000aLsh sets z = x &lt;&lt; n and returns z.\u000a</p>\u000a\u000a","name":"Lsh"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Mod!\">Mod</a></h2>\u000a<code>func (z *Int) Mod(x, y *Int) *Int</code>\u000a<p>\u000aMod sets z to the modulus x%y for y != 0 and returns z.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000aSee DivMod for more details.\u000a</p>\u000a\u000a","name":"Mod"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.ModInverse!\">ModInverse</a></h2>\u000a<code>func (z *Int) ModInverse(g, p *Int) *Int</code>\u000a<p>\u000aModInverse sets z to the multiplicative inverse of g in the group ℤ/pℤ (where\u000ap is a prime) and returns z.\u000a</p>\u000a\u000a","name":"ModInverse"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Mul!\">Mul</a></h2>\u000a<code>func (z *Int) Mul(x, y *Int) *Int</code>\u000a<p>\u000aMul sets z to the product x*y and returns z.\u000a</p>\u000a\u000a","name":"Mul"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.MulRange!\">MulRange</a></h2>\u000a<code>func (z *Int) MulRange(a, b int64) *Int</code>\u000a<p>\u000aMulRange sets z to the product of all integers\u000ain the range [a, b] inclusively and returns z.\u000aIf a &gt; b (empty range), the result is 1.\u000a</p>\u000a\u000a","name":"MulRange"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Neg!\">Neg</a></h2>\u000a<code>func (z *Int) Neg(x *Int) *Int</code>\u000a<p>\u000aNeg sets z to -x and returns z.\u000a</p>\u000a\u000a","name":"Neg"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Not!\">Not</a></h2>\u000a<code>func (z *Int) Not(x *Int) *Int</code>\u000a<p>\u000aNot sets z = ^x and returns z.\u000a</p>\u000a\u000a","name":"Not"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Or!\">Or</a></h2>\u000a<code>func (z *Int) Or(x, y *Int) *Int</code>\u000a<p>\u000aOr sets z = x | y and returns z.\u000a</p>\u000a\u000a","name":"Or"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Quo!\">Quo</a></h2>\u000a<code>func (z *Int) Quo(x, y *Int) *Int</code>\u000a<p>\u000aQuo sets z to the quotient x/y for y != 0 and returns z.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000aSee QuoRem for more details.\u000a</p>\u000a\u000a","name":"Quo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.QuoRem!\">QuoRem</a></h2>\u000a<code>func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)</code>\u000a<p>\u000aQuoRem sets z to the quotient x/y and r to the remainder x%y\u000aand returns the pair (z, r) for y != 0.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000a</p>\u000a<p>\u000aQuoRem implements T-division and modulus (like Go):\u000a</p>\u000a<pre>q = x/y      with the result truncated to zero\u000ar = x - y*q\u000a</pre>\u000a<p>\u000a(See Daan Leijen, &ldquo;Division and Modulus for Computer Scientists&rdquo;.)\u000a</p>\u000a\u000a","name":"QuoRem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Rand!\">Rand</a></h2>\u000a<code>func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</code>\u000a<p>\u000aRand sets z to a pseudo-random number in [0, n) and returns z.\u000a</p>\u000a\u000a","name":"Rand"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Rem!\">Rem</a></h2>\u000a<code>func (z *Int) Rem(x, y *Int) *Int</code>\u000a<p>\u000aRem sets z to the remainder x%y for y != 0 and returns z.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000aSee QuoRem for more details.\u000a</p>\u000a\u000a","name":"Rem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Rsh!\">Rsh</a></h2>\u000a<code>func (z *Int) Rsh(x *Int, n uint) *Int</code>\u000a<p>\u000aRsh sets z = x &gt;&gt; n and returns z.\u000a</p>\u000a\u000a","name":"Rsh"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Set!\">Set</a></h2>\u000a<code>func (z *Int) Set(x *Int) *Int</code>\u000a<p>\u000aSet sets z to x and returns z.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.SetBytes!\">SetBytes</a></h2>\u000a<code>func (z *Int) SetBytes(b []byte) *Int</code>\u000a<p>\u000aSetBytes interprets b as the bytes of a big-endian, unsigned integer and\u000asets z to that value.\u000a</p>\u000a\u000a","name":"SetBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.SetInt64!\">SetInt64</a></h2>\u000a<code>func (z *Int) SetInt64(x int64) *Int</code>\u000a<p>\u000aSetInt64 sets z to x and returns z.\u000a</p>\u000a\u000a","name":"SetInt64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.SetString!\">SetString</a></h2>\u000a<code>func (z *Int) SetString(s string, base int) (*Int, bool)</code>\u000a<p>\u000aSetString sets z to the value of s, interpreted in the given base,\u000aand returns z and a boolean indicating success. If SetString fails,\u000athe value of z is undefined.\u000a</p>\u000a<p>\u000aIf the base argument is 0, the string prefix determines the actual\u000aconversion base. A prefix of &ldquo;0x&rdquo; or &ldquo;0X&rdquo; selects base 16; the\u000a&ldquo;0&rdquo; prefix selects base 8, and a &ldquo;0b&rdquo; or &ldquo;0B&rdquo; prefix selects\u000abase 2. Otherwise the selected base is 10.\u000a</p>\u000a\u000a","name":"SetString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Sign!\">Sign</a></h2>\u000a<code>func (x *Int) Sign() int</code>\u000a<p>\u000aSign returns:\u000a</p>\u000a<pre>-1 if x &lt;  0\u000a 0 if x == 0\u000a+1 if x &gt;  0\u000a</pre>\u000a\u000a","name":"Sign"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.String!\">String</a></h2>\u000a<code>func (x *Int) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Sub!\">Sub</a></h2>\u000a<code>func (z *Int) Sub(x, y *Int) *Int</code>\u000a<p>\u000aSub sets z to the difference x-y and returns z.\u000a</p>\u000a\u000a","name":"Sub"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Int\">func (*Int)</a> <a href=\"?m:Int.Xor!\">Xor</a></h2>\u000a<code>func (z *Int) Xor(x, y *Int) *Int</code>\u000a<p>\u000aXor sets z = x ^ y and returns z.\u000a</p>\u000a\u000a","name":"Xor"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Rat!\">Rat</a></h2>\u000a<pre>type Rat struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Rat represents a quotient a/b of arbitrary precision. The zero value for\u000aa Rat, 0/0, is not a legal Rat.\u000a</p>\u000a\u000a","name":"Rat","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Abs!\">Abs</a></h2>\u000a<code>func (z *Rat) Abs(x *Rat) *Rat</code>\u000a<p>\u000aAbs sets z to |x| (the absolute value of x) and returns z.\u000a</p>\u000a\u000a","name":"Abs"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Add!\">Add</a></h2>\u000a<code>func (z *Rat) Add(x, y *Rat) *Rat</code>\u000a<p>\u000aAdd sets z to the sum x+y and returns z.\u000a</p>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Cmp!\">Cmp</a></h2>\u000a<code>func (x *Rat) Cmp(y *Rat) (r int)</code>\u000a<p>\u000aCmp compares x and y and returns:\u000a</p>\u000a<pre>-1 if x &lt;  y\u000a 0 if x == y\u000a+1 if x &gt;  y\u000a</pre>\u000a\u000a","name":"Cmp"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Denom!\">Denom</a></h2>\u000a<code>func (z *Rat) Denom() *Int</code>\u000a<p>\u000aDemom returns the denominator of z; it is always &gt; 0.\u000aThe result is a reference to z&#39;s denominator; it\u000amay change if a new value is assigned to z.\u000a</p>\u000a\u000a","name":"Denom"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.FloatString!\">FloatString</a></h2>\u000a<code>func (z *Rat) FloatString(prec int) string</code>\u000a<p>\u000aFloatString returns a string representation of z in decimal form with prec\u000adigits of precision after the decimal point and the last digit rounded.\u000a</p>\u000a\u000a","name":"FloatString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.IsInt!\">IsInt</a></h2>\u000a<code>func (x *Rat) IsInt() bool</code>\u000a<p>\u000aIsInt returns true if the denominator of x is 1.\u000a</p>\u000a\u000a","name":"IsInt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Mul!\">Mul</a></h2>\u000a<code>func (z *Rat) Mul(x, y *Rat) *Rat</code>\u000a<p>\u000aMul sets z to the product x*y and returns z.\u000a</p>\u000a\u000a","name":"Mul"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Neg!\">Neg</a></h2>\u000a<code>func (z *Rat) Neg(x *Rat) *Rat</code>\u000a<p>\u000aNeg sets z to -x (by making a copy of x if necessary) and returns z.\u000a</p>\u000a\u000a","name":"Neg"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Num!\">Num</a></h2>\u000a<code>func (z *Rat) Num() *Int</code>\u000a<p>\u000aNum returns the numerator of z; it may be &lt;= 0.\u000aThe result is a reference to z&#39;s numerator; it\u000amay change if a new value is assigned to z.\u000a</p>\u000a\u000a","name":"Num"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Quo!\">Quo</a></h2>\u000a<code>func (z *Rat) Quo(x, y *Rat) *Rat</code>\u000a<p>\u000aQuo sets z to the quotient x/y and returns z.\u000aIf y == 0, a division-by-zero run-time panic occurs.\u000a</p>\u000a\u000a","name":"Quo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.RatString!\">RatString</a></h2>\u000a<code>func (z *Rat) RatString() string</code>\u000a<p>\u000aRatString returns a string representation of z in the form &#34;a/b&#34; if b != 1,\u000aand in the form &#34;a&#34; if b == 1.\u000a</p>\u000a\u000a","name":"RatString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Set!\">Set</a></h2>\u000a<code>func (z *Rat) Set(x *Rat) *Rat</code>\u000a<p>\u000aSet sets z to x (by making a copy of x if necessary) and returns z.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.SetFrac!\">SetFrac</a></h2>\u000a<code>func (z *Rat) SetFrac(a, b *Int) *Rat</code>\u000a<p>\u000aSetFrac sets z to a/b and returns z.\u000a</p>\u000a\u000a","name":"SetFrac"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.SetFrac64!\">SetFrac64</a></h2>\u000a<code>func (z *Rat) SetFrac64(a, b int64) *Rat</code>\u000a<p>\u000aSetFrac64 sets z to a/b and returns z.\u000a</p>\u000a\u000a","name":"SetFrac64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.SetInt!\">SetInt</a></h2>\u000a<code>func (z *Rat) SetInt(x *Int) *Rat</code>\u000a<p>\u000aSetInt sets z to x (by making a copy of x) and returns z.\u000a</p>\u000a\u000a","name":"SetInt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.SetInt64!\">SetInt64</a></h2>\u000a<code>func (z *Rat) SetInt64(x int64) *Rat</code>\u000a<p>\u000aSetInt64 sets z to x and returns z.\u000a</p>\u000a\u000a","name":"SetInt64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.SetString!\">SetString</a></h2>\u000a<code>func (z *Rat) SetString(s string) (*Rat, bool)</code>\u000a<p>\u000aSetString sets z to the value of s and returns z and a boolean indicating\u000asuccess. s can be given as a fraction &#34;a/b&#34; or as a floating-point number\u000aoptionally followed by an exponent. If the operation failed, the value of z\u000ais undefined.\u000a</p>\u000a\u000a","name":"SetString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Sign!\">Sign</a></h2>\u000a<code>func (x *Rat) Sign() int</code>\u000a<p>\u000aSign returns:\u000a</p>\u000a<pre>-1 if x &lt;  0\u000a 0 if x == 0\u000a+1 if x &gt;  0\u000a</pre>\u000a\u000a","name":"Sign"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.String!\">String</a></h2>\u000a<code>func (z *Rat) String() string</code>\u000a<p>\u000aString returns a string representation of z in the form &#34;a/b&#34; (even if b == 1).\u000a</p>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rat\">func (*Rat)</a> <a href=\"?m:Rat.Sub!\">Sub</a></h2>\u000a<code>func (z *Rat) Sub(x, y *Rat) *Rat</code>\u000a<p>\u000aSub sets z to the difference x-y and returns z.\u000a</p>\u000a\u000a","name":"Sub"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Word!\">Word</a></h2>\u000a<pre>type Word uintptr</pre>\u000a\u000a","name":"Word","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GcdInt!\">GcdInt</a></h2>\u000a<code>func GcdInt(d, x, y, a, b *Int)</code>\u000a<p>\u000aGcdInt sets d to the greatest common divisor of a and b, which must be\u000apositive numbers.\u000aIf x and y are not nil, GcdInt sets x and y such that d = a*x + b*y.\u000aIf either a or b is not positive, GcdInt sets d = x = y = 0.\u000a</p>\u000a\u000a","name":"GcdInt"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewInt!\">NewInt</a></h2>\u000a<code>func NewInt(x int64) *Int</code>\u000a<p>\u000aNewInt allocates and returns a new Int set to x.\u000a</p>\u000a\u000a","name":"NewInt"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRat!\">NewRat</a></h2>\u000a<code>func NewRat(a, b int64) *Rat</code>\u000a<p>\u000aNewRat creates a new Rat with numerator a and denominator b.\u000a</p>\u000a\u000a","name":"NewRat"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ProbablyPrime!\">ProbablyPrime</a></h2>\u000a<code>func ProbablyPrime(z *Int, n int) bool</code>\u000a<p>\u000aProbablyPrime performs n Miller-Rabin tests to check whether z is prime.\u000aIf it returns true, z is prime with probability 1 - 1/4^n.\u000aIf it returns false, z is not prime.\u000a</p>\u000a\u000a","name":"ProbablyPrime"}],"consts":[],"vars":[]}