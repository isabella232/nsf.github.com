var gowtfData = {"html":"<p>\u000aPackage regexp implements a simple regular expression library.\u000a</p>\u000a<p>\u000aThe syntax of the regular expressions accepted is:\u000a</p>\u000a<pre>regexp:\u000a\u0009concatenation { &#39;|&#39; concatenation }\u000aconcatenation:\u000a\u0009{ closure }\u000aclosure:\u000a\u0009term [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]\u000aterm:\u000a\u0009&#39;^&#39;\u000a\u0009&#39;$&#39;\u000a\u0009&#39;.&#39;\u000a\u0009character\u000a\u0009&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;\u000a\u0009&#39;(&#39; regexp &#39;)&#39;\u000acharacter-range:\u000a\u0009character [ &#39;-&#39; character ]\u000a</pre>\u000a<p>\u000aAll characters are UTF-8-encoded code points.  Backslashes escape special\u000acharacters, including inside character classes.  The standard Go character\u000aescapes are also recognized: \\a \\b \\f \\n \\r \\t \\v.\u000a</p>\u000a<p>\u000aThere are 16 methods of Regexp that match a regular expression and identify\u000athe matched text.  Their names are matched by this regular expression:\u000a</p>\u000a<pre>Find(All)?(String)?(Submatch)?(Index)?\u000a</pre>\u000a<p>\u000aIf &#39;All&#39; is present, the routine matches successive non-overlapping\u000amatches of the entire expression.  Empty matches abutting a preceding\u000amatch are ignored.  The return value is a slice containing the successive\u000areturn values of the corresponding non-&#39;All&#39; routine.  These routines take\u000aan extra integer argument, n; if n &gt;= 0, the function returns at most n\u000amatches/submatches.\u000a</p>\u000a<p>\u000aIf &#39;String&#39; is present, the argument is a string; otherwise it is a slice\u000aof bytes; return values are adjusted as appropriate.\u000a</p>\u000a<p>\u000aIf &#39;Submatch&#39; is present, the return value is a slice identifying the\u000asuccessive submatches of the expression.  Submatches are matches of\u000aparenthesized subexpressions within the regular expression, numbered from\u000aleft to right in order of opening parenthesis.  Submatch 0 is the match of\u000athe entire expression, submatch 1 the match of the first parenthesized\u000asubexpression, and so on.\u000a</p>\u000a<p>\u000aIf &#39;Index&#39; is present, matches and submatches are identified by byte index\u000apairs within the input string: result[2*n:2*n+1] identifies the indexes of\u000athe nth submatch.  The pair for n==0 identifies the match of the entire\u000aexpression.  If &#39;Index&#39; is not present, the match is identified by the\u000atext of the match/submatch.  If an index is negative, it means that\u000asubexpression did not match any string in the input.\u000a</p>\u000a<p>\u000a(There are a few other methods that do not match this pattern.)\u000a</p>\u000a","name":"regexp","filenames":["/home/nsf/go/src/pkg/regexp/regexp.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error string</pre>\u000a<p>\u000aError is the local type for a parsing error.\u000a</p>\u000a\u000a","name":"Error","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Error\">func (Error)</a> <a href=\"?m:Error.String!\">String</a></h2>\u000a<code>func (e Error) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Regexp!\">Regexp</a></h2>\u000a<pre>type Regexp struct {\u000a\u0009expr        string // the original expression\u000a\u0009prefix      string // initial plain text string\u000a\u0009prefixBytes []byte // initial plain text bytes\u000a\u0009inst        []instr\u000a\u0009start       instr // first instruction of machine\u000a\u0009prefixStart instr // where to start if there is a prefix\u000a\u0009nbra        int   // number of brackets in expression, for subexpressions\u000a}</pre>\u000a<p>\u000aRegexp is the representation of a compiled regular expression.\u000aThe public interface is entirely through methods.\u000a</p>\u000a\u000a","name":"Regexp","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.Find!\">Find</a></h2>\u000a<code>func (re *Regexp) Find(b []byte) []byte</code>\u000a<p>\u000aFind returns a slice holding the text of the leftmost match in b of the regular expression.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"Find"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAll!\">FindAll</a></h2>\u000a<code>func (re *Regexp) FindAll(b []byte, n int) [][]byte</code>\u000a<p>\u000aFindAll is the &#39;All&#39; version of Find; it returns a slice of all successive\u000amatches of the expression, as defined by the &#39;All&#39; description in the\u000apackage comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAll"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllIndex!\">FindAllIndex</a></h2>\u000a<code>func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</code>\u000a<p>\u000aFindAllIndex is the &#39;All&#39; version of FindIndex; it returns a slice of all\u000asuccessive matches of the expression, as defined by the &#39;All&#39; description\u000ain the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllString!\">FindAllString</a></h2>\u000a<code>func (re *Regexp) FindAllString(s string, n int) []string</code>\u000a<p>\u000aFindAllString is the &#39;All&#39; version of FindString; it returns a slice of all\u000asuccessive matches of the expression, as defined by the &#39;All&#39; description\u000ain the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringIndex!\">FindAllStringIndex</a></h2>\u000a<code>func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</code>\u000a<p>\u000aFindAllStringIndex is the &#39;All&#39; version of FindStringIndex; it returns a\u000aslice of all successive matches of the expression, as defined by the &#39;All&#39;\u000adescription in the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllStringIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringSubmatch!\">FindAllStringSubmatch</a></h2>\u000a<code>func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</code>\u000a<p>\u000aFindAllStringSubmatch is the &#39;All&#39; version of FindStringSubmatch; it\u000areturns a slice of all successive matches of the expression, as defined by\u000athe &#39;All&#39; description in the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllStringSubmatch"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringSubmatchIndex!\">FindAllStringSubmatchIndex</a></h2>\u000a<code>func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</code>\u000a<p>\u000aFindAllStringSubmatchIndex is the &#39;All&#39; version of\u000aFindStringSubmatchIndex; it returns a slice of all successive matches of\u000athe expression, as defined by the &#39;All&#39; description in the package\u000acomment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllStringSubmatchIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllSubmatch!\">FindAllSubmatch</a></h2>\u000a<code>func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</code>\u000a<p>\u000aFindAllSubmatch is the &#39;All&#39; version of FindSubmatch; it returns a slice\u000aof all successive matches of the expression, as defined by the &#39;All&#39;\u000adescription in the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllSubmatch"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllSubmatchIndex!\">FindAllSubmatchIndex</a></h2>\u000a<code>func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</code>\u000a<p>\u000aFindAllSubmatchIndex is the &#39;All&#39; version of FindSubmatchIndex; it returns\u000aa slice of all successive matches of the expression, as defined by the\u000a&#39;All&#39; description in the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindAllSubmatchIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindIndex!\">FindIndex</a></h2>\u000a<code>func (re *Regexp) FindIndex(b []byte) (loc []int)</code>\u000a<p>\u000aFindIndex returns a two-element slice of integers defining the location of\u000athe leftmost match in b of the regular expression.  The match itself is at\u000ab[loc[0]:loc[1]].\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindString!\">FindString</a></h2>\u000a<code>func (re *Regexp) FindString(s string) string</code>\u000a<p>\u000aFindString returns a string holding the text of the leftmost match in s of the regular\u000aexpression.  If there is no match, the return value is an empty string,\u000abut it will also be empty if the regular expression successfully matches\u000aan empty string.  Use FindStringIndex or FindStringSubmatch if it is\u000anecessary to distinguish these cases.\u000a</p>\u000a\u000a","name":"FindString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringIndex!\">FindStringIndex</a></h2>\u000a<code>func (re *Regexp) FindStringIndex(s string) []int</code>\u000a<p>\u000aFindStringIndex returns a two-element slice of integers defining the\u000alocation of the leftmost match in s of the regular expression.  The match\u000aitself is at s[loc[0]:loc[1]].\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindStringIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringSubmatch!\">FindStringSubmatch</a></h2>\u000a<code>func (re *Regexp) FindStringSubmatch(s string) []string</code>\u000a<p>\u000aFindStringSubmatch returns a slice of strings holding the text of the\u000aleftmost match of the regular expression in s and the matches, if any, of\u000aits subexpressions, as defined by the &#39;Submatch&#39; description in the\u000apackage comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindStringSubmatch"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringSubmatchIndex!\">FindStringSubmatchIndex</a></h2>\u000a<code>func (re *Regexp) FindStringSubmatchIndex(s string) []int</code>\u000a<p>\u000aFindStringSubmatchIndex returns a slice holding the index pairs\u000aidentifying the leftmost match of the regular expression in s and the\u000amatches, if any, of its subexpressions, as defined by the &#39;Submatch&#39; and\u000a&#39;Index&#39; descriptions in the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindStringSubmatchIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindSubmatch!\">FindSubmatch</a></h2>\u000a<code>func (re *Regexp) FindSubmatch(b []byte) [][]byte</code>\u000a<p>\u000aFindSubmatch returns a slice of slices holding the text of the leftmost\u000amatch of the regular expression in b and the matches, if any, of its\u000asubexpressions, as defined by the &#39;Submatch&#39; descriptions in the package\u000acomment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindSubmatch"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindSubmatchIndex!\">FindSubmatchIndex</a></h2>\u000a<code>func (re *Regexp) FindSubmatchIndex(b []byte) []int</code>\u000a<p>\u000aFindSubmatchIndex returns a slice holding the index pairs identifying the\u000aleftmost match of the regular expression in b and the matches, if any, of\u000aits subexpressions, as defined by the &#39;Submatch&#39; and &#39;Index&#39; descriptions\u000ain the package comment.\u000aA return value of nil indicates no match.\u000a</p>\u000a\u000a","name":"FindSubmatchIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.Match!\">Match</a></h2>\u000a<code>func (re *Regexp) Match(b []byte) bool</code>\u000a<p>\u000aMatch returns whether the Regexp matches the byte slice b.\u000aThe return value is a boolean: true for match, false for no match.\u000a</p>\u000a\u000a","name":"Match"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.MatchString!\">MatchString</a></h2>\u000a<code>func (re *Regexp) MatchString(s string) bool</code>\u000a<p>\u000aMatchString returns whether the Regexp matches the string s.\u000aThe return value is a boolean: true for match, false for no match.\u000a</p>\u000a\u000a","name":"MatchString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.NumSubexp!\">NumSubexp</a></h2>\u000a<code>func (re *Regexp) NumSubexp() int</code>\u000a<p>\u000aNumSubexp returns the number of parenthesized subexpressions in this Regexp.\u000a</p>\u000a\u000a","name":"NumSubexp"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAll!\">ReplaceAll</a></h2>\u000a<code>func (re *Regexp) ReplaceAll(src, repl []byte) []byte</code>\u000a<p>\u000aReplaceAll returns a copy of src in which all matches for the Regexp\u000ahave been replaced by repl.  No support is provided for expressions\u000a(e.g. \\1 or $1) in the replacement text.\u000a</p>\u000a\u000a","name":"ReplaceAll"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllFunc!\">ReplaceAllFunc</a></h2>\u000a<code>func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</code>\u000a<p>\u000aReplaceAllFunc returns a copy of src in which all matches for the\u000aRegexp have been replaced by the return value of of function repl (whose\u000afirst argument is the matched []byte).  No support is provided for\u000aexpressions (e.g. \\1 or $1) in the replacement string.\u000a</p>\u000a\u000a","name":"ReplaceAllFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllString!\">ReplaceAllString</a></h2>\u000a<code>func (re *Regexp) ReplaceAllString(src, repl string) string</code>\u000a<p>\u000aReplaceAllString returns a copy of src in which all matches for the Regexp\u000ahave been replaced by repl.  No support is provided for expressions\u000a(e.g. \\1 or $1) in the replacement string.\u000a</p>\u000a\u000a","name":"ReplaceAllString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllStringFunc!\">ReplaceAllStringFunc</a></h2>\u000a<code>func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</code>\u000a<p>\u000aReplaceAllStringFunc returns a copy of src in which all matches for the\u000aRegexp have been replaced by the return value of of function repl (whose\u000afirst argument is the matched string).  No support is provided for\u000aexpressions (e.g. \\1 or $1) in the replacement string.\u000a</p>\u000a\u000a","name":"ReplaceAllStringFunc"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Compile!\">Compile</a></h2>\u000a<code>func Compile(str string) (regexp *Regexp, error os.Error)</code>\u000a<p>\u000aCompile parses a regular expression and returns, if successful, a Regexp\u000aobject that can be used to match against text.\u000a</p>\u000a\u000a","name":"Compile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Match!\">Match</a></h2>\u000a<code>func Match(pattern string, b []byte) (matched bool, error os.Error)</code>\u000a<p>\u000aMatch checks whether a textual regular expression\u000amatches a byte slice.  More complicated queries need\u000ato use Compile and the full Regexp interface.\u000a</p>\u000a\u000a","name":"Match"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MatchString!\">MatchString</a></h2>\u000a<code>func MatchString(pattern string, s string) (matched bool, error os.Error)</code>\u000a<p>\u000aMatchString checks whether a textual regular expression\u000amatches a string.  More complicated queries need\u000ato use Compile and the full Regexp interface.\u000a</p>\u000a\u000a","name":"MatchString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MustCompile!\">MustCompile</a></h2>\u000a<code>func MustCompile(str string) *Regexp</code>\u000a<p>\u000aMustCompile is like Compile but panics if the expression cannot be parsed.\u000aIt simplifies safe initialization of global variables holding compiled regular\u000aexpressions.\u000a</p>\u000a\u000a","name":"MustCompile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:QuoteMeta!\">QuoteMeta</a></h2>\u000a<code>func QuoteMeta(s string) string</code>\u000a<p>\u000aQuoteMeta returns a string that quotes all regular expression metacharacters\u000ainside the argument text; the returned string is a regular expression matching\u000athe literal text.  For example, QuoteMeta(`[foo]`) returns `\\[foo\\]`.\u000a</p>\u000a\u000a","name":"QuoteMeta"}],"consts":[],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrInternal!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009ErrInternal            = Error(&#34;internal error&#34;)\u000a\u0009ErrUnmatchedLpar       = Error(&#34;unmatched &#39;(&#39;&#34;)\u000a\u0009ErrUnmatchedRpar       = Error(&#34;unmatched &#39;)&#39;&#34;)\u000a\u0009ErrUnmatchedLbkt       = Error(&#34;unmatched &#39;[&#39;&#34;)\u000a\u0009ErrUnmatchedRbkt       = Error(&#34;unmatched &#39;]&#39;&#34;)\u000a\u0009ErrBadRange            = Error(&#34;bad range in character class&#34;)\u000a\u0009ErrExtraneousBackslash = Error(&#34;extraneous backslash&#34;)\u000a\u0009ErrBadClosure          = Error(&#34;repeated closure (**, ++, etc.)&#34;)\u000a\u0009ErrBareClosure         = Error(&#34;closure applies to nothing&#34;)\u000a\u0009ErrBadBackslash        = Error(&#34;illegal backslash escape&#34;)\u000a)</pre>\u000a<p>\u000aError codes returned by failures to parse an expression.\u000a</p>\u000a\u000a","names":["ErrInternal","ErrUnmatchedLpar","ErrUnmatchedRpar","ErrUnmatchedLbkt","ErrUnmatchedRbkt","ErrBadRange","ErrExtraneousBackslash","ErrBadClosure","ErrBareClosure","ErrBadBackslash"],"type":""}]}