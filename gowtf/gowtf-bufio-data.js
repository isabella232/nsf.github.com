var gowtfData = {"index":"index.html","html":"<p>\u000aThis package implements buffered I/O.  It wraps an io.Reader or io.Writer\u000aobject, creating another object (Reader or Writer) that also implements\u000athe interface but provides buffering and some help for textual I/O.\u000a</p>\u000a","name":"bufio","filenames":["/home/nsf/go/src/pkg/bufio/bufio.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BufSizeError!\">BufSizeError</a></h2>\u000a<pre>type BufSizeError int</pre>\u000a<p>\u000aBufSizeError is the error representing an invalid buffer size.\u000a</p>\u000a\u000a","name":"BufSizeError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:BufSizeError\">func (BufSizeError)</a> <a href=\"?m:BufSizeError.String!\">String</a></h2>\u000a<code>func (b BufSizeError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error struct {\u000a\u0009os.ErrorString\u000a}</pre>\u000a<p>\u000aErrors introduced by this package.\u000a</p>\u000a\u000a","name":"Error","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriter!\">ReadWriter</a></h2>\u000a<pre>type ReadWriter struct {\u000a\u0009*Reader\u000a\u0009*Writer\u000a}</pre>\u000a<p>\u000aReadWriter stores pointers to a Reader and a Writer.\u000aIt implements io.ReadWriter.\u000a</p>\u000a\u000a","name":"ReadWriter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\u000a<pre>type Reader struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aReader implements buffering for an io.Reader object.\u000a</p>\u000a\u000a","name":"Reader","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Buffered!\">Buffered</a></h2>\u000a<code>func (b *Reader) Buffered() int</code>\u000a<p>\u000aBuffered returns the number of bytes that can be read from the current buffer.\u000a</p>\u000a\u000a","name":"Buffered"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Peek!\">Peek</a></h2>\u000a<code>func (b *Reader) Peek(n int) ([]byte, os.Error)</code>\u000a<p>\u000aPeek returns the next n bytes without advancing the reader. The bytes stop\u000abeing valid at the next read call. If Peek returns fewer than n bytes, it\u000aalso returns an error explaining why the read is short. The error is\u000aErrBufferFull if n is larger than b&#39;s buffer size.\u000a</p>\u000a\u000a","name":"Peek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Read!\">Read</a></h2>\u000a<code>func (b *Reader) Read(p []byte) (nn int, err os.Error)</code>\u000a<p>\u000aRead reads data into p.\u000aIt returns the number of bytes read into p.\u000aIf nn &lt; len(p), also returns an error explaining\u000awhy the read is short.  At EOF, the count will be\u000azero and err will be os.EOF.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadByte!\">ReadByte</a></h2>\u000a<code>func (b *Reader) ReadByte() (c byte, err os.Error)</code>\u000a<p>\u000aReadByte reads and returns a single byte.\u000aIf no byte is available, returns an error.\u000a</p>\u000a\u000a","name":"ReadByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadBytes!\">ReadBytes</a></h2>\u000a<code>func (b *Reader) ReadBytes(delim byte) (line []byte, err os.Error)</code>\u000a<p>\u000aReadBytes reads until the first occurrence of delim in the input,\u000areturning a slice containing the data up to and including the delimiter.\u000aIf ReadBytes encounters an error before finding a delimiter,\u000ait returns the data read before the error and the error itself (often os.EOF).\u000aReadBytes returns err != nil if and only if line does not end in delim.\u000a</p>\u000a\u000a","name":"ReadBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadRune!\">ReadRune</a></h2>\u000a<code>func (b *Reader) ReadRune() (rune int, size int, err os.Error)</code>\u000a<p>\u000aReadRune reads a single UTF-8 encoded Unicode character and returns the\u000arune and its size in bytes.\u000a</p>\u000a\u000a","name":"ReadRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadSlice!\">ReadSlice</a></h2>\u000a<code>func (b *Reader) ReadSlice(delim byte) (line []byte, err os.Error)</code>\u000a<p>\u000aReadSlice reads until the first occurrence of delim in the input,\u000areturning a slice pointing at the bytes in the buffer.\u000aThe bytes stop being valid at the next read call.\u000aIf ReadSlice encounters an error before finding a delimiter,\u000ait returns all the data in the buffer and the error itself (often os.EOF).\u000aReadSlice fails with error ErrBufferFull if the buffer fills without a delim.\u000aBecause the data returned from ReadSlice will be overwritten\u000aby the next I/O operation, most clients should use\u000aReadBytes or ReadString instead.\u000aReadSlice returns err != nil if and only if line does not end in delim.\u000a</p>\u000a\u000a","name":"ReadSlice"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadString!\">ReadString</a></h2>\u000a<code>func (b *Reader) ReadString(delim byte) (line string, err os.Error)</code>\u000a<p>\u000aReadString reads until the first occurrence of delim in the input,\u000areturning a string containing the data up to and including the delimiter.\u000aIf ReadString encounters an error before finding a delimiter,\u000ait returns the data read before the error and the error itself (often os.EOF).\u000aReadString returns err != nil if and only if line does not end in delim.\u000a</p>\u000a\u000a","name":"ReadString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.UnreadByte!\">UnreadByte</a></h2>\u000a<code>func (b *Reader) UnreadByte() os.Error</code>\u000a<p>\u000aUnreadByte unreads the last byte.  Only the most recently read byte can be unread.\u000a</p>\u000a\u000a","name":"UnreadByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.UnreadRune!\">UnreadRune</a></h2>\u000a<code>func (b *Reader) UnreadRune() os.Error</code>\u000a<p>\u000aUnreadRune unreads the last rune.  If the most recent read operation on\u000athe buffer was not a ReadRune, UnreadRune returns an error.  (In this\u000aregard it is stricter than UnreadByte, which will unread the last byte\u000afrom any read operation.)\u000a</p>\u000a\u000a","name":"UnreadRune"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\u000a<pre>type Writer struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aWriter implements buffering for an io.Writer object.\u000a</p>\u000a\u000a","name":"Writer","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Available!\">Available</a></h2>\u000a<code>func (b *Writer) Available() int</code>\u000a<p>\u000aAvailable returns how many bytes are unused in the buffer.\u000a</p>\u000a\u000a","name":"Available"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Buffered!\">Buffered</a></h2>\u000a<code>func (b *Writer) Buffered() int</code>\u000a<p>\u000aBuffered returns the number of bytes that have been written into the current buffer.\u000a</p>\u000a\u000a","name":"Buffered"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Flush!\">Flush</a></h2>\u000a<code>func (b *Writer) Flush() os.Error</code>\u000a<p>\u000aFlush writes any buffered data to the underlying io.Writer.\u000a</p>\u000a\u000a","name":"Flush"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Write!\">Write</a></h2>\u000a<code>func (b *Writer) Write(p []byte) (nn int, err os.Error)</code>\u000a<p>\u000aWrite writes the contents of p into the buffer.\u000aIt returns the number of bytes written.\u000aIf nn &lt; len(p), it also returns an error explaining\u000awhy the write is short.\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.WriteByte!\">WriteByte</a></h2>\u000a<code>func (b *Writer) WriteByte(c byte) os.Error</code>\u000a<p>\u000aWriteByte writes a single byte.\u000a</p>\u000a\u000a","name":"WriteByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.WriteRune!\">WriteRune</a></h2>\u000a<code>func (b *Writer) WriteRune(rune int) (size int, err os.Error)</code>\u000a<p>\u000aWriteRune writes a single Unicode code point, returning\u000athe number of bytes written and any error.\u000a</p>\u000a\u000a","name":"WriteRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.WriteString!\">WriteString</a></h2>\u000a<code>func (b *Writer) WriteString(s string) (int, os.Error)</code>\u000a<p>\u000aWriteString writes a string.\u000aIt returns the number of bytes written.\u000aIf the count is less than len(s), it also returns an error explaining\u000awhy the write is short.\u000a</p>\u000a\u000a","name":"WriteString"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReadWriter!\">NewReadWriter</a></h2>\u000a<code>func NewReadWriter(r *Reader, w *Writer) *ReadWriter</code>\u000a<p>\u000aNewReadWriter allocates a new ReadWriter that dispatches to r and w.\u000a</p>\u000a\u000a","name":"NewReadWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\u000a<code>func NewReader(rd io.Reader) *Reader</code>\u000a<p>\u000aNewReader returns a new Reader whose buffer has the default size.\u000a</p>\u000a\u000a","name":"NewReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReaderSize!\">NewReaderSize</a></h2>\u000a<code>func NewReaderSize(rd io.Reader, size int) (*Reader, os.Error)</code>\u000a<p>\u000aNewReaderSize creates a new Reader whose buffer has the specified size,\u000awhich must be greater than zero.  If the argument io.Reader is already a\u000aReader with large enough size, it returns the underlying Reader.\u000aIt returns the Reader and any error.\u000a</p>\u000a\u000a","name":"NewReaderSize"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(wr io.Writer) *Writer</code>\u000a<p>\u000aNewWriter returns a new Writer whose buffer has the default size.\u000a</p>\u000a\u000a","name":"NewWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriterSize!\">NewWriterSize</a></h2>\u000a<code>func NewWriterSize(wr io.Writer, size int) (*Writer, os.Error)</code>\u000a<p>\u000aNewWriterSize creates a new Writer whose buffer has the specified size,\u000awhich must be greater than zero. If the argument io.Writer is already a\u000aWriter with large enough size, it returns the underlying Writer.\u000aIt returns the Writer and any error.\u000a</p>\u000a\u000a","name":"NewWriterSize"}],"consts":[],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrInvalidUnreadByte!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009ErrInvalidUnreadByte os.Error = &amp;Error{&#34;bufio: invalid use of UnreadByte&#34;}\u000a\u0009ErrInvalidUnreadRune os.Error = &amp;Error{&#34;bufio: invalid use of UnreadRune&#34;}\u000a\u0009ErrBufferFull        os.Error = &amp;Error{&#34;bufio: buffer full&#34;}\u000a\u0009ErrNegativeCount     os.Error = &amp;Error{&#34;bufio: negative count&#34;}\u000a)</pre>\u000a\u000a","names":["ErrInvalidUnreadByte","ErrInvalidUnreadRune","ErrBufferFull","ErrNegativeCount"],"type":""}]}