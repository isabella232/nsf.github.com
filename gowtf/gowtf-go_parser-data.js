var gowtfData = {"index":"index.html","html":"<p>\u000aA parser for Go source files. Input may be provided in a variety of\u000aforms (see the various Parse* functions); the output is an abstract\u000asyntax tree (AST) representing the Go source. The parser is invoked\u000athrough one of the Parse* functions.\u000a</p>\u000a","name":"parser","filenames":["/home/nsf/go/src/pkg/go/parser/interface.go","/home/nsf/go/src/pkg/go/parser/parser.go"],"types":[],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseDeclList!\">ParseDeclList</a></h2>\u000a<code>func ParseDeclList(filename string, src interface{}) ([]ast.Decl, os.Error)</code>\u000a<p>\u000aParseDeclList parses a list of Go declarations and returns the list\u000aof corresponding AST nodes.  The filename and src arguments have the same\u000ainterpretation as for ParseFile. If there is an error, the node\u000alist may be nil or contain partial ASTs.\u000a</p>\u000a\u000a","name":"ParseDeclList"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseDir!\">ParseDir</a></h2>\u000a<code>func ParseDir(path string, filter func(*os.FileInfo) bool, mode uint) (map[string]*ast.Package, os.Error)</code>\u000a<p>\u000aParseDir calls ParseFile for the files in the directory specified by path and\u000areturns a map of package name -&gt; package AST with all the packages found. If\u000afilter != nil, only the files with os.FileInfo entries passing through the filter\u000aare considered. The mode bits are passed to ParseFile unchanged.\u000a</p>\u000a<p>\u000aIf the directory couldn&#39;t be read, a nil map and the respective error are\u000areturned. If a parse error occured, a non-nil but incomplete map and the\u000aerror are returned.\u000a</p>\u000a\u000a","name":"ParseDir"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseExpr!\">ParseExpr</a></h2>\u000a<code>func ParseExpr(filename string, src interface{}) (ast.Expr, os.Error)</code>\u000a<p>\u000aParseExpr parses a Go expression and returns the corresponding\u000aAST node. The filename and src arguments have the same interpretation\u000aas for ParseFile. If there is an error, the result expression\u000amay be nil or contain a partial AST.\u000a</p>\u000a\u000a","name":"ParseExpr"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseFile!\">ParseFile</a></h2>\u000a<code>func ParseFile(filename string, src interface{}, mode uint) (*ast.File, os.Error)</code>\u000a<p>\u000aParseFile parses a Go source file and returns a File node.\u000a</p>\u000a<p>\u000aIf src != nil, ParseFile parses the file source from src. src may\u000abe provided in a variety of formats. At the moment the following types\u000aare supported: string, []byte, and io.Reader. In this case, filename is\u000aonly used for source position information and error messages.\u000a</p>\u000a<p>\u000aIf src == nil, ParseFile parses the file specified by filename.\u000a</p>\u000a<p>\u000aThe mode parameter controls the amount of source text parsed and other\u000aoptional parser functionality.\u000a</p>\u000a<p>\u000aIf the source couldn&#39;t be read, the returned AST is nil and the error\u000aindicates the specific failure. If the source was read but syntax\u000aerrors were found, the result is a partial AST (with ast.BadX nodes\u000arepresenting the fragments of erroneous source code). Multiple errors\u000aare returned via a scanner.ErrorList which is sorted by file position.\u000a</p>\u000a\u000a","name":"ParseFile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseFiles!\">ParseFiles</a></h2>\u000a<code>func ParseFiles(filenames []string, mode uint) (pkgs map[string]*ast.Package, first os.Error)</code>\u000a<p>\u000aParseFiles calls ParseFile for each file in the filenames list and returns\u000aa map of package name -&gt; package AST with all the packages found. The mode\u000abits are passed to ParseFile unchanged.\u000a</p>\u000a<p>\u000aFiles with parse errors are ignored. In this case the map of packages may\u000abe incomplete (missing packages and/or incomplete packages) and the first\u000aerror encountered is returned.\u000a</p>\u000a\u000a","name":"ParseFiles"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseStmtList!\">ParseStmtList</a></h2>\u000a<code>func ParseStmtList(filename string, src interface{}) ([]ast.Stmt, os.Error)</code>\u000a<p>\u000aParseStmtList parses a list of Go statements and returns the list\u000aof corresponding AST nodes. The filename and src arguments have the same\u000ainterpretation as for ParseFile. If there is an error, the node\u000alist may be nil or contain partial ASTs.\u000a</p>\u000a\u000a","name":"ParseStmtList"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:PackageClauseOnly!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009PackageClauseOnly uint = 1 &lt;&lt; iota // parsing stops after package clause\u000a\u0009ImportsOnly                        // parsing stops after import declarations\u000a\u0009ParseComments                      // parse comments and add them to AST\u000a\u0009Trace                              // print a trace of parsed productions\u000a)</pre>\u000a<p>\u000aThe mode parameter to the Parse* functions is a set of flags (or 0).\u000aThey control the amount of source code parsed and other optional\u000aparser functionality.\u000a</p>\u000a\u000a","names":["PackageClauseOnly","ImportsOnly","ParseComments","Trace"],"type":""}],"vars":[]}