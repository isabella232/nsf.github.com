var gowtfData = {"index":"index.html","html":"<p>\u000aThe textproto package implements generic support for\u000atext-based request/response protocols in the style of\u000aHTTP, NNTP, and SMTP.\u000a</p>\u000a<p>\u000aThe package provides:\u000a</p>\u000a<p>\u000aError, which represents a numeric error response from\u000aa server.\u000a</p>\u000a<p>\u000aPipeline, to manage pipelined requests and responses\u000ain a client.\u000a</p>\u000a<p>\u000aReader, to read numeric response code lines,\u000akey: value headers, lines wrapped with leading spaces\u000aon continuation lines, and whole text blocks ending\u000awith a dot on a line by itself.\u000a</p>\u000a<p>\u000aWriter, to write dot-encoded text blocks.\u000a</p>\u000a","name":"textproto","filenames":["/home/nsf/go/src/pkg/net/textproto/writer.go","/home/nsf/go/src/pkg/net/textproto/pipeline.go","/home/nsf/go/src/pkg/net/textproto/reader.go","/home/nsf/go/src/pkg/net/textproto/textproto.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\u000a<pre>type Conn struct {\u000a\u0009Reader\u000a\u0009Writer\u000a\u0009Pipeline\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Conn represents a textual network protocol connection.\u000aIt consists of a Reader and Writer to manage I/O\u000aand a Pipeline to sequence concurrent requests on the connection.\u000aThese embedded types carry methods with them;\u000asee the documentation of those types for details.\u000a</p>\u000a\u000a","name":"Conn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Close!\">Close</a></h2>\u000a<code>func (c *Conn) Close() os.Error</code>\u000a<p>\u000aClose closes the connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Cmd!\">Cmd</a></h2>\u000a<code>func (c *Conn) Cmd(format string, args ...interface{}) (id uint, err os.Error)</code>\u000a<p>\u000aCmd is a convenience method that sends a command after\u000awaiting its turn in the pipeline.  The command text is the\u000aresult of formatting format with args and appending \\r\\n.\u000aCmd returns the id of the command, for use with StartResponse and EndResponse.\u000a</p>\u000a<p>\u000aFor example, a client might run a HELP command that returns a dot-body\u000aby using:\u000a</p>\u000a<pre>id, err := c.Cmd(&#34;HELP&#34;)\u000aif err != nil {\u000a\u0009return nil, err\u000a}\u000a\u000ac.StartResponse(id)\u000adefer c.EndResponse(id)\u000a\u000aif _, _, err = c.ReadCodeLine(110); err != nil {\u000a\u0009return nil, err\u000a}\u000atext, err := c.ReadDotAll()\u000aif err != nil {\u000a\u0009return nil, err\u000a}\u000areturn c.ReadCodeLine(250)\u000a</pre>\u000a\u000a","name":"Cmd"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error struct {\u000a\u0009Code int\u000a\u0009Msg  string\u000a}</pre>\u000a<p>\u000aAn Error represents a numeric error response from a server.\u000a</p>\u000a\u000a","name":"Error","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Error\">func (*Error)</a> <a href=\"?m:Error.String!\">String</a></h2>\u000a<code>func (e *Error) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Pipeline!\">Pipeline</a></h2>\u000a<pre>type Pipeline struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Pipeline manages a pipelined in-order request/response sequence.\u000a</p>\u000a<p>\u000aTo use a Pipeline p to manage multiple clients on a connection,\u000aeach client should run:\u000a</p>\u000a<pre>id := p.Next()\u0009// take a number\u000a\u000ap.StartRequest(id)\u0009// wait for turn to send request\u000a«send request»\u000ap.EndRequest(id)\u0009// notify Pipeline that request is sent\u000a\u000ap.StartResponse(id)\u0009// wait for turn to read response\u000a«read response»\u000ap.EndResponse(id)\u0009// notify Pipeline that response is read\u000a</pre>\u000a<p>\u000aA pipelined server can use the same calls to ensure that\u000aresponses computed in parallel are written in the correct order.\u000a</p>\u000a\u000a","name":"Pipeline","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Pipeline\">func (*Pipeline)</a> <a href=\"?m:Pipeline.EndRequest!\">EndRequest</a></h2>\u000a<code>func (p *Pipeline) EndRequest(id uint)</code>\u000a<p>\u000aEndRequest notifies p that the request with the given id has been sent\u000a(or, if this is a server, received).\u000a</p>\u000a\u000a","name":"EndRequest"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Pipeline\">func (*Pipeline)</a> <a href=\"?m:Pipeline.EndResponse!\">EndResponse</a></h2>\u000a<code>func (p *Pipeline) EndResponse(id uint)</code>\u000a<p>\u000aEndResponse notifies p that the response with the given id has been received\u000a(or, if this is a server, sent).\u000a</p>\u000a\u000a","name":"EndResponse"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Pipeline\">func (*Pipeline)</a> <a href=\"?m:Pipeline.Next!\">Next</a></h2>\u000a<code>func (p *Pipeline) Next() uint</code>\u000a<p>\u000aNext returns the next id for a request/response pair.\u000a</p>\u000a\u000a","name":"Next"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Pipeline\">func (*Pipeline)</a> <a href=\"?m:Pipeline.StartRequest!\">StartRequest</a></h2>\u000a<code>func (p *Pipeline) StartRequest(id uint)</code>\u000a<p>\u000aStartRequest blocks until it is time to send (or, if this is a server, receive)\u000athe request with the given id.\u000a</p>\u000a\u000a","name":"StartRequest"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Pipeline\">func (*Pipeline)</a> <a href=\"?m:Pipeline.StartResponse!\">StartResponse</a></h2>\u000a<code>func (p *Pipeline) StartResponse(id uint)</code>\u000a<p>\u000aStartResponse blocks until it is time to receive (or, if this is a server, send)\u000athe request with the given id.\u000a</p>\u000a\u000a","name":"StartResponse"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProtocolError!\">ProtocolError</a></h2>\u000a<pre>type ProtocolError string</pre>\u000a<p>\u000aA ProtocolError describes a protocol violation such\u000aas an invalid response or a hung-up connection.\u000a</p>\u000a\u000a","name":"ProtocolError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ProtocolError\">func (ProtocolError)</a> <a href=\"?m:ProtocolError.String!\">String</a></h2>\u000a<code>func (p ProtocolError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\u000a<pre>type Reader struct {\u000a\u0009R *bufio.Reader\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Reader implements convenience methods for reading requests\u000aor responses from a text protocol network connection.\u000a</p>\u000a\u000a","name":"Reader","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.DotReader!\">DotReader</a></h2>\u000a<code>func (r *Reader) DotReader() io.Reader</code>\u000a<p>\u000aDotReader returns a new Reader that satisfies Reads using the\u000adecoded text of a dot-encoded block read from r.\u000aThe returned Reader is only valid until the next call\u000ato a method on r.\u000a</p>\u000a<p>\u000aDot encoding is a common framing used for data blocks\u000ain text protcols like SMTP.  The data consists of a sequence\u000aof lines, each of which ends in &#34;\\r\\n&#34;.  The sequence itself\u000aends at a line containing just a dot: &#34;.\\r\\n&#34;.  Lines beginning\u000awith a dot are escaped with an additional dot to avoid\u000alooking like the end of the sequence.\u000a</p>\u000a<p>\u000aThe decoded form returned by the Reader&#39;s Read method\u000arewrites the &#34;\\r\\n&#34; line endings into the simpler &#34;\\n&#34;,\u000aremoves leading dot escapes if present, and stops with error os.EOF\u000aafter consuming (and discarding) the end-of-sequence line.\u000a</p>\u000a\u000a","name":"DotReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadCodeLine!\">ReadCodeLine</a></h2>\u000a<code>func (r *Reader) ReadCodeLine(expectCode int) (code int, message string, err os.Error)</code>\u000a<p>\u000aReadCodeLine reads a response code line of the form\u000a</p>\u000a<pre>code message\u000a</pre>\u000a<p>\u000awhere code is a 3-digit status code and the message\u000aextends to the rest of the line.  An example of such a line is:\u000a</p>\u000a<pre>220 plan9.bell-labs.com ESMTP\u000a</pre>\u000a<p>\u000aIf the prefix of the status does not match the digits in expectCode,\u000aReadCodeLine returns with err set to &amp;Error{code, message}.\u000aFor example, if expectCode is 31, an error will be returned if\u000athe status is not in the range [310,319].\u000a</p>\u000a<p>\u000aIf the response is multi-line, ReadCodeLine returns an error.\u000a</p>\u000a<p>\u000aAn expectCode &lt;= 0 disables the check of the status code.\u000a</p>\u000a\u000a","name":"ReadCodeLine"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadContinuedLine!\">ReadContinuedLine</a></h2>\u000a<code>func (r *Reader) ReadContinuedLine() (string, os.Error)</code>\u000a<p>\u000aReadContinuedLine reads a possibly continued line from r,\u000aeliding the final trailing ASCII white space.\u000aLines after the first are considered continuations if they\u000abegin with a space or tab character.  In the returned data,\u000acontinuation lines are separated from the previous line\u000aonly by a single space: the newline and leading white space\u000aare removed.\u000a</p>\u000a<p>\u000aFor example, consider this input:\u000a</p>\u000a<pre>Line 1\u000a  continued...\u000aLine 2\u000a</pre>\u000a<p>\u000aThe first call to ReadContinuedLine will return &#34;Line 1 continued...&#34;\u000aand the second will return &#34;Line 2&#34;.\u000a</p>\u000a<p>\u000aA line consisting of only white space is never continued.\u000a</p>\u000a\u000a","name":"ReadContinuedLine"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadContinuedLineBytes!\">ReadContinuedLineBytes</a></h2>\u000a<code>func (r *Reader) ReadContinuedLineBytes() ([]byte, os.Error)</code>\u000a<p>\u000aReadContinuedLineBytes is like ReadContinuedLine but\u000areturns a []byte instead of a string.\u000a</p>\u000a\u000a","name":"ReadContinuedLineBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadDotBytes!\">ReadDotBytes</a></h2>\u000a<code>func (r *Reader) ReadDotBytes() ([]byte, os.Error)</code>\u000a<p>\u000aReadDotBytes reads a dot-encoding and returns the decoded data.\u000a</p>\u000a<p>\u000aSee the documentation for the DotReader method for details about dot-encoding.\u000a</p>\u000a\u000a","name":"ReadDotBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadDotLines!\">ReadDotLines</a></h2>\u000a<code>func (r *Reader) ReadDotLines() ([]string, os.Error)</code>\u000a<p>\u000aReadDotLines reads a dot-encoding and returns a slice\u000acontaining the decoded lines, with the final \\r\\n or \\n elided from each.\u000a</p>\u000a<p>\u000aSee the documentation for the DotReader method for details about dot-encoding.\u000a</p>\u000a\u000a","name":"ReadDotLines"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadLine!\">ReadLine</a></h2>\u000a<code>func (r *Reader) ReadLine() (string, os.Error)</code>\u000a<p>\u000aReadLine reads a single line from r,\u000aeliding the final \\n or \\r\\n from the returned string.\u000a</p>\u000a\u000a","name":"ReadLine"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadLineBytes!\">ReadLineBytes</a></h2>\u000a<code>func (r *Reader) ReadLineBytes() ([]byte, os.Error)</code>\u000a<p>\u000aReadLineBytes is like ReadLine but returns a []byte instead of a string.\u000a</p>\u000a\u000a","name":"ReadLineBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadMIMEHeader!\">ReadMIMEHeader</a></h2>\u000a<code>func (r *Reader) ReadMIMEHeader() (map[string][]string, os.Error)</code>\u000a<p>\u000aReadMIMEHeader reads a MIME-style header from r.\u000aThe header is a sequence of possibly continued Key: Value lines\u000aending in a blank line.\u000aThe returned map m maps CanonicalHeaderKey(key) to a\u000asequence of values in the same order encountered in the input.\u000a</p>\u000a<p>\u000aFor example, consider this input:\u000a</p>\u000a<pre>My-Key: Value 1\u000aLong-Key: Even\u000a       Longer Value\u000aMy-Key: Value 2\u000a</pre>\u000a<p>\u000aGiven that input, ReadMIMEHeader returns the map:\u000a</p>\u000a<pre>map[string][]string{\u000a\u0009&#34;My-Key&#34;: []string{&#34;Value 1&#34;, &#34;Value 2&#34;},\u000a\u0009&#34;Long-Key&#34;: []string{&#34;Even Longer Value&#34;},\u000a}\u000a</pre>\u000a\u000a","name":"ReadMIMEHeader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadResponse!\">ReadResponse</a></h2>\u000a<code>func (r *Reader) ReadResponse(expectCode int) (code int, message string, err os.Error)</code>\u000a<p>\u000aReadResponse reads a multi-line response of the form\u000a</p>\u000a<pre>code-message line 1\u000acode-message line 2\u000a...\u000acode message line n\u000a</pre>\u000a<p>\u000awhere code is a 3-digit status code. Each line should have the same code.\u000aThe response is terminated by a line that uses a space between the code and\u000athe message line rather than a dash. Each line in message is separated by\u000aa newline (\\n).\u000a</p>\u000a<p>\u000aIf the prefix of the status does not match the digits in expectCode,\u000aReadResponse returns with err set to &amp;Error{code, message}.\u000aFor example, if expectCode is 31, an error will be returned if\u000athe status is not in the range [310,319].\u000a</p>\u000a<p>\u000aAn expectCode &lt;= 0 disables the check of the status code.\u000a</p>\u000a\u000a","name":"ReadResponse"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\u000a<pre>type Writer struct {\u000a\u0009W *bufio.Writer\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Writer implements convenience methods for writing\u000arequests or responses to a text protocol network connection.\u000a</p>\u000a\u000a","name":"Writer","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.DotWriter!\">DotWriter</a></h2>\u000a<code>func (w *Writer) DotWriter() io.WriteCloser</code>\u000a<p>\u000aDotWriter returns a writer that can be used to write a dot-encoding to w.\u000aIt takes care of inserting leading dots when necessary,\u000atranslating line-ending \\n into \\r\\n, and adding the final .\\r\\n line\u000awhen the DotWriter is closed.  The caller should close the\u000aDotWriter before the next call to a method on w.\u000a</p>\u000a<p>\u000aSee the documentation for Reader&#39;s DotReader method for details about dot-encoding.\u000a</p>\u000a\u000a","name":"DotWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.PrintfLine!\">PrintfLine</a></h2>\u000a<code>func (w *Writer) PrintfLine(format string, args ...interface{}) os.Error</code>\u000a<p>\u000aPrintfLine writes the formatted output followed by \\r\\n.\u000a</p>\u000a\u000a","name":"PrintfLine"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalHeaderKey!\">CanonicalHeaderKey</a></h2>\u000a<code>func CanonicalHeaderKey(s string) string</code>\u000a<p>\u000aCanonicalHeaderKey returns the canonical format of the\u000aMIME header key s.  The canonicalization converts the first\u000aletter and any letter following a hyphen to upper case;\u000athe rest are converted to lowercase.  For example, the\u000acanonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.\u000a</p>\u000a\u000a","name":"CanonicalHeaderKey"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\u000a<code>func Dial(network, addr string) (*Conn, os.Error)</code>\u000a<p>\u000aDial connects to the given address on the given network using net.Dial\u000aand then returns a new Conn for the connection.\u000a</p>\u000a\u000a","name":"Dial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewConn!\">NewConn</a></h2>\u000a<code>func NewConn(conn io.ReadWriteCloser) *Conn</code>\u000a<p>\u000aNewConn returns a new Conn using conn for I/O.\u000a</p>\u000a\u000a","name":"NewConn"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\u000a<code>func NewReader(r *bufio.Reader) *Reader</code>\u000a<p>\u000aNewReader returns a new Reader reading from r.\u000a</p>\u000a\u000a","name":"NewReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(w *bufio.Writer) *Writer</code>\u000a<p>\u000aNewWriter returns a new Writer writing to w.\u000a</p>\u000a\u000a","name":"NewWriter"}],"consts":[],"vars":[]}