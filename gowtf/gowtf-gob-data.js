var gowtfData = {"html":"<p>\u000aThe gob package manages streams of gobs - binary values exchanged between an\u000aEncoder (transmitter) and a Decoder (receiver).  A typical use is transporting\u000aarguments and results of remote procedure calls (RPCs) such as those provided by\u000apackage &#34;rpc&#34;.\u000a</p>\u000a<p>\u000aA stream of gobs is self-describing.  Each data item in the stream is preceded by\u000aa specification of its type, expressed in terms of a small set of predefined\u000atypes.  Pointers are not transmitted, but the things they point to are\u000atransmitted; that is, the values are flattened.  Recursive types work fine, but\u000arecursive values (data with cycles) are problematic.  This may change.\u000a</p>\u000a<p>\u000aTo use gobs, create an Encoder and present it with a series of data items as\u000avalues or addresses that can be dereferenced to values.  The Encoder makes sure\u000aall type information is sent before it is needed.  At the receive side, a\u000aDecoder retrieves values from the encoded stream and unpacks them into local\u000avariables.\u000a</p>\u000a<p>\u000aThe source and destination values/types need not correspond exactly.  For structs,\u000afields (identified by name) that are in the source but absent from the receiving\u000avariable will be ignored.  Fields that are in the receiving variable but missing\u000afrom the transmitted type or value will be ignored in the destination.  If a field\u000awith the same name is present in both, their types must be compatible. Both the\u000areceiver and transmitter will do all necessary indirection and dereferencing to\u000aconvert between gobs and actual Go values.  For instance, a gob type that is\u000aschematically,\u000a</p>\u000a<pre>struct { a, b int }\u000a</pre>\u000a<p>\u000acan be sent from or received into any of these Go types:\u000a</p>\u000a<pre>struct { a, b int }\u0009// the same\u000a*struct { a, b int }\u0009// extra indirection of the struct\u000astruct { *a, **b int }\u0009// extra indirection of the fields\u000astruct { a, b int64 }\u0009// different concrete value type; see below\u000a</pre>\u000a<p>\u000aIt may also be received into any of these:\u000a</p>\u000a<pre>struct { a, b int }\u0009// the same\u000astruct { b, a int }\u0009// ordering doesn&#39;t matter; matching is by name\u000astruct { a, b, c int }\u0009// extra field (c) ignored\u000astruct { b int }\u0009// missing field (a) ignored; data will be dropped\u000astruct { b, c int }\u0009// missing field (a) ignored; extra field (c) ignored.\u000a</pre>\u000a<p>\u000aAttempting to receive into these types will draw a decode error:\u000a</p>\u000a<pre>struct { a int; b uint }\u0009// change of signedness for b\u000astruct { a int; b float }\u0009// change of type for b\u000astruct { }\u0009\u0009\u0009// no field names in common\u000astruct { c, d int }\u0009\u0009// no field names in common\u000a</pre>\u000a<p>\u000aIntegers are transmitted two ways: arbitrary precision signed integers or\u000aarbitrary precision unsigned integers.  There is no int8, int16 etc.\u000adiscrimination in the gob format; there are only signed and unsigned integers.  As\u000adescribed below, the transmitter sends the value in a variable-length encoding;\u000athe receiver accepts the value and stores it in the destination variable.\u000aFloating-point numbers are always sent using IEEE-754 64-bit precision (see\u000abelow).\u000a</p>\u000a<p>\u000aSigned integers may be received into any signed integer variable: int, int16, etc.;\u000aunsigned integers may be received into any unsigned integer variable; and floating\u000apoint values may be received into any floating point variable.  However,\u000athe destination variable must be able to represent the value or the decode\u000aoperation will fail.\u000a</p>\u000a<p>\u000aStructs, arrays and slices are also supported.  Strings and arrays of bytes are\u000asupported with a special, efficient representation (see below).\u000a</p>\u000a<p>\u000aInterfaces, functions, and channels cannot be sent in a gob.  Attempting\u000ato encode a value that contains one will fail.\u000a</p>\u000a<p>\u000aThe rest of this comment documents the encoding, details that are not important\u000afor most users.  Details are presented bottom-up.\u000a</p>\u000a<p>\u000aAn unsigned integer is sent one of two ways.  If it is less than 128, it is sent\u000aas a byte with that value.  Otherwise it is sent as a minimal-length big-endian\u000a(high byte first) byte stream holding the value, preceded by one byte holding the\u000abyte count, negated.  Thus 0 is transmitted as (00), 7 is transmitted as (07) and\u000a256 is transmitted as (FE 01 00).\u000a</p>\u000a<p>\u000aA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\u000a</p>\u000a<p>\u000aA signed integer, i, is encoded within an unsigned integer, u.  Within u, bits 1\u000aupward contain the value; bit 0 says whether they should be complemented upon\u000areceipt.  The encode algorithm looks like this:\u000a</p>\u000a<pre>uint u;\u000aif i &lt; 0 {\u000a\u0009u = (^i &lt;&lt; 1) | 1\u0009// complement i, bit 0 is 1\u000a} else {\u000a\u0009u = (i &lt;&lt; 1)\u0009// do not complement i, bit 0 is 0\u000a}\u000aencodeUnsigned(u)\u000a</pre>\u000a<p>\u000aThe low bit is therefore analogous to a sign bit, but making it the complement bit\u000ainstead guarantees that the largest negative integer is not a special case.  For\u000aexample, -129=^128=(^256&gt;&gt;1) encodes as (FE 01 01).\u000a</p>\u000a<p>\u000aFloating-point numbers are always sent as a representation of a float64 value.\u000aThat value is converted to a uint64 using math.Float64bits.  The uint64 is then\u000abyte-reversed and sent as a regular unsigned integer.  The byte-reversal means the\u000aexponent and high-precision part of the mantissa go first.  Since the low bits are\u000aoften zero, this can save encoding bytes.  For instance, 17.0 is encoded in only\u000athree bytes (FE 31 40).\u000a</p>\u000a<p>\u000aStrings and slices of bytes are sent as an unsigned count followed by that many\u000auninterpreted bytes of the value.\u000a</p>\u000a<p>\u000aAll other slices and arrays are sent as an unsigned count followed by that many\u000aelements using the standard gob encoding for their type, recursively.\u000a</p>\u000a<p>\u000aStructs are sent as a sequence of (field number, field value) pairs.  The field\u000avalue is sent using the standard gob encoding for its type, recursively.  If a\u000afield has the zero value for its type, it is omitted from the transmission.  The\u000afield number is defined by the type of the encoded struct: the first field of the\u000aencoded type is field 0, the second is field 1, etc.  When encoding a value, the\u000afield numbers are delta encoded for efficiency and the fields are always sent in\u000aorder of increasing field number; the deltas are therefore unsigned.  The\u000ainitialization for the delta encoding sets the field number to -1, so an unsigned\u000ainteger field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value\u000a= 7 or (01 07).  Finally, after all the fields have been sent a terminating mark\u000adenotes the end of the struct.  That mark is a delta=0 value, which has\u000arepresentation (00).\u000a</p>\u000a<p>\u000aInterface types are not checked for compatibility; all interface types are\u000atreated, for transmission, as members of a single &#34;interface&#34; type, analogous to\u000aint or []byte - in effect they&#39;re all treated as interface{}.  Interface values\u000aare transmitted as a string identifying the concrete type being sent (a name\u000athat must be pre-defined by calling Register()), followed by the usual encoding\u000aof concrete (dynamic) value stored in the interface value.  (A nil interface\u000avalue is identified by the empty string and transmits no value.) Upon receipt,\u000athe decoder verifies that the unpacked concrete item satisfies the interface of\u000athe receiving variable.\u000a</p>\u000a<p>\u000aThe representation of types is described below.  When a type is defined on a given\u000aconnection between an Encoder and Decoder, it is assigned a signed integer type\u000aid.  When Encoder.Encode(v) is called, it makes sure there is an id assigned for\u000athe type of v and all its elements and then it sends the pair (typeid, encoded-v)\u000awhere typeid is the type id of the encoded type of v and encoded-v is the gob\u000aencoding of the value v.\u000a</p>\u000a<p>\u000aTo define a type, the encoder chooses an unused, positive type id and sends the\u000apair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType\u000adescription, constructed from these types:\u000a</p>\u000a<pre>type wireType struct {\u000a\u0009s structType\u000a}\u000atype arrayType struct {\u000a\u0009commonType\u000a\u0009Elem typeId\u000a\u0009Len  int\u000a}\u000atype commonType {\u000a\u0009name string // the name of the struct type\u000a\u0009_id  int    // the id of the type, repeated for so it&#39;s inside the type\u000a}\u000atype sliceType struct {\u000a\u0009commonType\u000a\u0009Elem typeId\u000a}\u000atype structType struct {\u000a\u0009commonType\u000a\u0009field []*fieldType // the fields of the struct.\u000a}\u000atype fieldType struct {\u000a\u0009name string // the name of the field.\u000a\u0009id   int    // the type id of the field, which must be already defined\u000a}\u000atype mapType struct {\u000a\u0009commonType\u000a\u0009Key  typeId\u000a\u0009Elem typeId\u000a}\u000a</pre>\u000a<p>\u000aIf there are nested type ids, the types for all inner type ids must be defined\u000abefore the top-level type id is used to describe an encoded-v.\u000a</p>\u000a<p>\u000aFor simplicity in setup, the connection is defined to understand these types a\u000apriori, as well as the basic gob types int, uint, etc.  Their ids are:\u000a</p>\u000a<pre>bool        1\u000aint         2\u000auint        3\u000afloat       4\u000a[]byte      5\u000astring      6\u000acomplex     7\u000ainterface   8\u000a// gap for reserved ids.\u000awireType    16\u000aarrayType   17\u000acommonType  18\u000asliceType   19\u000astructType  20\u000afieldType   21\u000a// 22 is slice of fieldType.\u000amapType     23\u000a</pre>\u000a<p>\u000aIn summary, a gob stream looks like\u000a</p>\u000a<pre>((-type id, encoding of a wireType)* (type id, encoding of a value))*\u000a</pre>\u000a<p>\u000awhere * signifies zero or more repetitions and the type id of a value must\u000abe predefined or be defined before the value in the stream.\u000a</p>\u000a","name":"gob","filenames":["/home/nsf/go/src/pkg/gob/decode.go","/home/nsf/go/src/pkg/gob/encode.go","/home/nsf/go/src/pkg/gob/doc.go","/home/nsf/go/src/pkg/gob/type.go","/home/nsf/go/src/pkg/gob/decoder.go","/home/nsf/go/src/pkg/gob/encoder.go","/home/nsf/go/src/pkg/gob/error.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decoder!\">Decoder</a></h2>\u000a<pre>type Decoder struct {\u000a\u0009mutex        sync.Mutex                              // each item must be received atomically\u000a\u0009r            io.Reader                               // source of the data\u000a\u0009wireType     map[typeId]*wireType                    // map from remote ID to local description\u000a\u0009decoderCache map[reflect.Type]map[typeId]**decEngine // cache of compiled engines\u000a\u0009ignorerCache map[typeId]**decEngine                  // ditto for ignored objects\u000a\u0009state        *decodeState                            // reads data from in-memory buffer\u000a\u0009countState   *decodeState                            // reads counts from wire\u000a\u0009buf          []byte\u000a\u0009countBuf     [9]byte // counts may be uint64s (unlikely!), require 9 bytes\u000a\u0009byteBuffer   *bytes.Buffer\u000a\u0009err          os.Error\u000a}</pre>\u000a<p>\u000aA Decoder manages the receipt of type and data information read from the\u000aremote side of a connection.\u000a</p>\u000a\u000a","name":"Decoder","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.Decode!\">Decode</a></h2>\u000a<code>func (dec *Decoder) Decode(e interface{}) os.Error</code>\u000a<p>\u000aDecode reads the next value from the connection and stores\u000ait in the data represented by the empty interface value.\u000aThe value underlying e must be the correct type for the next\u000adata item received, and must be a pointer.\u000a</p>\u000a\u000a","name":"Decode"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.DecodeValue!\">DecodeValue</a></h2>\u000a<code>func (dec *Decoder) DecodeValue(value reflect.Value) os.Error</code>\u000a<p>\u000aDecodeValue reads the next value from the connection and stores\u000ait in the data represented by the reflection value.\u000aThe value must be the correct type for the next\u000adata item received.\u000a</p>\u000a\u000a","name":"DecodeValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Encoder!\">Encoder</a></h2>\u000a<pre>type Encoder struct {\u000a\u0009mutex      sync.Mutex              // each item must be sent atomically\u000a\u0009w          io.Writer               // where to send the data\u000a\u0009sent       map[reflect.Type]typeId // which types we&#39;ve already sent\u000a\u0009state      *encoderState           // so we can encode integers, strings directly\u000a\u0009countState *encoderState           // stage for writing counts\u000a\u0009buf        []byte                  // for collecting the output.\u000a\u0009err        os.Error\u000a}</pre>\u000a<p>\u000aAn Encoder manages the transmission of type and data information to the\u000aother side of a connection.\u000a</p>\u000a\u000a","name":"Encoder","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.Encode!\">Encode</a></h2>\u000a<code>func (enc *Encoder) Encode(e interface{}) os.Error</code>\u000a<p>\u000aEncode transmits the data item represented by the empty interface value,\u000aguaranteeing that all necessary type information has been transmitted first.\u000a</p>\u000a\u000a","name":"Encode"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.EncodeValue!\">EncodeValue</a></h2>\u000a<code>func (enc *Encoder) EncodeValue(value reflect.Value) os.Error</code>\u000a<p>\u000aEncodeValue transmits the data item represented by the reflection value,\u000aguaranteeing that all necessary type information has been transmitted first.\u000a</p>\u000a\u000a","name":"EncodeValue"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewDecoder!\">NewDecoder</a></h2>\u000a<code>func NewDecoder(r io.Reader) *Decoder</code>\u000a<p>\u000aNewDecoder returns a new decoder that reads from the io.Reader.\u000a</p>\u000a\u000a","name":"NewDecoder"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEncoder!\">NewEncoder</a></h2>\u000a<code>func NewEncoder(w io.Writer) *Encoder</code>\u000a<p>\u000aNewEncoder returns a new encoder that will transmit on the io.Writer.\u000a</p>\u000a\u000a","name":"NewEncoder"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Register!\">Register</a></h2>\u000a<code>func Register(value interface{})</code>\u000a<p>\u000aRegister records a type, identified by a value for that type, under its\u000ainternal type name.  That name will identify the concrete type of a value\u000asent or received as an interface variable.  Only types that will be\u000atransferred as implementations of interface values need to be registered.\u000aExpecting to be used only during initialization, it panics if the mapping\u000abetween types and names is not a bijection.\u000a</p>\u000a\u000a","name":"Register"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RegisterName!\">RegisterName</a></h2>\u000a<code>func RegisterName(name string, value interface{})</code>\u000a<p>\u000aRegisterName is like Register but uses the provided name rather than the\u000atype&#39;s default.\u000a</p>\u000a\u000a","name":"RegisterName"}],"consts":[],"vars":[]}