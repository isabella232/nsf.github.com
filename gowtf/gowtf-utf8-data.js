var gowtfData = {"index":"index.html","html":"<p>\u000aFunctions and constants to support text encoded in UTF-8.\u000aThis package calls a Unicode character a rune for brevity.\u000a</p>\u000a","name":"utf8","filenames":["/home/nsf/go/src/pkg/utf8/utf8.go","/home/nsf/go/src/pkg/utf8/string.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:String!\">String</a></h2>\u000a<pre>type String struct {\u000a\u0009str      string\u000a\u0009numRunes int\u000a\u0009// If width &gt; 0, the rune at runePos starts at bytePos and has the specified width.\u000a\u0009width    int\u000a\u0009bytePos  int\u000a\u0009runePos  int\u000a\u0009nonASCII int // byte index of the first non-ASCII rune.\u000a}</pre>\u000a<p>\u000aString wraps a regular string with a small structure that provides more\u000aefficient indexing by code point index, as opposed to byte index.\u000aScanning incrementally forwards or backwards is O(1) per index operation\u000a(although not as fast a range clause going forwards).  Random access is\u000aO(N) in the length of the string, but the overhead is less than always\u000ascanning from the beginning.\u000aIf the string is ASCII, random access is O(1).\u000aUnlike the built-in string type, String has internal mutable state and\u000ais not thread-safe.\u000a</p>\u000a\u000a","name":"String","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.At!\">At</a></h2>\u000a<code>func (s *String) At(i int) int</code>\u000a<p>\u000aAt returns the rune with index i in the String.  The sequence of runes is the same\u000aas iterating over the contents with a &#34;for range&#34; clause.\u000a</p>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.Init!\">Init</a></h2>\u000a<code>func (s *String) Init(contents string) *String</code>\u000a<p>\u000aInit initializes an existing String to hold the provided contents.\u000aIt returns a pointer to the initialized String.\u000a</p>\u000a\u000a","name":"Init"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.IsASCII!\">IsASCII</a></h2>\u000a<code>func (s *String) IsASCII() bool</code>\u000a<p>\u000aIsASCII returns a boolean indicating whether the String contains only ASCII bytes.\u000a</p>\u000a\u000a","name":"IsASCII"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.RuneCount!\">RuneCount</a></h2>\u000a<code>func (s *String) RuneCount() int</code>\u000a<p>\u000aRuneCount returns the number of runes (Unicode code points) in the String.\u000a</p>\u000a\u000a","name":"RuneCount"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.Slice!\">Slice</a></h2>\u000a<code>func (s *String) Slice(i, j int) string</code>\u000a<p>\u000aSlice returns the string sliced at rune positions [i:j].\u000a</p>\u000a\u000a","name":"Slice"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:String\">func (*String)</a> <a href=\"?m:String.String!\">String</a></h2>\u000a<code>func (s *String) String() string</code>\u000a<p>\u000aString returns the contents of the String.  This method also means the\u000aString is directly printable by fmt.Print.\u000a</p>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeLastRune!\">DecodeLastRune</a></h2>\u000a<code>func DecodeLastRune(p []byte) (rune, size int)</code>\u000a<p>\u000aDecodeLastRune unpacks the last UTF-8 encoding in p\u000aand returns the rune and its width in bytes.\u000a</p>\u000a\u000a","name":"DecodeLastRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeLastRuneInString!\">DecodeLastRuneInString</a></h2>\u000a<code>func DecodeLastRuneInString(s string) (rune, size int)</code>\u000a<p>\u000aDecodeLastRuneInString is like DecodeLastRune but its input is a string.\u000a</p>\u000a\u000a","name":"DecodeLastRuneInString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeRune!\">DecodeRune</a></h2>\u000a<code>func DecodeRune(p []byte) (rune, size int)</code>\u000a<p>\u000aDecodeRune unpacks the first UTF-8 encoding in p and returns the rune and its width in bytes.\u000a</p>\u000a\u000a","name":"DecodeRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeRuneInString!\">DecodeRuneInString</a></h2>\u000a<code>func DecodeRuneInString(s string) (rune, size int)</code>\u000a<p>\u000aDecodeRuneInString is like DecodeRune but its input is a string.\u000a</p>\u000a\u000a","name":"DecodeRuneInString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodeRune!\">EncodeRune</a></h2>\u000a<code>func EncodeRune(rune int, p []byte) int</code>\u000a<p>\u000aEncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\u000aIt returns the number of bytes written.\u000a</p>\u000a\u000a","name":"EncodeRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FullRune!\">FullRune</a></h2>\u000a<code>func FullRune(p []byte) bool</code>\u000a<p>\u000aFullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\u000aAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\u000a</p>\u000a\u000a","name":"FullRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FullRuneInString!\">FullRuneInString</a></h2>\u000a<code>func FullRuneInString(s string) bool</code>\u000a<p>\u000aFullRuneInString is like FullRune but its input is a string.\u000a</p>\u000a\u000a","name":"FullRuneInString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewString!\">NewString</a></h2>\u000a<code>func NewString(contents string) *String</code>\u000a<p>\u000aNewString returns a new UTF-8 string with the provided contents.\u000a</p>\u000a\u000a","name":"NewString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RuneCount!\">RuneCount</a></h2>\u000a<code>func RuneCount(p []byte) int</code>\u000a<p>\u000aRuneCount returns the number of runes in p.  Erroneous and short\u000aencodings are treated as single runes of width 1 byte.\u000a</p>\u000a\u000a","name":"RuneCount"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RuneCountInString!\">RuneCountInString</a></h2>\u000a<code>func RuneCountInString(s string) (n int)</code>\u000a<p>\u000aRuneCountInString is like RuneCount but its input is a string.\u000a</p>\u000a\u000a","name":"RuneCountInString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RuneLen!\">RuneLen</a></h2>\u000a<code>func RuneLen(rune int) int</code>\u000a<p>\u000aRuneLen returns the number of bytes required to encode the rune.\u000a</p>\u000a\u000a","name":"RuneLen"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RuneStart!\">RuneStart</a></h2>\u000a<code>func RuneStart(b byte) bool</code>\u000a<p>\u000aRuneStart reports whether the byte could be the first byte of\u000aan encoded rune.  Second and subsequent bytes always have the top\u000atwo bits set to 10.\u000a</p>\u000a\u000a","name":"RuneStart"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:RuneError!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009RuneError = unicode.ReplacementChar // the &#34;error&#34; Rune or &#34;replacement character&#34;.\u000a\u0009RuneSelf  = 0x80                    // characters below Runeself are represented as themselves in a single byte.\u000a\u0009UTFMax    = 4                       // maximum number of bytes of a UTF-8 encoded Unicode character.\u000a)</pre>\u000a<p>\u000aNumbers fundamental to the encoding.\u000a</p>\u000a\u000a","names":["RuneError","RuneSelf","UTFMax"],"type":""}],"vars":[]}