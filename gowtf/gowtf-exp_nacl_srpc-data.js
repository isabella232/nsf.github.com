var gowtfData = {"html":"<p>\u000aThis package implements Native Client&#39;s simple RPC (SRPC).\u000a</p>\u000a","name":"srpc","filenames":["/home/nsf/go/src/pkg/exp/nacl/srpc/server.go","/home/nsf/go/src/pkg/exp/nacl/srpc/client.go","/home/nsf/go/src/pkg/exp/nacl/srpc/msg.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Client!\">Client</a></h2>\u000a<pre>type Client struct {\u000a\u0009fd      int // fd to server\u000a\u0009r       msgReceiver\u000a\u0009s       msgSender\u000a\u0009service map[string]srv // services by name\u000a\u0009out     chan *msg      // send to out to write to connection\u000a\u000a\u0009mu      sync.Mutex // protects pending, idGen\u000a\u0009pending map[uint64]*RPC\u000a\u0009idGen   uint64 // generator for request IDs\u000a}</pre>\u000a<p>\u000aA Client represents the client side of an SRPC connection.\u000a</p>\u000a\u000a","name":"Client","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.NewRPC!\">NewRPC</a></h2>\u000a<code>func (c *Client) NewRPC(done chan *RPC) *RPC</code>\u000a<p>\u000aNewRPC creates a new RPC on the client connection.\u000a</p>\u000a\u000a","name":"NewRPC"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Errno!\">Errno</a></h2>\u000a<pre>type Errno uint32</pre>\u000a<p>\u000aAn Errno is an SRPC status code.\u000a</p>\u000a\u000a","name":"Errno","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Errno\">func (Errno)</a> <a href=\"?m:Errno.String!\">String</a></h2>\u000a<code>func (e Errno) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Handler!\">Handler</a></h2>\u000a<pre>type Handler interface {\u000a\u0009Run(arg, ret []interface{}, size []int) Errno\u000a}</pre>\u000a<p>\u000aA Handler is a handler for an SRPC method.\u000aIt reads arguments from arg, checks size for array limits,\u000awrites return values to ret, and returns an Errno status code.\u000a</p>\u000a\u000a","name":"Handler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RPC!\">RPC</a></h2>\u000a<pre>type RPC struct {\u000a\u0009Ret   []interface{} // Return values\u000a\u0009Done  chan *RPC     // Channel where notification of done arrives\u000a\u0009Errno Errno         // Status code\u000a\u0009c     *Client\u000a\u0009id    uint64 // request id\u000a}</pre>\u000a<p>\u000aAn RPC represents a single RPC issued by a client.\u000a</p>\u000a\u000a","name":"RPC","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RPC\">func (*RPC)</a> <a href=\"?m:RPC.Call!\">Call</a></h2>\u000a<code>func (r *RPC) Call(name string, arg []interface{}) (ret []interface{}, err Errno)</code>\u000a<p>\u000aCall is a convenient wrapper that starts the RPC request,\u000awaits for it to finish, and then returns the results.\u000aIts implementation is:\u000a</p>\u000a<pre>r.Start(name, arg)\u000a&lt;-r.Done\u000areturn r.Ret, r.Errno\u000a</pre>\u000a\u000a","name":"Call"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RPC\">func (*RPC)</a> <a href=\"?m:RPC.Start!\">Start</a></h2>\u000a<code>func (r *RPC) Start(name string, arg []interface{})</code>\u000a<p>\u000aStart issues an RPC request for method name with the given arguments.\u000aThe RPC r must not be in use for another pending request.\u000aTo wait for the RPC to finish, receive from r.Done and then\u000ainspect r.Ret and r.Errno.\u000a</p>\u000a\u000a","name":"Start"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Add!\">Add</a></h2>\u000a<code>func Add(name, fmt string, handler Handler)</code>\u000a<p>\u000aAdd registers a handler for the named method.\u000aFmt is a Native Client format string, a sequence of\u000aalphabetic characters representing the types of the parameter values,\u000aa colon, and then a sequence of alphabetic characters\u000arepresenting the types of the returned values.\u000aThe format characters and corresponding dynamic types are:\u000a</p>\u000a<pre>b\u0009bool\u000aC\u0009[]byte\u000ad\u0009float64\u000aD\u0009[]float64\u000ah\u0009int\u0009// a file descriptor (aka handle)\u000ai\u0009int32\u000aI\u0009[]int32\u000as\u0009string\u000a</pre>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Enabled!\">Enabled</a></h2>\u000a<code>func Enabled() bool</code>\u000a<p>\u000aEnabled returns true if SRPC is enabled in the Native Client runtime.\u000a</p>\u000a\u000a","name":"Enabled"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClient!\">NewClient</a></h2>\u000a<code>func NewClient(fd int) (c *Client, err os.Error)</code>\u000a<p>\u000aNewClient allocates a new client using the file descriptor fd.\u000a</p>\u000a\u000a","name":"NewClient"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Serve!\">Serve</a></h2>\u000a<code>func Serve(fd int) os.Error</code>\u000a<p>\u000aServe accepts new SRPC connections from the file descriptor fd\u000aand answers RPCs issued on those connections.\u000aIt closes fd and returns an error if the imc_accept system call fails.\u000a</p>\u000a\u000a","name":"Serve"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeRuntime!\">ServeRuntime</a></h2>\u000a<code>func ServeRuntime() os.Error</code>\u000a<p>\u000aServeRuntime serves RPCs issued by the Native Client embedded runtime.\u000aThis should be called by main once all methods have been registered using Add.\u000a</p>\u000a\u000a","name":"ServeRuntime"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Errno!\">Errno</a></h2>\u000a<pre>const (\u000a\u0009OK Errno = 256 + iota\u000a\u0009ErrBreak\u000a\u0009ErrMessageTruncated\u000a\u0009ErrNoMemory\u000a\u0009ErrProtocolMismatch\u000a\u0009ErrBadRPCNumber\u000a\u0009ErrBadArgType\u000a\u0009ErrTooFewArgs\u000a\u0009ErrTooManyArgs\u000a\u0009ErrInArgTypeMismatch\u000a\u0009ErrOutArgTypeMismatch\u000a\u0009ErrInternalError\u000a\u0009ErrAppError\u000a)</pre>\u000a\u000a","names":["OK","ErrBreak","ErrMessageTruncated","ErrNoMemory","ErrProtocolMismatch","ErrBadRPCNumber","ErrBadArgType","ErrTooFewArgs","ErrTooManyArgs","ErrInArgTypeMismatch","ErrOutArgTypeMismatch","ErrInternalError","ErrAppError"],"type":"Errno"}],"vars":[]}