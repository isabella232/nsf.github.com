var gowtfData = {"html":"<p>\u000aA scanner and tokenizer for UTF-8-encoded text.  Takes an io.Reader\u000aproviding the source, which then can be tokenized through repeated calls\u000ato the Scan function.  For compatibility with existing tools, the NUL\u000acharacter is not allowed (implementation restriction).\u000a</p>\u000a<p>\u000aBy default, a Scanner skips white space and Go comments and recognizes all\u000aliterals as defined by the Go language specification.  It may be\u000acustomized to recognize only a subset of those literals and to recognize\u000adifferent white space characters.\u000a</p>\u000a<p>\u000aBasic usage pattern:\u000a</p>\u000a<pre>var s scanner.Scanner\u000as.Init(src)\u000atok := s.Scan()\u000afor tok != scanner.EOF {\u000a\u0009// do something with tok\u000a\u0009tok = s.Scan()\u000a}\u000a</pre>\u000a","name":"scanner","filenames":["/home/nsf/go/src/pkg/scanner/scanner.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Position!\">Position</a></h2>\u000a<pre>type Position struct {\u000a\u0009Filename string // filename, if any\u000a\u0009Offset   int    // byte offset, starting at 0\u000a\u0009Line     int    // line number, starting at 1\u000a\u0009Column   int    // column number, starting at 0 (character count per line)\u000a}</pre>\u000a<p>\u000aA source position is represented by a Position value.\u000aA position is valid if Line &gt; 0.\u000a</p>\u000a\u000a","name":"Position","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.IsValid!\">IsValid</a></h2>\u000a<code>func (pos *Position) IsValid() bool</code>\u000a<p>\u000aIsValid returns true if the position is valid.\u000a</p>\u000a\u000a","name":"IsValid"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Position\">func (Position)</a> <a href=\"?m:Position.String!\">String</a></h2>\u000a<code>func (pos Position) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scanner!\">Scanner</a></h2>\u000a<pre>type Scanner struct {\u000a\u0009// Input\u000a\u0009src io.Reader\u000a\u000a\u0009// Source buffer\u000a\u0009srcBuf [bufLen + 1]byte // +1 for sentinel for common case of s.next()\u000a\u0009srcPos int              // reading position (srcBuf index)\u000a\u0009srcEnd int              // source end (srcBuf index)\u000a\u000a\u000a\u0009// Source position\u000a\u0009srcBufOffset int // byte offset of srcBuf[0] in source\u000a\u0009line         int // newline count + 1\u000a\u0009column       int // character count on line\u000a\u000a\u000a\u0009// Token text buffer\u000a\u0009// Typically, token text is stored completely in srcBuf, but in general\u000a\u0009// the token text&#39;s head may be buffered in tokBuf while the token text&#39;s\u000a\u0009// tail is stored in srcBuf.\u000a\u0009tokBuf bytes.Buffer // token text head that is not in srcBuf anymore\u000a\u0009tokPos int          // token text tail position (srcBuf index)\u000a\u0009tokEnd int          // token text tail end (srcBuf index)\u000a\u000a\u000a\u0009// One character look-ahead\u000a\u0009ch int // character before current srcPos\u000a\u000a\u000a\u0009// Error is called for each error encountered. If no Error\u000a\u0009// function is set, the error is reported to os.Stderr.\u000a\u0009Error func(s *Scanner, msg string)\u000a\u000a\u0009// ErrorCount is incremented by one for each error encountered.\u000a\u0009ErrorCount int\u000a\u000a\u0009// The Mode field controls which tokens are recognized. For instance,\u000a\u0009// to recognize Ints, set the ScanInts bit in Mode. The field may be\u000a\u0009// changed at any time.\u000a\u0009Mode uint\u000a\u000a\u0009// The Whitespace field controls which characters are recognized\u000a\u0009// as white space. To recognize a character ch &lt;= &#39; &#39; as white space,\u000a\u0009// set the ch&#39;th bit in Whitespace (the Scanner&#39;s behavior is undefined\u000a\u0009// for values ch &gt; &#39; &#39;). The field may be changed at any time.\u000a\u0009Whitespace uint64\u000a\u000a\u0009// Current token position. The Offset, Line, and Column fields\u000a\u0009// are set by Scan(); the Filename field is left untouched by the\u000a\u0009// Scanner.\u000a\u0009Position\u000a}</pre>\u000a<p>\u000aA Scanner implements reading of Unicode characters and tokens from an io.Reader.\u000a</p>\u000a\u000a","name":"Scanner","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Init!\">Init</a></h2>\u000a<code>func (s *Scanner) Init(src io.Reader) *Scanner</code>\u000a<p>\u000aInit initializes a Scanner with a new source and returns itself.\u000aError is set to nil, ErrorCount is set to 0, Mode is set to GoTokens,\u000aand Whitespace is set to GoWhitespace.\u000a</p>\u000a\u000a","name":"Init"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Next!\">Next</a></h2>\u000a<code>func (s *Scanner) Next() int</code>\u000a<p>\u000aNext reads and returns the next Unicode character.\u000aIt returns EOF at the end of the source. It reports\u000aa read error by calling s.Error, if set, or else\u000aprints an error message to os.Stderr. Next does not\u000aupdate the Scanner&#39;s Position field; use Pos() to\u000aget the current position.\u000a</p>\u000a\u000a","name":"Next"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Peek!\">Peek</a></h2>\u000a<code>func (s *Scanner) Peek() int</code>\u000a<p>\u000aPeek returns the next Unicode character in the source without advancing\u000athe scanner. It returns EOF if the scanner&#39;s position is at the last\u000acharacter of the source.\u000a</p>\u000a\u000a","name":"Peek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Pos!\">Pos</a></h2>\u000a<code>func (s *Scanner) Pos() Position</code>\u000a<p>\u000aPosition returns the current source position. If called before Next()\u000aor Scan(), it returns the position of the next Unicode character or token\u000areturned by these functions. If called afterwards, it returns the position\u000aimmediately after the last character of the most recent token or character\u000ascanned.\u000a</p>\u000a\u000a","name":"Pos"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Scan!\">Scan</a></h2>\u000a<code>func (s *Scanner) Scan() int</code>\u000a<p>\u000aScan reads the next token or Unicode character from source and returns it.\u000aIt only recognizes tokens t for which the respective Mode bit (1&lt;&lt;-t) is set.\u000aIt returns EOF at the end of the source. It reports scanner errors (read and\u000atoken errors) by calling s.Error, if set; otherwise it prints an error message\u000ato os.Stderr.\u000a</p>\u000a\u000a","name":"Scan"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.TokenText!\">TokenText</a></h2>\u000a<code>func (s *Scanner) TokenText() string</code>\u000a<p>\u000aTokenText returns the string corresponding to the most recently scanned token.\u000aValid after calling Scan().\u000a</p>\u000a\u000a","name":"TokenText"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TokenString!\">TokenString</a></h2>\u000a<code>func TokenString(tok int) string</code>\u000a<p>\u000aTokenString returns a (visible) string for a token or Unicode character.\u000a</p>\u000a\u000a","name":"TokenString"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ScanIdents!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009ScanIdents     = 1 &lt;&lt; -Ident\u000a\u0009ScanInts       = 1 &lt;&lt; -Int\u000a\u0009ScanFloats     = 1 &lt;&lt; -Float // includes Ints\u000a\u0009ScanChars      = 1 &lt;&lt; -Char\u000a\u0009ScanStrings    = 1 &lt;&lt; -String\u000a\u0009ScanRawStrings = 1 &lt;&lt; -RawString\u000a\u0009ScanComments   = 1 &lt;&lt; -Comment\u000a\u0009SkipComments   = 1 &lt;&lt; -skipComment // if set with ScanComments, comments become white space\u000a\u0009GoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments\u000a)</pre>\u000a<p>\u000aPredefined mode bits to control recognition of tokens. For instance,\u000ato configure a Scanner such that it only recognizes (Go) identifiers,\u000aintegers, and skips comments, set the Scanner&#39;s Mode field to:\u000a</p>\u000a<pre>ScanIdents | ScanInts | SkipComments\u000a</pre>\u000a\u000a","names":["ScanIdents","ScanInts","ScanFloats","ScanChars","ScanStrings","ScanRawStrings","ScanComments","SkipComments","GoTokens"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EOF!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009EOF = -(iota + 1)\u000a\u0009Ident\u000a\u0009Int\u000a\u0009Float\u000a\u0009Char\u000a\u0009String\u000a\u0009RawString\u000a\u0009Comment\u000a\u0009skipComment\u000a)</pre>\u000a<p>\u000aThe result of Scan is one of the following tokens or a Unicode character.\u000a</p>\u000a\u000a","names":["EOF","Ident","Int","Float","Char","String","RawString","Comment"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GoWhitespace!\">GoWhitespace</a></h2>\u000a<pre>const GoWhitespace = 1&lt;&lt;&#39;\\t&#39; | 1&lt;&lt;&#39;\\n&#39; | 1&lt;&lt;&#39;\\r&#39; | 1&lt;&lt;&#39; &#39;</pre>\u000a<p>\u000aGoWhitespace is the default value for the Scanner&#39;s Whitespace field.\u000aIts value selects Go&#39;s white space characters.\u000a</p>\u000a\u000a","names":["GoWhitespace"],"type":""}],"vars":[]}