var gowtfData = {"html":"<p>\u000aThe AST package declares the types used to represent\u000asyntax trees for Go packages.\u000a</p>\u000a","name":"ast","filenames":["/home/nsf/go/src/pkg/go/ast/walk.go","/home/nsf/go/src/pkg/go/ast/scope.go","/home/nsf/go/src/pkg/go/ast/print.go","/home/nsf/go/src/pkg/go/ast/ast.go","/home/nsf/go/src/pkg/go/ast/filter.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\u000a<pre>type ArrayType struct {\u000a\u0009token.Position      // position of &#34;[&#34;\u000a\u0009Len            Expr // Ellipsis node for [...]T array types, nil for slice types\u000a\u0009Elt            Expr // element type\u000a}</pre>\u000a<p>\u000aAn ArrayType node represents an array or slice type.\u000a</p>\u000a\u000a","name":"ArrayType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AssignStmt!\">AssignStmt</a></h2>\u000a<pre>type AssignStmt struct {\u000a\u0009Lhs    []Expr\u000a\u0009TokPos token.Position // position of Tok\u000a\u0009Tok    token.Token    // assignment token, DEFINE\u000a\u0009Rhs    []Expr\u000a}</pre>\u000a<p>\u000aAn AssignStmt node represents an assignment or\u000aa short variable declaration.\u000a</p>\u000a\u000a","name":"AssignStmt","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:AssignStmt\">func (*AssignStmt)</a> <a href=\"?m:AssignStmt.Pos!\">Pos</a></h2>\u000a<code>func (s *AssignStmt) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadDecl!\">BadDecl</a></h2>\u000a<pre>type BadDecl struct {\u000a\u0009token.Position // beginning position of bad declaration\u000a}</pre>\u000a<p>\u000aA BadDecl node is a placeholder for declarations containing\u000asyntax errors for which no correct declaration nodes can be\u000acreated.\u000a</p>\u000a\u000a","name":"BadDecl","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadExpr!\">BadExpr</a></h2>\u000a<pre>type BadExpr struct {\u000a\u0009token.Position // beginning position of bad expression\u000a}</pre>\u000a<p>\u000aA BadExpr node is a placeholder for expressions containing\u000asyntax errors for which no correct expression nodes can be\u000acreated.\u000a</p>\u000a\u000a","name":"BadExpr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadStmt!\">BadStmt</a></h2>\u000a<pre>type BadStmt struct {\u000a\u0009token.Position // beginning position of bad statement\u000a}</pre>\u000a<p>\u000aA BadStmt node is a placeholder for statements containing\u000asyntax errors for which no correct statement nodes can be\u000acreated.\u000a</p>\u000a\u000a","name":"BadStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BasicLit!\">BasicLit</a></h2>\u000a<pre>type BasicLit struct {\u000a\u0009token.Position             // literal position\u000a\u0009Kind           token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\u000a\u0009Value          []byte      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, &#39;a&#39;, &#39;\\x7f&#39;, &#34;foo&#34; or `\\m\\n\\o`\u000a}</pre>\u000a<p>\u000aA BasicLit node represents a literal of basic type.\u000a</p>\u000a\u000a","name":"BasicLit","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BinaryExpr!\">BinaryExpr</a></h2>\u000a<pre>type BinaryExpr struct {\u000a\u0009X     Expr           // left operand\u000a\u0009OpPos token.Position // position of Op\u000a\u0009Op    token.Token    // operator\u000a\u0009Y     Expr           // right operand\u000a}</pre>\u000a<p>\u000aA BinaryExpr node represents a binary expression.\u000a</p>\u000a\u000a","name":"BinaryExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:BinaryExpr\">func (*BinaryExpr)</a> <a href=\"?m:BinaryExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *BinaryExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BlockStmt!\">BlockStmt</a></h2>\u000a<pre>type BlockStmt struct {\u000a\u0009token.Position // position of &#34;{&#34;\u000a\u0009List           []Stmt\u000a\u0009Rbrace         token.Position // position of &#34;}&#34;\u000a}</pre>\u000a<p>\u000aA BlockStmt node represents a braced statement list.\u000a</p>\u000a\u000a","name":"BlockStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BranchStmt!\">BranchStmt</a></h2>\u000a<pre>type BranchStmt struct {\u000a\u0009token.Position             // position of Tok\u000a\u0009Tok            token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\u000a\u0009Label          *Ident\u000a}</pre>\u000a<p>\u000aA BranchStmt node represents a break, continue, goto,\u000aor fallthrough statement.\u000a</p>\u000a\u000a","name":"BranchStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CallExpr!\">CallExpr</a></h2>\u000a<pre>type CallExpr struct {\u000a\u0009Fun      Expr           // function expression\u000a\u0009Lparen   token.Position // position of &#34;(&#34;\u000a\u0009Args     []Expr         // function arguments\u000a\u0009Ellipsis token.Position // position of &#34;...&#34;, if any\u000a\u0009Rparen   token.Position // position of &#34;)&#34;\u000a}</pre>\u000a<p>\u000aA CallExpr node represents an expression followed by an argument list.\u000a</p>\u000a\u000a","name":"CallExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CallExpr\">func (*CallExpr)</a> <a href=\"?m:CallExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *CallExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CaseClause!\">CaseClause</a></h2>\u000a<pre>type CaseClause struct {\u000a\u0009token.Position                // position of &#34;case&#34; or &#34;default&#34; keyword\u000a\u0009Values         []Expr         // nil means default case\u000a\u0009Colon          token.Position // position of &#34;:&#34;\u000a\u0009Body           []Stmt         // statement list; or nil\u000a}</pre>\u000a<p>\u000aA CaseClause represents a case of an expression switch statement.\u000a</p>\u000a\u000a","name":"CaseClause","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\u000a<pre>type ChanDir int</pre>\u000a<p>\u000aThe direction of a channel type is indicated by one\u000aof the following constants.\u000a</p>\u000a\u000a","name":"ChanDir","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\u000a<pre>type ChanType struct {\u000a\u0009token.Position         // position of &#34;chan&#34; keyword or &#34;&lt;-&#34; (whichever comes first)\u000a\u0009Dir            ChanDir // channel direction\u000a\u0009Value          Expr    // value type\u000a}</pre>\u000a<p>\u000aA ChanType node represents a channel type.\u000a</p>\u000a\u000a","name":"ChanType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommClause!\">CommClause</a></h2>\u000a<pre>type CommClause struct {\u000a\u0009token.Position                // position of &#34;case&#34; or &#34;default&#34; keyword\u000a\u0009Tok            token.Token    // ASSIGN or DEFINE (valid only if Lhs != nil)\u000a\u0009Lhs, Rhs       Expr           // Rhs == nil means default case\u000a\u0009Colon          token.Position // position of &#34;:&#34;\u000a\u0009Body           []Stmt         // statement list; or nil\u000a}</pre>\u000a<p>\u000aA CommClause node represents a case of a select statement.\u000a</p>\u000a\u000a","name":"CommClause","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Comment!\">Comment</a></h2>\u000a<pre>type Comment struct {\u000a\u0009token.Position        // beginning position of the comment\u000a\u0009Text           []byte // comment text (excluding &#39;\\n&#39; for //-style comments)\u000a}</pre>\u000a<p>\u000aA Comment node represents a single //-style or /*-style comment.\u000a</p>\u000a\u000a","name":"Comment","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommentGroup!\">CommentGroup</a></h2>\u000a<pre>type CommentGroup struct {\u000a\u0009List []*Comment\u000a}</pre>\u000a<p>\u000aA CommentGroup represents a sequence of comments\u000awith no other tokens and no empty lines between.\u000a</p>\u000a\u000a","name":"CommentGroup","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CompositeLit!\">CompositeLit</a></h2>\u000a<pre>type CompositeLit struct {\u000a\u0009Type   Expr           // literal type; or nil\u000a\u0009Lbrace token.Position // position of &#34;{&#34;\u000a\u0009Elts   []Expr         // list of composite elements\u000a\u0009Rbrace token.Position // position of &#34;}&#34;\u000a}</pre>\u000a<p>\u000aA CompositeLit node represents a composite literal.\u000a</p>\u000a\u000a","name":"CompositeLit","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CompositeLit\">func (*CompositeLit)</a> <a href=\"?m:CompositeLit.Pos!\">Pos</a></h2>\u000a<code>func (x *CompositeLit) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decl!\">Decl</a></h2>\u000a<pre>type Decl interface {\u000a\u0009Node\u000a\u0009declNode()\u000a}</pre>\u000a<p>\u000aAll declaration nodes implement the Decl interface.\u000a</p>\u000a\u000a","name":"Decl","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DeclStmt!\">DeclStmt</a></h2>\u000a<pre>type DeclStmt struct {\u000a\u0009Decl Decl\u000a}</pre>\u000a<p>\u000aA DeclStmt node represents a declaration in a statement list.\u000a</p>\u000a\u000a","name":"DeclStmt","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DeclStmt\">func (*DeclStmt)</a> <a href=\"?m:DeclStmt.Pos!\">Pos</a></h2>\u000a<code>func (s *DeclStmt) Pos() token.Position</code>\u000a<p>\u000aPos() implementations for statement nodes where the position\u000acorresponds to the position of a sub-node.\u000a</p>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DeferStmt!\">DeferStmt</a></h2>\u000a<pre>type DeferStmt struct {\u000a\u0009token.Position // position of &#34;defer&#34; keyword\u000a\u0009Call           *CallExpr\u000a}</pre>\u000a<p>\u000aA DeferStmt node represents a defer statement.\u000a</p>\u000a\u000a","name":"DeferStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Ellipsis!\">Ellipsis</a></h2>\u000a<pre>type Ellipsis struct {\u000a\u0009token.Position      // position of &#34;...&#34;\u000a\u0009Elt            Expr // ellipsis element type (parameter lists only)\u000a}</pre>\u000a<p>\u000aAn Ellipsis node stands for the &#34;...&#34; type in a\u000aparameter list or the &#34;...&#34; length in an array type.\u000a</p>\u000a\u000a","name":"Ellipsis","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EmptyStmt!\">EmptyStmt</a></h2>\u000a<pre>type EmptyStmt struct {\u000a\u0009token.Position // position of preceeding &#34;;&#34;\u000a}</pre>\u000a<p>\u000aAn EmptyStmt node represents an empty statement.\u000aThe &#34;position&#34; of the empty statement is the position\u000aof the immediately preceeding semicolon.\u000a</p>\u000a\u000a","name":"EmptyStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Expr!\">Expr</a></h2>\u000a<pre>type Expr interface {\u000a\u0009Node\u000a\u0009exprNode()\u000a}</pre>\u000a<p>\u000aAll expression nodes implement the Expr interface.\u000a</p>\u000a\u000a","name":"Expr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ExprStmt!\">ExprStmt</a></h2>\u000a<pre>type ExprStmt struct {\u000a\u0009X Expr // expression\u000a}</pre>\u000a<p>\u000aAn ExprStmt node represents a (stand-alone) expression\u000ain a statement list.\u000a</p>\u000a\u000a","name":"ExprStmt","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ExprStmt\">func (*ExprStmt)</a> <a href=\"?m:ExprStmt.Pos!\">Pos</a></h2>\u000a<code>func (s *ExprStmt) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Field!\">Field</a></h2>\u000a<pre>type Field struct {\u000a\u0009Doc     *CommentGroup // associated documentation; or nil\u000a\u0009Names   []*Ident      // field/method/parameter names; or nil if anonymous field\u000a\u0009Type    Expr          // field/method/parameter type\u000a\u0009Tag     *BasicLit     // field tag; or nil\u000a\u0009Comment *CommentGroup // line comments; or nil\u000a}</pre>\u000a<p>\u000aA Field represents a Field declaration list in a struct type,\u000aa method list in an interface type, or a parameter/result declaration\u000ain a signature.\u000a</p>\u000a\u000a","name":"Field","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Field\">func (*Field)</a> <a href=\"?m:Field.Pos!\">Pos</a></h2>\u000a<code>func (f *Field) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FieldFilter!\">FieldFilter</a></h2>\u000a<pre>type FieldFilter func(name string, value reflect.Value) bool</pre>\u000a<p>\u000aA FieldFilter may be provided to Fprint to control the output.\u000a</p>\u000a\u000a","name":"FieldFilter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FieldList!\">FieldList</a></h2>\u000a<pre>type FieldList struct {\u000a\u0009Opening token.Position // position of opening parenthesis/brace\u000a\u0009List    []*Field       // field list\u000a\u0009Closing token.Position // position of closing parenthesis/brace\u000a}</pre>\u000a<p>\u000aA FieldList represents a list of Fields, enclosed by parentheses or braces.\u000a</p>\u000a\u000a","name":"FieldList","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FieldList\">func (*FieldList)</a> <a href=\"?m:FieldList.NumFields!\">NumFields</a></h2>\u000a<code>func (f *FieldList) NumFields() int</code>\u000a<p>\u000aNumFields returns the number of (named and anonymous fields) in a FieldList.\u000a</p>\u000a\u000a","name":"NumFields"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\u000a<pre>type File struct {\u000a\u0009Doc            *CommentGroup   // associated documentation; or nil\u000a\u0009token.Position                 // position of &#34;package&#34; keyword\u000a\u0009Name           *Ident          // package name\u000a\u0009Decls          []Decl          // top-level declarations\u000a\u0009Comments       []*CommentGroup // list of all comments in the source file\u000a}</pre>\u000a<p>\u000aA File node represents a Go source file.\u000a</p>\u000a<p>\u000aThe Comments list contains all comments in the source file in order of\u000aappearance, including the comments that are pointed to from other nodes\u000avia Doc and Comment fields.\u000a</p>\u000a\u000a","name":"File","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Filter!\">Filter</a></h2>\u000a<pre>type Filter func(string) bool</pre>\u000a\u000a","name":"Filter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ForStmt!\">ForStmt</a></h2>\u000a<pre>type ForStmt struct {\u000a\u0009token.Position // position of &#34;for&#34; keyword\u000a\u0009Init           Stmt\u000a\u0009Cond           Expr\u000a\u0009Post           Stmt\u000a\u0009Body           *BlockStmt\u000a}</pre>\u000a<p>\u000aA ForStmt represents a for statement.\u000a</p>\u000a\u000a","name":"ForStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Form!\">Form</a></h2>\u000a<pre>type Form int</pre>\u000a<p>\u000aForm describes the form of a type.\u000a</p>\u000a\u000a","name":"Form","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Form\">func (Form)</a> <a href=\"?m:Form.String!\">String</a></h2>\u000a<code>func (form Form) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncDecl!\">FuncDecl</a></h2>\u000a<pre>type FuncDecl struct {\u000a\u0009Doc  *CommentGroup // associated documentation; or nil\u000a\u0009Recv *FieldList    // receiver (methods); or nil (functions)\u000a\u0009Name *Ident        // function/method name\u000a\u0009Type *FuncType     // position of Func keyword, parameters and results\u000a\u0009Body *BlockStmt    // function body; or nil (forward declaration)\u000a}</pre>\u000a<p>\u000aA FuncDecl node represents a function declaration.\u000a</p>\u000a\u000a","name":"FuncDecl","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncDecl\">func (*FuncDecl)</a> <a href=\"?m:FuncDecl.Pos!\">Pos</a></h2>\u000a<code>func (d *FuncDecl) Pos() token.Position</code>\u000a<p>\u000aThe position of a FuncDecl node is the position of its function type.\u000a</p>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncLit!\">FuncLit</a></h2>\u000a<pre>type FuncLit struct {\u000a\u0009Type *FuncType  // function type\u000a\u0009Body *BlockStmt // function body\u000a}</pre>\u000a<p>\u000aA FuncLit node represents a function literal.\u000a</p>\u000a\u000a","name":"FuncLit","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncLit\">func (*FuncLit)</a> <a href=\"?m:FuncLit.Pos!\">Pos</a></h2>\u000a<code>func (x *FuncLit) Pos() token.Position</code>\u000a<p>\u000aPos() implementations for expression/type where the position\u000acorresponds to the position of a sub-node.\u000a</p>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\u000a<pre>type FuncType struct {\u000a\u0009token.Position            // position of &#34;func&#34; keyword\u000a\u0009Params         *FieldList // (incoming) parameters\u000a\u0009Results        *FieldList // (outgoing) results\u000a}</pre>\u000a<p>\u000aA FuncType node represents a function type.\u000a</p>\u000a\u000a","name":"FuncType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GenDecl!\">GenDecl</a></h2>\u000a<pre>type GenDecl struct {\u000a\u0009Doc            *CommentGroup  // associated documentation; or nil\u000a\u0009token.Position                // position of Tok\u000a\u0009Tok            token.Token    // IMPORT, CONST, TYPE, VAR\u000a\u0009Lparen         token.Position // position of &#39;(&#39;, if any\u000a\u0009Specs          []Spec\u000a\u0009Rparen         token.Position // position of &#39;)&#39;, if any\u000a}</pre>\u000a<p>\u000aA GenDecl node (generic declaration node) represents an import,\u000aconstant, type or variable declaration. A valid Lparen position\u000a(Lparen.Line &gt; 0) indicates a parenthesized declaration.\u000a</p>\u000a<p>\u000aRelationship between Tok value and Specs element type:\u000a</p>\u000a<pre>token.IMPORT  *ImportSpec\u000atoken.CONST   *ValueSpec\u000atoken.TYPE    *TypeSpec\u000atoken.VAR     *ValueSpec\u000a</pre>\u000a\u000a","name":"GenDecl","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoStmt!\">GoStmt</a></h2>\u000a<pre>type GoStmt struct {\u000a\u0009token.Position // position of &#34;go&#34; keyword\u000a\u0009Call           *CallExpr\u000a}</pre>\u000a<p>\u000aA GoStmt node represents a go statement.\u000a</p>\u000a\u000a","name":"GoStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Ident!\">Ident</a></h2>\u000a<pre>type Ident struct {\u000a\u0009token.Position         // identifier position\u000a\u0009Name           string  // identifier name\u000a\u0009Obj            *Object // denoted object; or nil\u000a}</pre>\u000a<p>\u000aAn Ident node represents an identifier.\u000a</p>\u000a\u000a","name":"Ident","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.IsExported!\">IsExported</a></h2>\u000a<code>func (id *Ident) IsExported() bool</code>\u000a<p>\u000aIsExported returns whether id is an exported Go symbol\u000a(i.e., whether it begins with an uppercase letter).\u000a</p>\u000a\u000a","name":"IsExported"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.String!\">String</a></h2>\u000a<code>func (id *Ident) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IfStmt!\">IfStmt</a></h2>\u000a<pre>type IfStmt struct {\u000a\u0009token.Position // position of &#34;if&#34; keyword\u000a\u0009Init           Stmt\u000a\u0009Cond           Expr\u000a\u0009Body           *BlockStmt\u000a\u0009Else           Stmt\u000a}</pre>\u000a<p>\u000aAn IfStmt node represents an if statement.\u000a</p>\u000a\u000a","name":"IfStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ImportSpec!\">ImportSpec</a></h2>\u000a<pre>type ImportSpec struct {\u000a\u0009Doc     *CommentGroup // associated documentation; or nil\u000a\u0009Name    *Ident        // local package name (including &#34;.&#34;); or nil\u000a\u0009Path    *BasicLit     // package path\u000a\u0009Comment *CommentGroup // line comments; or nil\u000a}</pre>\u000a<p>\u000aAn ImportSpec node represents a single package import.\u000a</p>\u000a\u000a","name":"ImportSpec","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ImportSpec\">func (*ImportSpec)</a> <a href=\"?m:ImportSpec.Pos!\">Pos</a></h2>\u000a<code>func (s *ImportSpec) Pos() token.Position</code>\u000a<p>\u000aPos() implementations for spec nodes.\u000a</p>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IncDecStmt!\">IncDecStmt</a></h2>\u000a<pre>type IncDecStmt struct {\u000a\u0009X   Expr\u000a\u0009Tok token.Token // INC or DEC\u000a}</pre>\u000a<p>\u000aAn IncDecStmt node represents an increment or decrement statement.\u000a</p>\u000a\u000a","name":"IncDecStmt","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IncDecStmt\">func (*IncDecStmt)</a> <a href=\"?m:IncDecStmt.Pos!\">Pos</a></h2>\u000a<code>func (s *IncDecStmt) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IndexExpr!\">IndexExpr</a></h2>\u000a<pre>type IndexExpr struct {\u000a\u0009X     Expr // expression\u000a\u0009Index Expr // index expression\u000a}</pre>\u000a<p>\u000aAn IndexExpr node represents an expression followed by an index.\u000a</p>\u000a\u000a","name":"IndexExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IndexExpr\">func (*IndexExpr)</a> <a href=\"?m:IndexExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *IndexExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\u000a<pre>type InterfaceType struct {\u000a\u0009token.Position            // position of &#34;interface&#34; keyword\u000a\u0009Methods        *FieldList // list of methods\u000a\u0009Incomplete     bool       // true if (source) methods are missing in the Methods list\u000a}</pre>\u000a<p>\u000aAn InterfaceType node represents an interface type.\u000a</p>\u000a\u000a","name":"InterfaceType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeyValueExpr!\">KeyValueExpr</a></h2>\u000a<pre>type KeyValueExpr struct {\u000a\u0009Key   Expr\u000a\u0009Colon token.Position // position of &#34;:&#34;\u000a\u0009Value Expr\u000a}</pre>\u000a<p>\u000aA KeyValueExpr node represents (key : value) pairs\u000ain composite literals.\u000a</p>\u000a\u000a","name":"KeyValueExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:KeyValueExpr\">func (*KeyValueExpr)</a> <a href=\"?m:KeyValueExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *KeyValueExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Kind!\">Kind</a></h2>\u000a<pre>type Kind int</pre>\u000a<p>\u000aKind describes what an object represents.\u000a</p>\u000a\u000a","name":"Kind","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Kind\">func (Kind)</a> <a href=\"?m:Kind.String!\">String</a></h2>\u000a<code>func (kind Kind) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LabeledStmt!\">LabeledStmt</a></h2>\u000a<pre>type LabeledStmt struct {\u000a\u0009Label *Ident\u000a\u0009Stmt  Stmt\u000a}</pre>\u000a<p>\u000aA LabeledStmt node represents a labeled statement.\u000a</p>\u000a\u000a","name":"LabeledStmt","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:LabeledStmt\">func (*LabeledStmt)</a> <a href=\"?m:LabeledStmt.Pos!\">Pos</a></h2>\u000a<code>func (s *LabeledStmt) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\u000a<pre>type MapType struct {\u000a\u0009token.Position // position of &#34;map&#34; keyword\u000a\u0009Key            Expr\u000a\u0009Value          Expr\u000a}</pre>\u000a<p>\u000aA MapType node represents a map type.\u000a</p>\u000a\u000a","name":"MapType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MergeMode!\">MergeMode</a></h2>\u000a<pre>type MergeMode uint</pre>\u000a<p>\u000aThe MergeMode flags control the behavior of MergePackageFiles.\u000a</p>\u000a\u000a","name":"MergeMode","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Node!\">Node</a></h2>\u000a<pre>type Node interface {\u000a\u0009// Pos returns the (beginning) position of the node.\u000a\u0009Pos() token.Position\u000a}</pre>\u000a<p>\u000aAll node types implement the Node interface.\u000a</p>\u000a\u000a","name":"Node","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Object!\">Object</a></h2>\u000a<pre>type Object struct {\u000a\u0009Kind Kind\u000a\u0009Name string // declared name\u000a\u0009Type *Type\u000a\u0009Decl interface{} // corresponding Field, XxxSpec or FuncDecl\u000a\u0009N    int         // value of iota for this declaration\u000a}</pre>\u000a<p>\u000aAn Object describes a language entity such as a package,\u000aconstant, type, variable, or function (incl. methods).\u000a</p>\u000a\u000a","name":"Object","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Object\">func (*Object)</a> <a href=\"?m:Object.IsExported!\">IsExported</a></h2>\u000a<code>func (obj *Object) IsExported() bool</code>\u000a<p>\u000aIsExported returns whether obj is exported.\u000a</p>\u000a\u000a","name":"IsExported"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Package!\">Package</a></h2>\u000a<pre>type Package struct {\u000a\u0009Name  string           // package name\u000a\u0009Scope *Scope           // package scope; or nil\u000a\u0009Files map[string]*File // Go source files by filename\u000a}</pre>\u000a<p>\u000aA Package node represents a set of source files\u000acollectively building a Go package.\u000a</p>\u000a\u000a","name":"Package","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ParenExpr!\">ParenExpr</a></h2>\u000a<pre>type ParenExpr struct {\u000a\u0009token.Position                // position of &#34;(&#34;\u000a\u0009X              Expr           // parenthesized expression\u000a\u0009Rparen         token.Position // position of &#34;)&#34;\u000a}</pre>\u000a<p>\u000aA ParenExpr node represents a parenthesized expression.\u000a</p>\u000a\u000a","name":"ParenExpr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RangeStmt!\">RangeStmt</a></h2>\u000a<pre>type RangeStmt struct {\u000a\u0009token.Position                // position of &#34;for&#34; keyword\u000a\u0009Key, Value     Expr           // Value may be nil\u000a\u0009TokPos         token.Position // position of Tok\u000a\u0009Tok            token.Token    // ASSIGN, DEFINE\u000a\u0009X              Expr           // value to range over\u000a\u0009Body           *BlockStmt\u000a}</pre>\u000a<p>\u000aA RangeStmt represents a for statement with a range clause.\u000a</p>\u000a\u000a","name":"RangeStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReturnStmt!\">ReturnStmt</a></h2>\u000a<pre>type ReturnStmt struct {\u000a\u0009token.Position // position of &#34;return&#34; keyword\u000a\u0009Results        []Expr\u000a}</pre>\u000a<p>\u000aA ReturnStmt node represents a return statement.\u000a</p>\u000a\u000a","name":"ReturnStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scope!\">Scope</a></h2>\u000a<pre>type Scope struct {\u000a\u0009Outer   *Scope\u000a\u0009Objects []*Object // in declaration order\u000a\u0009// Implementation note: In some cases (struct fields,\u000a\u0009// function parameters) we need the source order of\u000a\u0009// variables. Thus for now, we store scope entries\u000a\u0009// in a linear list. If scopes become very large\u000a\u0009// (say, for packages), we may need to change this\u000a\u0009// to avoid slow lookups.\u000a}</pre>\u000a<p>\u000aA Scope maintains the set of named language entities declared\u000ain the scope and a link to the immediately surrounding (outer)\u000ascope.\u000a</p>\u000a\u000a","name":"Scope","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scope\">func (*Scope)</a> <a href=\"?m:Scope.Insert!\">Insert</a></h2>\u000a<code>func (s *Scope) Insert(obj *Object) *Object</code>\u000a<p>\u000aInsert attempts to insert a named object into the scope s.\u000aIf the scope does not contain an object with that name yet\u000aor if the object is named &#34;_&#34;, Insert inserts the object\u000aand returns it. Otherwise, Insert leaves the scope unchanged\u000aand returns the object found in the scope instead.\u000a</p>\u000a\u000a","name":"Insert"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scope\">func (*Scope)</a> <a href=\"?m:Scope.Lookup!\">Lookup</a></h2>\u000a<code>func (s *Scope) Lookup(name string) *Object</code>\u000a<p>\u000aLookup returns the object with the given name if it is\u000afound in scope s, otherwise it returns nil. Outer scopes\u000aare ignored.\u000a</p>\u000a<p>\u000aLookup always returns nil if name is &#34;_&#34;, even if the scope\u000acontains objects with that name.\u000a</p>\u000a\u000a","name":"Lookup"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SelectStmt!\">SelectStmt</a></h2>\u000a<pre>type SelectStmt struct {\u000a\u0009token.Position            // position of &#34;select&#34; keyword\u000a\u0009Body           *BlockStmt // CommClauses only\u000a}</pre>\u000a<p>\u000aAn SelectStmt node represents a select statement.\u000a</p>\u000a\u000a","name":"SelectStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SelectorExpr!\">SelectorExpr</a></h2>\u000a<pre>type SelectorExpr struct {\u000a\u0009X   Expr   // expression\u000a\u0009Sel *Ident // field selector\u000a}</pre>\u000a<p>\u000aA SelectorExpr node represents an expression followed by a selector.\u000a</p>\u000a\u000a","name":"SelectorExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SelectorExpr\">func (*SelectorExpr)</a> <a href=\"?m:SelectorExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *SelectorExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceExpr!\">SliceExpr</a></h2>\u000a<pre>type SliceExpr struct {\u000a\u0009X     Expr // expression\u000a\u0009Index Expr // beginning of slice range; or nil\u000a\u0009End   Expr // end of slice range; or nil\u000a}</pre>\u000a<p>\u000aAn SliceExpr node represents an expression followed by slice indices.\u000a</p>\u000a\u000a","name":"SliceExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceExpr\">func (*SliceExpr)</a> <a href=\"?m:SliceExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *SliceExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Spec!\">Spec</a></h2>\u000a<pre>type Spec interface {\u000a\u0009Node\u000a\u0009specNode()\u000a}</pre>\u000a<p>\u000aThe Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\u000a</p>\u000a\u000a","name":"Spec","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StarExpr!\">StarExpr</a></h2>\u000a<pre>type StarExpr struct {\u000a\u0009token.Position      // position of &#34;*&#34;\u000a\u0009X              Expr // operand\u000a}</pre>\u000a<p>\u000aA StarExpr node represents an expression of the form &#34;*&#34; Expression.\u000aSemantically it could be a unary &#34;*&#34; expression, or a pointer type.\u000a</p>\u000a\u000a","name":"StarExpr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Stmt!\">Stmt</a></h2>\u000a<pre>type Stmt interface {\u000a\u0009Node\u000a\u0009stmtNode()\u000a}</pre>\u000a<p>\u000aAll statement nodes implement the Stmt interface.\u000a</p>\u000a\u000a","name":"Stmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\u000a<pre>type StructType struct {\u000a\u0009token.Position            // position of &#34;struct&#34; keyword\u000a\u0009Fields         *FieldList // list of field declarations\u000a\u0009Incomplete     bool       // true if (source) fields are missing in the Fields list\u000a}</pre>\u000a<p>\u000aA StructType node represents a struct type.\u000a</p>\u000a\u000a","name":"StructType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SwitchStmt!\">SwitchStmt</a></h2>\u000a<pre>type SwitchStmt struct {\u000a\u0009token.Position // position of &#34;switch&#34; keyword\u000a\u0009Init           Stmt\u000a\u0009Tag            Expr\u000a\u0009Body           *BlockStmt // CaseClauses only\u000a}</pre>\u000a<p>\u000aA SwitchStmt node represents an expression switch statement.\u000a</p>\u000a\u000a","name":"SwitchStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\u000a<pre>type Type struct {\u000a\u0009Form     Form\u000a\u0009Obj      *Object // corresponding type name, or nil\u000a\u0009Scope    *Scope  // fields and methods, always present\u000a\u0009N        uint    // basic type id, array length, number of function results, or channel direction\u000a\u0009Key, Elt *Type   // map key and array, pointer, slice, map or channel element\u000a\u0009Params   *Scope  // function (receiver, input and result) parameters, tuple expressions (results of function calls), or nil\u000a\u0009Expr     Expr    // corresponding AST expression\u000a}</pre>\u000a<p>\u000aA Type represents a Go type.\u000a</p>\u000a\u000a","name":"Type","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeAssertExpr!\">TypeAssertExpr</a></h2>\u000a<pre>type TypeAssertExpr struct {\u000a\u0009X    Expr // expression\u000a\u0009Type Expr // asserted type; nil means type switch X.(type)\u000a}</pre>\u000a<p>\u000aA TypeAssertExpr node represents an expression followed by a\u000atype assertion.\u000a</p>\u000a\u000a","name":"TypeAssertExpr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertExpr\">func (*TypeAssertExpr)</a> <a href=\"?m:TypeAssertExpr.Pos!\">Pos</a></h2>\u000a<code>func (x *TypeAssertExpr) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeCaseClause!\">TypeCaseClause</a></h2>\u000a<pre>type TypeCaseClause struct {\u000a\u0009token.Position                // position of &#34;case&#34; or &#34;default&#34; keyword\u000a\u0009Types          []Expr         // nil means default case\u000a\u0009Colon          token.Position // position of &#34;:&#34;\u000a\u0009Body           []Stmt         // statement list; or nil\u000a}</pre>\u000a<p>\u000aA TypeCaseClause represents a case of a type switch statement.\u000a</p>\u000a\u000a","name":"TypeCaseClause","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeSpec!\">TypeSpec</a></h2>\u000a<pre>type TypeSpec struct {\u000a\u0009Doc     *CommentGroup // associated documentation; or nil\u000a\u0009Name    *Ident        // type name\u000a\u0009Type    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\u000a\u0009Comment *CommentGroup // line comments; or nil\u000a}</pre>\u000a<p>\u000aA TypeSpec node represents a type declaration (TypeSpec production).\u000a</p>\u000a\u000a","name":"TypeSpec","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeSpec\">func (*TypeSpec)</a> <a href=\"?m:TypeSpec.Pos!\">Pos</a></h2>\u000a<code>func (s *TypeSpec) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeSwitchStmt!\">TypeSwitchStmt</a></h2>\u000a<pre>type TypeSwitchStmt struct {\u000a\u0009token.Position // position of &#34;switch&#34; keyword\u000a\u0009Init           Stmt\u000a\u0009Assign         Stmt       // x := y.(type)\u000a\u0009Body           *BlockStmt // TypeCaseClauses only\u000a}</pre>\u000a<p>\u000aAn TypeSwitchStmt node represents a type switch statement.\u000a</p>\u000a\u000a","name":"TypeSwitchStmt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnaryExpr!\">UnaryExpr</a></h2>\u000a<pre>type UnaryExpr struct {\u000a\u0009token.Position             // position of Op\u000a\u0009Op             token.Token // operator\u000a\u0009X              Expr        // operand\u000a}</pre>\u000a<p>\u000aA UnaryExpr node represents a unary expression.\u000aUnary &#34;*&#34; expressions are represented via StarExpr nodes.\u000a</p>\u000a\u000a","name":"UnaryExpr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ValueSpec!\">ValueSpec</a></h2>\u000a<pre>type ValueSpec struct {\u000a\u0009Doc     *CommentGroup // associated documentation; or nil\u000a\u0009Names   []*Ident      // value names\u000a\u0009Type    Expr          // value type; or nil\u000a\u0009Values  []Expr        // initial values; or nil\u000a\u0009Comment *CommentGroup // line comments; or nil\u000a}</pre>\u000a<p>\u000aA ValueSpec node represents a constant or variable declaration\u000a(ConstSpec or VarSpec production).\u000a</p>\u000a\u000a","name":"ValueSpec","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ValueSpec\">func (*ValueSpec)</a> <a href=\"?m:ValueSpec.Pos!\">Pos</a></h2>\u000a<code>func (s *ValueSpec) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Visitor!\">Visitor</a></h2>\u000a<pre>type Visitor interface {\u000a\u0009Visit(node interface{}) (w Visitor)\u000a}</pre>\u000a<p>\u000aA Visitor&#39;s Visit method is invoked for each node encountered by Walk.\u000aIf the result visitor w is not nil, Walk visits each of the children\u000aof node with the visitor w, followed by a call of w.Visit(nil).\u000a</p>\u000a\u000a","name":"Visitor","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileExports!\">FileExports</a></h2>\u000a<code>func FileExports(src *File) bool</code>\u000a<p>\u000aFileExports trims the AST for a Go source file in place such that only\u000aexported nodes remain: all top-level identifiers which are not exported\u000aand their associated information (such as type, initial value, or function\u000abody) are removed. Non-exported fields and methods of exported types are\u000astripped, and the function bodies of exported functions are set to nil.\u000aThe File.comments list is not changed.\u000a</p>\u000a<p>\u000aFileExports returns true if there is an exported declaration; it returns\u000afalse otherwise.\u000a</p>\u000a\u000a","name":"FileExports"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilterFile!\">FilterFile</a></h2>\u000a<code>func FilterFile(src *File, f Filter) bool</code>\u000a<p>\u000aFilterFile trims the AST for a Go file in place by removing all\u000anames from top-level declarations (but not from parameter lists\u000aor inside types) that don&#39;t pass through the filter f. If the\u000adeclaration is empty afterwards, the declaration is removed from\u000athe AST.\u000aThe File.comments list is not changed.\u000a</p>\u000a<p>\u000aFilterFile returns true if there are any top-level declarations\u000aleft after filtering; it returns false otherwise.\u000a</p>\u000a\u000a","name":"FilterFile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilterPackage!\">FilterPackage</a></h2>\u000a<code>func FilterPackage(pkg *Package, f Filter) bool</code>\u000a<p>\u000aFilterPackage trims the AST for a Go package in place by removing all\u000anames from top-level declarations (but not from parameter lists\u000aor inside types) that don&#39;t pass through the filter f. If the\u000adeclaration is empty afterwards, the declaration is removed from\u000athe AST.\u000aThe pkg.Files list is not changed, so that file names and top-level\u000apackage comments don&#39;t get lost.\u000a</p>\u000a<p>\u000aFilterPackage returns true if there are any top-level declarations\u000aleft after filtering; it returns false otherwise.\u000a</p>\u000a\u000a","name":"FilterPackage"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fprint!\">Fprint</a></h2>\u000a<code>func Fprint(w io.Writer, x interface{}, f FieldFilter) (n int, err os.Error)</code>\u000a<p>\u000aFprint prints the (sub-)tree starting at AST node x to w.\u000a</p>\u000a<p>\u000aA non-nil FieldFilter f may be provided to control the output:\u000astruct fields for which f(fieldname, fieldvalue) is true are\u000aare printed; all others are filtered from the output.\u000a</p>\u000a\u000a","name":"Fprint"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IsExported!\">IsExported</a></h2>\u000a<code>func IsExported(name string) bool</code>\u000a<p>\u000aIsExported returns whether name is an exported Go symbol\u000a(i.e., whether it begins with an uppercase letter).\u000a</p>\u000a\u000a","name":"IsExported"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MergePackageFiles!\">MergePackageFiles</a></h2>\u000a<code>func MergePackageFiles(pkg *Package, mode MergeMode) *File</code>\u000a<p>\u000aMergePackageFiles creates a file AST by merging the ASTs of the\u000afiles belonging to a package. The mode flags control merging behavior.\u000a</p>\u000a\u000a","name":"MergePackageFiles"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewIdent!\">NewIdent</a></h2>\u000a<code>func NewIdent(name string) *Ident</code>\u000a<p>\u000aNewIdent creates a new Ident without position.\u000aUseful for ASTs generated by code other than the Go parser.\u000a</p>\u000a\u000a","name":"NewIdent"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewObj!\">NewObj</a></h2>\u000a<code>func NewObj(kind Kind, name string) *Object</code>\u000a<p>\u000aNewObj creates a new object of a given kind and name.\u000a</p>\u000a\u000a","name":"NewObj"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewScope!\">NewScope</a></h2>\u000a<code>func NewScope(outer *Scope) *Scope</code>\u000a<p>\u000aNewScope creates a new scope nested in the outer scope.\u000a</p>\u000a\u000a","name":"NewScope"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewType!\">NewType</a></h2>\u000a<code>func NewType(form Form) *Type</code>\u000a<p>\u000aNewType creates a new type of a given form.\u000a</p>\u000a\u000a","name":"NewType"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotNilFilter!\">NotNilFilter</a></h2>\u000a<code>func NotNilFilter(_ string, value reflect.Value) bool</code>\u000a<p>\u000aNotNilFilter returns true for field values that are not nil;\u000ait returns false otherwise.\u000a</p>\u000a\u000a","name":"NotNilFilter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PackageExports!\">PackageExports</a></h2>\u000a<code>func PackageExports(pkg *Package) bool</code>\u000a<p>\u000aPackageExports trims the AST for a Go package in place such that only\u000aexported nodes remain. The pkg.Files list is not changed, so that file\u000anames and top-level package comments don&#39;t get lost.\u000a</p>\u000a<p>\u000aPackageExports returns true if there is an exported declaration; it\u000areturns false otherwise.\u000a</p>\u000a\u000a","name":"PackageExports"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Print!\">Print</a></h2>\u000a<code>func Print(x interface{}) (int, os.Error)</code>\u000a<p>\u000aPrint prints x to standard output, skipping nil fields.\u000aPrint(x) is the same as Fprint(os.Stdout, x, NotNilFilter).\u000a</p>\u000a\u000a","name":"Print"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Walk!\">Walk</a></h2>\u000a<code>func Walk(v Visitor, node interface{})</code>\u000a<p>\u000aWalk traverses an AST in depth-first order: If node != nil, it\u000ainvokes v.Visit(node). If the visitor w returned by v.Visit(node) is\u000anot nil, Walk visits each of the children of node with the visitor w,\u000afollowed by a call of w.Visit(nil).\u000a</p>\u000a<p>\u000aWalk may be called with any of the named ast node types. It also\u000aaccepts arguments of type []*Field, []*Ident, []Expr, []Stmt and []Decl;\u000athe respective children are the slice elements.\u000a</p>\u000a\u000a","name":"Walk"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Kind!\">Kind</a></h2>\u000a<pre>const (\u000a\u0009Bad Kind = iota // for error handling\u000a\u0009Pkg             // package\u000a\u0009Con             // constant\u000a\u0009Typ             // type\u000a\u0009Var             // variable\u000a\u0009Fun             // function or method\u000a)</pre>\u000a<p>\u000aThe list of possible Object kinds.\u000a</p>\u000a\u000a","names":["Bad","Pkg","Con","Typ","Var","Fun"],"type":"Kind"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Form!\">Form</a></h2>\u000a<pre>const (\u000a\u0009BadType    Form = iota // for error handling\u000a\u0009Unresolved             // type not fully setup\u000a\u0009Basic\u000a\u0009Array\u000a\u0009Struct\u000a\u0009Pointer\u000a\u0009Function\u000a\u0009Method\u000a\u0009Interface\u000a\u0009Slice\u000a\u0009Map\u000a\u0009Channel\u000a\u0009Tuple\u000a)</pre>\u000a<p>\u000aThe list of possible type forms.\u000a</p>\u000a\u000a","names":["BadType","Unresolved","Basic","Array","Struct","Pointer","Function","Method","Interface","Slice","Map","Channel","Tuple"],"type":"Form"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Bool!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009Bool = iota\u000a\u0009Byte\u000a\u0009Uint\u000a\u0009Int\u000a\u0009Float\u000a\u0009Complex\u000a\u0009Uintptr\u000a\u0009String\u000a\u000a\u0009Uint8\u000a\u0009Uint16\u000a\u0009Uint32\u000a\u0009Uint64\u000a\u000a\u0009Int8\u000a\u0009Int16\u000a\u0009Int32\u000a\u0009Int64\u000a\u000a\u0009Float32\u000a\u0009Float64\u000a\u000a\u0009Complex64\u000a\u0009Complex128\u000a)</pre>\u000a<p>\u000aThe list of basic type id&#39;s.\u000a</p>\u000a\u000a","names":["Bool","Byte","Uint","Int","Float","Complex","Uintptr","String","Uint8","Uint16","Uint32","Uint64","Int8","Int16","Int32","Int64","Float32","Float64","Complex64","Complex128"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\u000a<pre>const (\u000a\u0009SEND ChanDir = 1 &lt;&lt; iota\u000a\u0009RECV\u000a)</pre>\u000a\u000a","names":["SEND","RECV"],"type":"ChanDir"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:MergeMode!\">MergeMode</a></h2>\u000a<pre>const (\u000a\u0009// If set, duplicate function declarations are excluded.\u000a\u0009FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota\u000a\u0009// If set, comments that are not associated with a specific\u000a\u0009// AST node (as Doc or Comment) are excluded.\u000a\u0009FilterUnassociatedComments\u000a)</pre>\u000a\u000a","names":["FilterFuncDuplicates","FilterUnassociatedComments"],"type":"MergeMode"}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:BasicTypes!\">BasicTypes</a></h2>\u000a<pre>var BasicTypes = map[uint]string{\u000a\u0009Bool:    &#34;bool&#34;,\u000a\u0009Byte:    &#34;byte&#34;,\u000a\u0009Uint:    &#34;uint&#34;,\u000a\u0009Int:     &#34;int&#34;,\u000a\u0009Float:   &#34;float&#34;,\u000a\u0009Complex: &#34;complex&#34;,\u000a\u0009Uintptr: &#34;uintptr&#34;,\u000a\u0009String:  &#34;string&#34;,\u000a\u000a\u0009Uint8:  &#34;uint8&#34;,\u000a\u0009Uint16: &#34;uint16&#34;,\u000a\u0009Uint32: &#34;uint32&#34;,\u000a\u0009Uint64: &#34;uint64&#34;,\u000a\u000a\u0009Int8:  &#34;int8&#34;,\u000a\u0009Int16: &#34;int16&#34;,\u000a\u0009Int32: &#34;int32&#34;,\u000a\u0009Int64: &#34;int64&#34;,\u000a\u000a\u0009Float32: &#34;float32&#34;,\u000a\u0009Float64: &#34;float64&#34;,\u000a\u000a\u0009Complex64:  &#34;complex64&#34;,\u000a\u0009Complex128: &#34;complex128&#34;,\u000a}</pre>\u000a\u000a","names":["BasicTypes"],"type":""}]}