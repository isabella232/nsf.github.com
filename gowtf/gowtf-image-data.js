var gowtfData = {"html":"<p>\u000aThe image package implements a basic 2-D image library.\u000a</p>\u000a","name":"image","filenames":["/home/nsf/go/src/pkg/image/image.go","/home/nsf/go/src/pkg/image/color.go","/home/nsf/go/src/pkg/image/format.go","/home/nsf/go/src/pkg/image/names.go","/home/nsf/go/src/pkg/image/geom.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha!\">Alpha</a></h2>\u000a<pre>type Alpha struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []AlphaColor\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn Alpha is an in-memory image of AlphaColor values.\u000a</p>\u000a\u000a","name":"Alpha","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.At!\">At</a></h2>\u000a<code>func (p *Alpha) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Bounds!\">Bounds</a></h2>\u000a<code>func (p *Alpha) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *Alpha) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Opaque!\">Opaque</a></h2>\u000a<code>func (p *Alpha) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Set!\">Set</a></h2>\u000a<code>func (p *Alpha) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha16!\">Alpha16</a></h2>\u000a<pre>type Alpha16 struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []Alpha16Color\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn Alpha16 is an in-memory image of Alpha16Color values.\u000a</p>\u000a\u000a","name":"Alpha16","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.At!\">At</a></h2>\u000a<code>func (p *Alpha16) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Bounds!\">Bounds</a></h2>\u000a<code>func (p *Alpha16) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *Alpha16) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Opaque!\">Opaque</a></h2>\u000a<code>func (p *Alpha16) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Set!\">Set</a></h2>\u000a<code>func (p *Alpha16) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha16Color!\">Alpha16Color</a></h2>\u000a<pre>type Alpha16Color struct {\u000a\u0009A uint16\u000a}</pre>\u000a<p>\u000aAn Alpha16Color represents a 16-bit alpha.\u000a</p>\u000a\u000a","name":"Alpha16Color","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alpha16Color\">func (Alpha16Color)</a> <a href=\"?m:Alpha16Color.RGBA!\">RGBA</a></h2>\u000a<code>func (c Alpha16Color) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AlphaColor!\">AlphaColor</a></h2>\u000a<pre>type AlphaColor struct {\u000a\u0009A uint8\u000a}</pre>\u000a<p>\u000aAn AlphaColor represents an 8-bit alpha.\u000a</p>\u000a\u000a","name":"AlphaColor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:AlphaColor\">func (AlphaColor)</a> <a href=\"?m:AlphaColor.RGBA!\">RGBA</a></h2>\u000a<code>func (c AlphaColor) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Color!\">Color</a></h2>\u000a<pre>type Color interface {\u000a\u0009RGBA() (r, g, b, a uint32)\u000a}</pre>\u000a<p>\u000aAll Colors can convert themselves, with a possible loss of precision,\u000ato 64-bit alpha-premultiplied RGBA. Each channel value ranges within\u000a[0, 0xFFFF].\u000a</p>\u000a\u000a","name":"Color","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorImage!\">ColorImage</a></h2>\u000a<pre>type ColorImage struct {\u000a\u0009C Color\u000a}</pre>\u000a<p>\u000aA ColorImage is an infinite-sized Image of uniform Color.\u000aIt implements both the Color and Image interfaces.\u000a</p>\u000a\u000a","name":"ColorImage","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.At!\">At</a></h2>\u000a<code>func (c *ColorImage) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.Bounds!\">Bounds</a></h2>\u000a<code>func (c *ColorImage) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.ColorModel!\">ColorModel</a></h2>\u000a<code>func (c *ColorImage) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.Opaque!\">Opaque</a></h2>\u000a<code>func (c *ColorImage) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.RGBA!\">RGBA</a></h2>\u000a<code>func (c *ColorImage) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorModel!\">ColorModel</a></h2>\u000a<pre>type ColorModel interface {\u000a\u0009Convert(c Color) Color\u000a}</pre>\u000a<p>\u000aA ColorModel can convert foreign Colors, with a possible loss of precision,\u000ato a Color from its own color model.\u000a</p>\u000a\u000a","name":"ColorModel","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorModelFunc!\">ColorModelFunc</a></h2>\u000a<pre>type ColorModelFunc func(Color) Color</pre>\u000a<p>\u000aThe ColorModelFunc type is an adapter to allow the use of an ordinary\u000acolor conversion function as a ColorModel.  If f is such a function,\u000aColorModelFunc(f) is a ColorModel object that invokes f to implement\u000athe conversion.\u000a</p>\u000a\u000a","name":"ColorModelFunc","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ColorModelFunc\">func (ColorModelFunc)</a> <a href=\"?m:ColorModelFunc.Convert!\">Convert</a></h2>\u000a<code>func (f ColorModelFunc) Convert(c Color) Color</code>\u000a\u000a","name":"Convert"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\u000a<pre>type Config struct {\u000a\u0009ColorModel    ColorModel\u000a\u0009Width, Height int\u000a}</pre>\u000a<p>\u000aA Config consists of an image&#39;s color model and dimensions.\u000a</p>\u000a\u000a","name":"Config","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray!\">Gray</a></h2>\u000a<pre>type Gray struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []GrayColor\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aA Gray is an in-memory image of GrayColor values.\u000a</p>\u000a\u000a","name":"Gray","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.At!\">At</a></h2>\u000a<code>func (p *Gray) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Bounds!\">Bounds</a></h2>\u000a<code>func (p *Gray) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *Gray) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Opaque!\">Opaque</a></h2>\u000a<code>func (p *Gray) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Set!\">Set</a></h2>\u000a<code>func (p *Gray) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray16!\">Gray16</a></h2>\u000a<pre>type Gray16 struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []Gray16Color\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aA Gray16 is an in-memory image of Gray16Color values.\u000a</p>\u000a\u000a","name":"Gray16","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.At!\">At</a></h2>\u000a<code>func (p *Gray16) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Bounds!\">Bounds</a></h2>\u000a<code>func (p *Gray16) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *Gray16) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Opaque!\">Opaque</a></h2>\u000a<code>func (p *Gray16) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Set!\">Set</a></h2>\u000a<code>func (p *Gray16) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray16Color!\">Gray16Color</a></h2>\u000a<pre>type Gray16Color struct {\u000a\u0009Y uint16\u000a}</pre>\u000a<p>\u000aA Gray16Color represents a 16-bit grayscale color.\u000a</p>\u000a\u000a","name":"Gray16Color","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Gray16Color\">func (Gray16Color)</a> <a href=\"?m:Gray16Color.RGBA!\">RGBA</a></h2>\u000a<code>func (c Gray16Color) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GrayColor!\">GrayColor</a></h2>\u000a<pre>type GrayColor struct {\u000a\u0009Y uint8\u000a}</pre>\u000a<p>\u000aA GrayColor represents an 8-bit grayscale color.\u000a</p>\u000a\u000a","name":"GrayColor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:GrayColor\">func (GrayColor)</a> <a href=\"?m:GrayColor.RGBA!\">RGBA</a></h2>\u000a<code>func (c GrayColor) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Image!\">Image</a></h2>\u000a<pre>type Image interface {\u000a\u0009// ColorModel returns the Image&#39;s ColorModel.\u000a\u0009ColorModel() ColorModel\u000a\u0009// Bounds returns the domain for which At can return non-zero color.\u000a\u0009// The bounds do not necessarily contain the point (0, 0).\u000a\u0009Bounds() Rectangle\u000a\u0009// At returns the color of the pixel at (x, y).\u000a\u0009// At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\u000a\u0009// At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\u000a\u0009At(x, y int) Color\u000a}</pre>\u000a<p>\u000aAn Image is a finite rectangular grid of Colors drawn from a ColorModel.\u000a</p>\u000a\u000a","name":"Image","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA!\">NRGBA</a></h2>\u000a<pre>type NRGBA struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []NRGBAColor\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn NRGBA is an in-memory image of NRGBAColor values.\u000a</p>\u000a\u000a","name":"NRGBA","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.At!\">At</a></h2>\u000a<code>func (p *NRGBA) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Bounds!\">Bounds</a></h2>\u000a<code>func (p *NRGBA) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *NRGBA) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Opaque!\">Opaque</a></h2>\u000a<code>func (p *NRGBA) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Set!\">Set</a></h2>\u000a<code>func (p *NRGBA) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA64!\">NRGBA64</a></h2>\u000a<pre>type NRGBA64 struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []NRGBA64Color\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn NRGBA64 is an in-memory image of NRGBA64Color values.\u000a</p>\u000a\u000a","name":"NRGBA64","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.At!\">At</a></h2>\u000a<code>func (p *NRGBA64) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Bounds!\">Bounds</a></h2>\u000a<code>func (p *NRGBA64) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *NRGBA64) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Opaque!\">Opaque</a></h2>\u000a<code>func (p *NRGBA64) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Set!\">Set</a></h2>\u000a<code>func (p *NRGBA64) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA64Color!\">NRGBA64Color</a></h2>\u000a<pre>type NRGBA64Color struct {\u000a\u0009R, G, B, A uint16\u000a}</pre>\u000a<p>\u000aAn NRGBA64Color represents a non-alpha-premultiplied 64-bit color,\u000ahaving 16 bits for each of red, green, blue and alpha.\u000a</p>\u000a\u000a","name":"NRGBA64Color","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBA64Color\">func (NRGBA64Color)</a> <a href=\"?m:NRGBA64Color.RGBA!\">RGBA</a></h2>\u000a<code>func (c NRGBA64Color) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBAColor!\">NRGBAColor</a></h2>\u000a<pre>type NRGBAColor struct {\u000a\u0009R, G, B, A uint8\u000a}</pre>\u000a<p>\u000aAn NRGBAColor represents a non-alpha-premultiplied 32-bit color.\u000a</p>\u000a\u000a","name":"NRGBAColor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NRGBAColor\">func (NRGBAColor)</a> <a href=\"?m:NRGBAColor.RGBA!\">RGBA</a></h2>\u000a<code>func (c NRGBAColor) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Paletted!\">Paletted</a></h2>\u000a<pre>type Paletted struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []uint8\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a\u0009// Palette is the image&#39;s palette.\u000a\u0009Palette PalettedColorModel\u000a}</pre>\u000a<p>\u000aA Paletted is an in-memory image backed by a 2-D slice of uint8 values and a PalettedColorModel.\u000a</p>\u000a\u000a","name":"Paletted","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.At!\">At</a></h2>\u000a<code>func (p *Paletted) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.Bounds!\">Bounds</a></h2>\u000a<code>func (p *Paletted) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.ColorIndexAt!\">ColorIndexAt</a></h2>\u000a<code>func (p *Paletted) ColorIndexAt(x, y int) uint8</code>\u000a\u000a","name":"ColorIndexAt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *Paletted) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.Opaque!\">Opaque</a></h2>\u000a<code>func (p *Paletted) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.SetColorIndex!\">SetColorIndex</a></h2>\u000a<code>func (p *Paletted) SetColorIndex(x, y int, index uint8)</code>\u000a\u000a","name":"SetColorIndex"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PalettedColorModel!\">PalettedColorModel</a></h2>\u000a<pre>type PalettedColorModel []Color</pre>\u000a<p>\u000aA PalettedColorModel represents a fixed palette of colors.\u000a</p>\u000a\u000a","name":"PalettedColorModel","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PalettedColorModel\">func (PalettedColorModel)</a> <a href=\"?m:PalettedColorModel.Convert!\">Convert</a></h2>\u000a<code>func (p PalettedColorModel) Convert(c Color) Color</code>\u000a<p>\u000aConvert returns the palette color closest to c in Euclidean R,G,B space.\u000a</p>\u000a\u000a","name":"Convert"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Point!\">Point</a></h2>\u000a<pre>type Point struct {\u000a\u0009X, Y int\u000a}</pre>\u000a<p>\u000aA Point is an X, Y coordinate pair. The axes increase right and down.\u000a</p>\u000a\u000a","name":"Point","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Add!\">Add</a></h2>\u000a<code>func (p Point) Add(q Point) Point</code>\u000a<p>\u000aAdd returns the vector p+q.\u000a</p>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Div!\">Div</a></h2>\u000a<code>func (p Point) Div(k int) Point</code>\u000a<p>\u000aDiv returns the vector p/k.\u000a</p>\u000a\u000a","name":"Div"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Eq!\">Eq</a></h2>\u000a<code>func (p Point) Eq(q Point) bool</code>\u000a<p>\u000aEq returns whether p and q are equal.\u000a</p>\u000a\u000a","name":"Eq"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Mod!\">Mod</a></h2>\u000a<code>func (p Point) Mod(r Rectangle) Point</code>\u000a<p>\u000aMod returns the point q in r such that p.X-q.X is a multiple of r&#39;s width\u000aand p.Y-q.Y is a multiple of r&#39;s height.\u000a</p>\u000a\u000a","name":"Mod"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Mul!\">Mul</a></h2>\u000a<code>func (p Point) Mul(k int) Point</code>\u000a<p>\u000aMul returns the vector p*k.\u000a</p>\u000a\u000a","name":"Mul"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.String!\">String</a></h2>\u000a<code>func (p Point) String() string</code>\u000a<p>\u000aString returns a string representation of p like &#34;(3,4)&#34;.\u000a</p>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Sub!\">Sub</a></h2>\u000a<code>func (p Point) Sub(q Point) Point</code>\u000a<p>\u000aSub returns the vector p-q.\u000a</p>\u000a\u000a","name":"Sub"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA!\">RGBA</a></h2>\u000a<pre>type RGBA struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []RGBAColor\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn RGBA is an in-memory image of RGBAColor values.\u000a</p>\u000a\u000a","name":"RGBA","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.At!\">At</a></h2>\u000a<code>func (p *RGBA) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Bounds!\">Bounds</a></h2>\u000a<code>func (p *RGBA) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *RGBA) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Opaque!\">Opaque</a></h2>\u000a<code>func (p *RGBA) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Set!\">Set</a></h2>\u000a<code>func (p *RGBA) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA64!\">RGBA64</a></h2>\u000a<pre>type RGBA64 struct {\u000a\u0009// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\u000a\u0009Pix    []RGBA64Color\u000a\u0009Stride int\u000a\u0009// Rect is the image&#39;s bounds.\u000a\u0009Rect Rectangle\u000a}</pre>\u000a<p>\u000aAn RGBA64 is an in-memory image of RGBA64Color values.\u000a</p>\u000a\u000a","name":"RGBA64","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.At!\">At</a></h2>\u000a<code>func (p *RGBA64) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Bounds!\">Bounds</a></h2>\u000a<code>func (p *RGBA64) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.ColorModel!\">ColorModel</a></h2>\u000a<code>func (p *RGBA64) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Opaque!\">Opaque</a></h2>\u000a<code>func (p *RGBA64) Opaque() bool</code>\u000a<p>\u000aOpaque scans the entire image and returns whether or not it is fully opaque.\u000a</p>\u000a\u000a","name":"Opaque"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Set!\">Set</a></h2>\u000a<code>func (p *RGBA64) Set(x, y int, c Color)</code>\u000a\u000a","name":"Set"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA64Color!\">RGBA64Color</a></h2>\u000a<pre>type RGBA64Color struct {\u000a\u0009R, G, B, A uint16\u000a}</pre>\u000a<p>\u000aAn RGBA64Color represents a 64-bit alpha-premultiplied color,\u000ahaving 16 bits for each of red, green, blue and alpha.\u000a</p>\u000a\u000a","name":"RGBA64Color","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBA64Color\">func (RGBA64Color)</a> <a href=\"?m:RGBA64Color.RGBA!\">RGBA</a></h2>\u000a<code>func (c RGBA64Color) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBAColor!\">RGBAColor</a></h2>\u000a<pre>type RGBAColor struct {\u000a\u0009R, G, B, A uint8\u000a}</pre>\u000a<p>\u000aAn RGBAColor represents a traditional 32-bit alpha-premultiplied color,\u000ahaving 8 bits for each of red, green, blue and alpha.\u000a</p>\u000a\u000a","name":"RGBAColor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RGBAColor\">func (RGBAColor)</a> <a href=\"?m:RGBAColor.RGBA!\">RGBA</a></h2>\u000a<code>func (c RGBAColor) RGBA() (r, g, b, a uint32)</code>\u000a\u000a","name":"RGBA"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Rectangle!\">Rectangle</a></h2>\u000a<pre>type Rectangle struct {\u000a\u0009Min, Max Point\u000a}</pre>\u000a<p>\u000aA Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y.\u000aIt is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always\u000awell-formed. A rectangle&#39;s methods always return well-formed outputs for\u000awell-formed inputs.\u000a</p>\u000a\u000a","name":"Rectangle","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Add!\">Add</a></h2>\u000a<code>func (r Rectangle) Add(p Point) Rectangle</code>\u000a<p>\u000aAdd returns the rectangle r translated by p.\u000a</p>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Canon!\">Canon</a></h2>\u000a<code>func (r Rectangle) Canon() Rectangle</code>\u000a<p>\u000aCanon returns the canonical version of r. The returned rectangle has minimum\u000aand maximum coordinates swapped if necessary so that it is well-formed.\u000a</p>\u000a\u000a","name":"Canon"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Contains!\">Contains</a></h2>\u000a<code>func (r Rectangle) Contains(p Point) bool</code>\u000a<p>\u000aContains returns whether r contains p.\u000a</p>\u000a\u000a","name":"Contains"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Dx!\">Dx</a></h2>\u000a<code>func (r Rectangle) Dx() int</code>\u000a<p>\u000aDx returns r&#39;s width.\u000a</p>\u000a\u000a","name":"Dx"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Dy!\">Dy</a></h2>\u000a<code>func (r Rectangle) Dy() int</code>\u000a<p>\u000aDy returns r&#39;s height.\u000a</p>\u000a\u000a","name":"Dy"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Empty!\">Empty</a></h2>\u000a<code>func (r Rectangle) Empty() bool</code>\u000a<p>\u000aEmpty returns whether the rectangle contains no points.\u000a</p>\u000a\u000a","name":"Empty"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Eq!\">Eq</a></h2>\u000a<code>func (r Rectangle) Eq(s Rectangle) bool</code>\u000a<p>\u000aEq returns whether r and s are equal.\u000a</p>\u000a\u000a","name":"Eq"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Inset!\">Inset</a></h2>\u000a<code>func (r Rectangle) Inset(n int) Rectangle</code>\u000a<p>\u000aInset returns the rectangle r inset by n, which may be negative. If either\u000aof r&#39;s dimensions is less than 2*n then an empty rectangle near the center\u000aof r will be returned.\u000a</p>\u000a\u000a","name":"Inset"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Intersect!\">Intersect</a></h2>\u000a<code>func (r Rectangle) Intersect(s Rectangle) Rectangle</code>\u000a<p>\u000aIntersect returns the largest rectangle contained by both r and s. If the\u000atwo rectangles do not overlap then the zero rectangle will be returned.\u000a</p>\u000a\u000a","name":"Intersect"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Overlaps!\">Overlaps</a></h2>\u000a<code>func (r Rectangle) Overlaps(s Rectangle) bool</code>\u000a<p>\u000aOverlaps returns whether r and s have a non-empty intersection.\u000a</p>\u000a\u000a","name":"Overlaps"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Size!\">Size</a></h2>\u000a<code>func (r Rectangle) Size() Point</code>\u000a<p>\u000aSize returns r&#39;s width and height.\u000a</p>\u000a\u000a","name":"Size"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.String!\">String</a></h2>\u000a<code>func (r Rectangle) String() string</code>\u000a<p>\u000aString returns a string representation of r like &#34;(3,4)-(6,5)&#34;.\u000a</p>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Sub!\">Sub</a></h2>\u000a<code>func (r Rectangle) Sub(p Point) Rectangle</code>\u000a<p>\u000aAdd returns the rectangle r translated by -p.\u000a</p>\u000a\u000a","name":"Sub"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Union!\">Union</a></h2>\u000a<code>func (r Rectangle) Union(s Rectangle) Rectangle</code>\u000a<p>\u000aUnion returns the smallest rectangle that contains both r and s.\u000a</p>\u000a\u000a","name":"Union"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Tiled!\">Tiled</a></h2>\u000a<pre>type Tiled struct {\u000a\u0009I      Image\u000a\u0009Offset Point\u000a}</pre>\u000a<p>\u000aA Tiled is an infinite-sized Image that repeats another Image in both\u000adirections. Tiled{i, p}.At(x, y) will equal i.At(x+p.X, y+p.Y) for all\u000apoints {x+p.X, y+p.Y} within i&#39;s Bounds.\u000a</p>\u000a\u000a","name":"Tiled","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.At!\">At</a></h2>\u000a<code>func (t *Tiled) At(x, y int) Color</code>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.Bounds!\">Bounds</a></h2>\u000a<code>func (t *Tiled) Bounds() Rectangle</code>\u000a\u000a","name":"Bounds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.ColorModel!\">ColorModel</a></h2>\u000a<code>func (t *Tiled) ColorModel() ColorModel</code>\u000a\u000a","name":"ColorModel"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Decode!\">Decode</a></h2>\u000a<code>func Decode(r io.Reader) (Image, string, os.Error)</code>\u000a<p>\u000aDecode decodes an image that has been encoded in a registered format.\u000aThe string returned is the format name used during format registration.\u000aFormat registration is typically done by the init method of the codec-\u000aspecific package.\u000a</p>\u000a\u000a","name":"Decode"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeConfig!\">DecodeConfig</a></h2>\u000a<code>func DecodeConfig(r io.Reader) (Config, string, os.Error)</code>\u000a<p>\u000aDecodeConfig decodes the color model and dimensions of an image that has\u000abeen encoded in a registered format. The string returned is the format name\u000aused during format registration. Format registration is typically done by\u000athe init method of the codec-specific package.\u000a</p>\u000a\u000a","name":"DecodeConfig"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewAlpha!\">NewAlpha</a></h2>\u000a<code>func NewAlpha(w, h int) *Alpha</code>\u000a<p>\u000aNewAlpha returns a new Alpha with the given width and height.\u000a</p>\u000a\u000a","name":"NewAlpha"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewAlpha16!\">NewAlpha16</a></h2>\u000a<code>func NewAlpha16(w, h int) *Alpha16</code>\u000a<p>\u000aNewAlpha16 returns a new Alpha16 with the given width and height.\u000a</p>\u000a\u000a","name":"NewAlpha16"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewColorImage!\">NewColorImage</a></h2>\u000a<code>func NewColorImage(c Color) *ColorImage</code>\u000a\u000a","name":"NewColorImage"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewGray!\">NewGray</a></h2>\u000a<code>func NewGray(w, h int) *Gray</code>\u000a<p>\u000aNewGray returns a new Gray with the given width and height.\u000a</p>\u000a\u000a","name":"NewGray"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewGray16!\">NewGray16</a></h2>\u000a<code>func NewGray16(w, h int) *Gray16</code>\u000a<p>\u000aNewGray16 returns a new Gray16 with the given width and height.\u000a</p>\u000a\u000a","name":"NewGray16"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewNRGBA!\">NewNRGBA</a></h2>\u000a<code>func NewNRGBA(w, h int) *NRGBA</code>\u000a<p>\u000aNewNRGBA returns a new NRGBA with the given width and height.\u000a</p>\u000a\u000a","name":"NewNRGBA"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewNRGBA64!\">NewNRGBA64</a></h2>\u000a<code>func NewNRGBA64(w, h int) *NRGBA64</code>\u000a<p>\u000aNewNRGBA64 returns a new NRGBA64 with the given width and height.\u000a</p>\u000a\u000a","name":"NewNRGBA64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewPaletted!\">NewPaletted</a></h2>\u000a<code>func NewPaletted(w, h int, m PalettedColorModel) *Paletted</code>\u000a<p>\u000aNewPaletted returns a new Paletted with the given width, height and palette.\u000a</p>\u000a\u000a","name":"NewPaletted"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRGBA!\">NewRGBA</a></h2>\u000a<code>func NewRGBA(w, h int) *RGBA</code>\u000a<p>\u000aNewRGBA returns a new RGBA with the given width and height.\u000a</p>\u000a\u000a","name":"NewRGBA"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRGBA64!\">NewRGBA64</a></h2>\u000a<code>func NewRGBA64(w, h int) *RGBA64</code>\u000a<p>\u000aNewRGBA64 returns a new RGBA64 with the given width and height.\u000a</p>\u000a\u000a","name":"NewRGBA64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewTiled!\">NewTiled</a></h2>\u000a<code>func NewTiled(i Image, offset Point) *Tiled</code>\u000a\u000a","name":"NewTiled"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pt!\">Pt</a></h2>\u000a<code>func Pt(X, Y int) Point</code>\u000a<p>\u000aPt is shorthand for Point{X, Y}.\u000a</p>\u000a\u000a","name":"Pt"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Rect!\">Rect</a></h2>\u000a<code>func Rect(x0, y0, x1, y1 int) Rectangle</code>\u000a<p>\u000aRect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}.\u000a</p>\u000a\u000a","name":"Rect"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RegisterFormat!\">RegisterFormat</a></h2>\u000a<code>func RegisterFormat(name, magic string, decode func(io.Reader) (Image, os.Error), decodeConfig func(io.Reader) (Config, os.Error))</code>\u000a<p>\u000aRegisterFormat registers an image format for use by Decode.\u000aName is the name of the format, like &#34;jpeg&#34; or &#34;png&#34;.\u000aMagic is the magic prefix that identifies the format&#39;s encoding.\u000aDecode is the function that decodes the encoded image.\u000aDecodeConfig is the function that decodes just its configuration.\u000a</p>\u000a\u000a","name":"RegisterFormat"}],"consts":[],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:RGBAColorModel!\">RGBAColorModel</a></h2>\u000a<pre>var RGBAColorModel ColorModel = ColorModelFunc(toRGBAColor)</pre>\u000a<p>\u000aThe ColorModel associated with RGBAColor.\u000a</p>\u000a\u000a","names":["RGBAColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:RGBA64ColorModel!\">RGBA64ColorModel</a></h2>\u000a<pre>var RGBA64ColorModel ColorModel = ColorModelFunc(toRGBA64Color)</pre>\u000a<p>\u000aThe ColorModel associated with RGBA64Color.\u000a</p>\u000a\u000a","names":["RGBA64ColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:NRGBAColorModel!\">NRGBAColorModel</a></h2>\u000a<pre>var NRGBAColorModel ColorModel = ColorModelFunc(toNRGBAColor)</pre>\u000a<p>\u000aThe ColorModel associated with NRGBAColor.\u000a</p>\u000a\u000a","names":["NRGBAColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:NRGBA64ColorModel!\">NRGBA64ColorModel</a></h2>\u000a<pre>var NRGBA64ColorModel ColorModel = ColorModelFunc(toNRGBA64Color)</pre>\u000a<p>\u000aThe ColorModel associated with NRGBA64Color.\u000a</p>\u000a\u000a","names":["NRGBA64ColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:AlphaColorModel!\">AlphaColorModel</a></h2>\u000a<pre>var AlphaColorModel ColorModel = ColorModelFunc(toAlphaColor)</pre>\u000a<p>\u000aThe ColorModel associated with AlphaColor.\u000a</p>\u000a\u000a","names":["AlphaColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Alpha16ColorModel!\">Alpha16ColorModel</a></h2>\u000a<pre>var Alpha16ColorModel ColorModel = ColorModelFunc(toAlpha16Color)</pre>\u000a<p>\u000aThe ColorModel associated with Alpha16Color.\u000a</p>\u000a\u000a","names":["Alpha16ColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:GrayColorModel!\">GrayColorModel</a></h2>\u000a<pre>var GrayColorModel ColorModel = ColorModelFunc(toGrayColor)</pre>\u000a<p>\u000aThe ColorModel associated with GrayColor.\u000a</p>\u000a\u000a","names":["GrayColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Gray16ColorModel!\">Gray16ColorModel</a></h2>\u000a<pre>var Gray16ColorModel ColorModel = ColorModelFunc(toGray16Color)</pre>\u000a<p>\u000aThe ColorModel associated with Gray16Color.\u000a</p>\u000a\u000a","names":["Gray16ColorModel"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:UnknownFormatErr!\">UnknownFormatErr</a></h2>\u000a<pre>var UnknownFormatErr = os.NewError(&#34;image: unknown format&#34;)</pre>\u000a<p>\u000aAn UnknownFormatErr indicates that decoding encountered an unknown format.\u000a</p>\u000a\u000a","names":["UnknownFormatErr"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Black!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009// Black is an opaque black ColorImage.\u000a\u0009Black = NewColorImage(Gray16Color{0})\u000a\u0009// White is an opaque white ColorImage.\u000a\u0009White = NewColorImage(Gray16Color{0xffff})\u000a\u0009// Transparent is a fully transparent ColorImage.\u000a\u0009Transparent = NewColorImage(Alpha16Color{0})\u000a\u0009// Opaque is a fully opaque ColorImage.\u000a\u0009Opaque = NewColorImage(Alpha16Color{0xffff})\u000a)</pre>\u000a\u000a","names":["Black","White","Transparent","Opaque"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ZP!\">ZP</a></h2>\u000a<pre>var ZP Point</pre>\u000a<p>\u000aZP is the zero Point.\u000a</p>\u000a\u000a","names":["ZP"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ZR!\">ZR</a></h2>\u000a<pre>var ZR Rectangle</pre>\u000a<p>\u000aZR is the zero Rectangle.\u000a</p>\u000a\u000a","names":["ZR"],"type":""}]}