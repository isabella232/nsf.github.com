var gowtfData = {"index":"index.html","html":"<p>\u000aThe time package provides functionality for measuring and\u000adisplaying time.\u000a</p>\u000a","name":"time","filenames":["/home/nsf/go/src/pkg/time/time.go","/home/nsf/go/src/pkg/time/sleep.go","/home/nsf/go/src/pkg/time/format.go","/home/nsf/go/src/pkg/time/tick.go","/home/nsf/go/src/pkg/time/zoneinfo_unix.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ParseError!\">ParseError</a></h2>\u000a<pre>type ParseError struct {\u000a\u0009Layout     string\u000a\u0009Value      string\u000a\u0009LayoutElem string\u000a\u0009ValueElem  string\u000a\u0009Message    string\u000a}</pre>\u000a<p>\u000aParseError describes a problem parsing a time string.\u000a</p>\u000a\u000a","name":"ParseError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ParseError\">func (*ParseError)</a> <a href=\"?m:ParseError.String!\">String</a></h2>\u000a<code>func (e *ParseError) String() string</code>\u000a<p>\u000aString is the string representation of a ParseError.\u000a</p>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Ticker!\">Ticker</a></h2>\u000a<pre>type Ticker struct {\u000a\u0009C &lt;-chan int64 // The channel on which the ticks are delivered.\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Ticker holds a synchronous channel that delivers `ticks&#39; of a clock\u000aat intervals.\u000a</p>\u000a\u000a","name":"Ticker","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Ticker\">func (*Ticker)</a> <a href=\"?m:Ticker.Stop!\">Stop</a></h2>\u000a<code>func (t *Ticker) Stop()</code>\u000a<p>\u000aStop turns off a ticker.  After Stop, no more ticks will be sent.\u000a</p>\u000a\u000a","name":"Stop"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Time!\">Time</a></h2>\u000a<pre>type Time struct {\u000a\u0009Year                 int64  // 2006 is 2006\u000a\u0009Month, Day           int    // Jan-2 is 1, 2\u000a\u0009Hour, Minute, Second int    // 15:04:05 is 15, 4, 5.\u000a\u0009Weekday              int    // Sunday, Monday, ...\u000a\u0009ZoneOffset           int    // seconds east of UTC, e.g. -7*60 for -0700\u000a\u0009Zone                 string // e.g., &#34;MST&#34;\u000a}</pre>\u000a<p>\u000aTime is the struct representing a parsed time value.\u000a</p>\u000a\u000a","name":"Time","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Time\">func (*Time)</a> <a href=\"?m:Time.Format!\">Format</a></h2>\u000a<code>func (t *Time) Format(layout string) string</code>\u000a<p>\u000aFormat returns a textual representation of the time value formatted\u000aaccording to layout.  The layout defines the format by showing the\u000arepresentation of a standard time, which is then used to describe\u000athe time to be formatted.  Predefined layouts ANSIC, UnixDate,\u000aRFC3339 and others describe standard representations.\u000a</p>\u000a\u000a","name":"Format"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Time\">func (*Time)</a> <a href=\"?m:Time.Seconds!\">Seconds</a></h2>\u000a<code>func (t *Time) Seconds() int64</code>\u000a<p>\u000aSeconds returns the number of seconds since January 1, 1970 represented by the\u000aparsed Time value.\u000a</p>\u000a\u000a","name":"Seconds"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Time\">func (*Time)</a> <a href=\"?m:Time.String!\">String</a></h2>\u000a<code>func (t *Time) String() string</code>\u000a<p>\u000aString returns a Unix-style representation of the time value.\u000a</p>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:After!\">After</a></h2>\u000a<code>func After(ns int64) &lt;-chan int64</code>\u000a<p>\u000aAfter waits at least ns nanoseconds before sending the current time\u000aon the returned channel.\u000a</p>\u000a\u000a","name":"After"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LocalTime!\">LocalTime</a></h2>\u000a<code>func LocalTime() *Time</code>\u000a<p>\u000aLocalTime returns the current time as a parsed Time value in the local time zone.\u000a</p>\u000a\u000a","name":"LocalTime"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Nanoseconds!\">Nanoseconds</a></h2>\u000a<code>func Nanoseconds() int64</code>\u000a<p>\u000aNanoseconds reports the number of nanoseconds since the Unix epoch,\u000aJanuary 1, 1970 00:00:00 UTC.\u000a</p>\u000a\u000a","name":"Nanoseconds"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewTicker!\">NewTicker</a></h2>\u000a<code>func NewTicker(ns int64) *Ticker</code>\u000a<p>\u000aNewTicker returns a new Ticker containing a channel that will\u000asend the time, in nanoseconds, every ns nanoseconds.  It adjusts the\u000aintervals to make up for pauses in delivery of the ticks.\u000a</p>\u000a\u000a","name":"NewTicker"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\u000a<code>func Parse(alayout, avalue string) (*Time, os.Error)</code>\u000a<p>\u000aParse parses a formatted string and returns the time value it represents.\u000aThe layout defines the format by showing the representation of a standard\u000atime, which is then used to describe the string to be parsed.  Predefined\u000alayouts ANSIC, UnixDate, RFC3339 and others describe standard\u000arepresentations.\u000a</p>\u000a<p>\u000aOnly those elements present in the value will be set in the returned time\u000astructure.  Also, if the input string represents an inconsistent time\u000a(such as having the wrong day of the week), the returned value will also\u000abe inconsistent.  In any case, the elements of the returned time will be\u000asane: hours in 0..23, minutes in 0..59, day of month in 0..31, etc.\u000aYears must be in the range 0000..9999.\u000a</p>\u000a\u000a","name":"Parse"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Seconds!\">Seconds</a></h2>\u000a<code>func Seconds() int64</code>\u000a<p>\u000aSeconds reports the number of seconds since the Unix epoch,\u000aJanuary 1, 1970 00:00:00 UTC.\u000a</p>\u000a\u000a","name":"Seconds"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SecondsToLocalTime!\">SecondsToLocalTime</a></h2>\u000a<code>func SecondsToLocalTime(sec int64) *Time</code>\u000a<p>\u000aSecondsToLocalTime converts sec, in number of seconds since the Unix epoch,\u000ainto a parsed Time value in the local time zone.\u000a</p>\u000a\u000a","name":"SecondsToLocalTime"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SecondsToUTC!\">SecondsToUTC</a></h2>\u000a<code>func SecondsToUTC(sec int64) *Time</code>\u000a<p>\u000aSecondsToUTC converts sec, in number of seconds since the Unix epoch,\u000ainto a parsed Time value in the UTC time zone.\u000a</p>\u000a\u000a","name":"SecondsToUTC"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sleep!\">Sleep</a></h2>\u000a<code>func Sleep(ns int64) os.Error</code>\u000a<p>\u000aSleep pauses the current goroutine for at least ns nanoseconds.\u000aHigher resolution sleeping may be provided by syscall.Nanosleep\u000aon some operating systems.\u000a</p>\u000a\u000a","name":"Sleep"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Tick!\">Tick</a></h2>\u000a<code>func Tick(ns int64) &lt;-chan int64</code>\u000a<p>\u000aTick is a convenience wrapper for NewTicker providing access to the ticking\u000achannel only.  Useful for clients that have no need to shut down the ticker.\u000a</p>\u000a\u000a","name":"Tick"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UTC!\">UTC</a></h2>\u000a<code>func UTC() *Time</code>\u000a<p>\u000aUTC returns the current time as a parsed Time value in the UTC time zone.\u000a</p>\u000a\u000a","name":"UTC"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Sunday!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009Sunday = iota\u000a\u0009Monday\u000a\u0009Tuesday\u000a\u0009Wednesday\u000a\u0009Thursday\u000a\u0009Friday\u000a\u0009Saturday\u000a)</pre>\u000a<p>\u000aDays of the week.\u000a</p>\u000a\u000a","names":["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ANSIC!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009ANSIC    = &#34;Mon Jan _2 15:04:05 2006&#34;\u000a\u0009UnixDate = &#34;Mon Jan _2 15:04:05 MST 2006&#34;\u000a\u0009RubyDate = &#34;Mon Jan 02 15:04:05 -0700 2006&#34;\u000a\u0009RFC822   = &#34;02 Jan 06 1504 MST&#34;\u000a\u0009// RFC822 with Zulu time.\u000a\u0009RFC822Z = &#34;02 Jan 06 1504 -0700&#34;\u000a\u0009RFC850  = &#34;Monday, 02-Jan-06 15:04:05 MST&#34;\u000a\u0009RFC1123 = &#34;Mon, 02 Jan 2006 15:04:05 MST&#34;\u000a\u0009Kitchen = &#34;3:04PM&#34;\u000a\u0009RFC3339 = &#34;2006-01-02T15:04:05Z07:00&#34;\u000a)</pre>\u000a<p>\u000aThese are predefined layouts for use in Time.Format.\u000aThe standard time used in the layouts is:\u000a</p>\u000a<pre>Mon Jan 2 15:04:05 MST 2006  (MST is GMT-0700)\u000a</pre>\u000a<p>\u000awhich is Unix time 1136243045.\u000a(Think of it as 01/02 03:04:05PM &#39;06 -0700.)\u000aAn underscore _ represents a space that\u000amay be replaced by a digit if the following number\u000a(a day) has two digits; for compatibility with\u000afixed-width Unix time formats.\u000a</p>\u000a<p>\u000aNumeric time zone offsets format as follows:\u000a</p>\u000a<pre>-0700  ±hhmm\u000a-07:00 ±hh:mm\u000a</pre>\u000a<p>\u000aReplacing the sign in the format with a Z triggers\u000athe ISO 8601 behavior of printing Z instead of an\u000aoffset for the UTC zone.  Thus:\u000a</p>\u000a<pre>Z0700  Z or ±hhmm\u000aZ07:00 Z or ±hh:mm\u000a</pre>\u000a\u000a","names":["ANSIC","UnixDate","RubyDate","RFC822","RFC822Z","RFC850","RFC1123","Kitchen","RFC3339"],"type":""}],"vars":[]}