var gowtfData = {"index":"index.html","html":"<p>\u000aThe flate package implements the DEFLATE compressed data\u000aformat, described in RFC 1951.  The gzip and zlib packages\u000aimplement access to DEFLATE-based file formats.\u000a</p>\u000a","name":"flate","filenames":["/home/nsf/go/src/pkg/compress/flate/inflate.go","/home/nsf/go/src/pkg/compress/flate/deflate.go","/home/nsf/go/src/pkg/compress/flate/huffman_code.go","/home/nsf/go/src/pkg/compress/flate/token.go","/home/nsf/go/src/pkg/compress/flate/util.go","/home/nsf/go/src/pkg/compress/flate/huffman_bit_writer.go","/home/nsf/go/src/pkg/compress/flate/reverse_bits.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CorruptInputError!\">CorruptInputError</a></h2>\u000a<pre>type CorruptInputError int64</pre>\u000a<p>\u000aA CorruptInputError reports the presence of corrupt input at a given offset.\u000a</p>\u000a\u000a","name":"CorruptInputError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CorruptInputError\">func (CorruptInputError)</a> <a href=\"?m:CorruptInputError.String!\">String</a></h2>\u000a<code>func (e CorruptInputError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InternalError!\">InternalError</a></h2>\u000a<pre>type InternalError string</pre>\u000a<p>\u000aAn InternalError reports an error in the flate code itself.\u000a</p>\u000a\u000a","name":"InternalError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InternalError\">func (InternalError)</a> <a href=\"?m:InternalError.String!\">String</a></h2>\u000a<code>func (e InternalError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadError!\">ReadError</a></h2>\u000a<pre>type ReadError struct {\u000a\u0009Offset int64    // byte offset where error occurred\u000a\u0009Error  os.Error // error returned by underlying Read\u000a}</pre>\u000a<p>\u000aA ReadError reports an error encountered while reading input.\u000a</p>\u000a\u000a","name":"ReadError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ReadError\">func (*ReadError)</a> <a href=\"?m:ReadError.String!\">String</a></h2>\u000a<code>func (e *ReadError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\u000a<pre>type Reader interface {\u000a\u0009io.Reader\u000a\u0009ReadByte() (c byte, err os.Error)\u000a}</pre>\u000a<p>\u000aThe actual read interface needed by NewReader.\u000aIf the passed in io.Reader does not also have ReadByte,\u000athe NewReader will introduce its own buffering.\u000a</p>\u000a\u000a","name":"Reader","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteError!\">WriteError</a></h2>\u000a<pre>type WriteError struct {\u000a\u0009Offset int64    // byte offset where error occurred\u000a\u0009Error  os.Error // error returned by underlying Read\u000a}</pre>\u000a<p>\u000aA WriteError reports an error encountered while writing output.\u000a</p>\u000a\u000a","name":"WriteError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:WriteError\">func (*WriteError)</a> <a href=\"?m:WriteError.String!\">String</a></h2>\u000a<code>func (e *WriteError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WrongValueError!\">WrongValueError</a></h2>\u000a<pre>type WrongValueError struct {\u000a\u0009name  string\u000a\u0009from  int32\u000a\u0009to    int32\u000a\u0009value int32\u000a}</pre>\u000a\u000a","name":"WrongValueError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:WrongValueError\">func (WrongValueError)</a> <a href=\"?m:WrongValueError.String!\">String</a></h2>\u000a<code>func (err WrongValueError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\u000a<code>func NewReader(r io.Reader) io.ReadCloser</code>\u000a<p>\u000aNewReader returns a new ReadCloser that can be used\u000ato read the uncompressed version of r.  It is the caller&#39;s\u000aresponsibility to call Close on the ReadCloser when\u000afinished reading.\u000a</p>\u000a\u000a","name":"NewReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(w io.Writer, level int) io.WriteCloser</code>\u000a\u000a","name":"NewWriter"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:NoCompression!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009NoCompression        = 0\u000a\u0009BestSpeed            = 1\u000a\u0009fastCompression      = 3\u000a\u0009BestCompression      = 9\u000a\u0009DefaultCompression   = -1\u000a\u0009logMaxOffsetSize     = 15  // Standard DEFLATE\u000a\u0009wideLogMaxOffsetSize = 22  // Wide DEFLATE\u000a\u0009minMatchLength       = 3   // The smallest match that the compressor looks for\u000a\u0009maxMatchLength       = 258 // The longest match for the compressor\u000a\u0009minOffsetSize        = 1   // The shortest offset that makes any sence\u000a\u000a\u000a\u0009// The maximum number of tokens we put into a single flat block, just too\u000a\u0009// stop things from getting too large.\u000a\u0009maxFlateBlockTokens = 1 &lt;&lt; 14\u000a\u0009maxStoreBlockSize   = 65535\u000a\u0009hashBits            = 15\u000a\u0009hashSize            = 1 &lt;&lt; hashBits\u000a\u0009hashMask            = (1 &lt;&lt; hashBits) - 1\u000a\u0009hashShift           = (hashBits + minMatchLength - 1) / minMatchLength\u000a)</pre>\u000a\u000a","names":["NoCompression","BestSpeed","BestCompression","DefaultCompression"],"type":""}],"vars":[]}