var gowtfData = {"html":"<p>\u000aThe exec package runs external commands.\u000a</p>\u000a","name":"exec","filenames":["/home/nsf/go/src/pkg/exec/lp_unix.go","/home/nsf/go/src/pkg/exec/exec.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cmd!\">Cmd</a></h2>\u000a<pre>type Cmd struct {\u000a\u0009Stdin  *os.File\u000a\u0009Stdout *os.File\u000a\u0009Stderr *os.File\u000a\u0009Pid    int\u000a}</pre>\u000a<p>\u000aA Cmd represents a running command.\u000aStdin, Stdout, and Stderr are Files representing pipes\u000aconnected to the running command&#39;s standard input, output, and error,\u000aor else nil, depending on the arguments to Run.\u000aPid is the running command&#39;s operating system process ID.\u000a</p>\u000a\u000a","name":"Cmd","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Cmd\">func (*Cmd)</a> <a href=\"?m:Cmd.Close!\">Close</a></h2>\u000a<code>func (p *Cmd) Close() os.Error</code>\u000a<p>\u000aClose waits for the running command p to exit,\u000aif it hasn&#39;t already, and then closes the non-nil file descriptors\u000ap.Stdin, p.Stdout, and p.Stderr.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Cmd\">func (*Cmd)</a> <a href=\"?m:Cmd.Wait!\">Wait</a></h2>\u000a<code>func (p *Cmd) Wait(options int) (*os.Waitmsg, os.Error)</code>\u000a<p>\u000aWait waits for the running command p,\u000areturning the Waitmsg returned by os.Wait and an error.\u000aThe options are passed through to os.Wait.\u000aSetting options to 0 waits for p to exit;\u000aother options cause Wait to return for other\u000aprocess events; see package os for details.\u000a</p>\u000a\u000a","name":"Wait"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookPath!\">LookPath</a></h2>\u000a<code>func LookPath(file string) (string, os.Error)</code>\u000a<p>\u000aLookPath searches for an executable binary named file\u000ain the directories named by the PATH environment variable.\u000aIf file contains a slash, it is tried directly and the PATH is not consulted.\u000a</p>\u000a\u000a","name":"LookPath"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Run!\">Run</a></h2>\u000a<code>func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int) (p *Cmd, err os.Error)</code>\u000a<p>\u000aRun starts the named binary running with\u000aarguments argv and environment envv.\u000aIt returns a pointer to a new Cmd representing\u000athe command or an error.\u000a</p>\u000a<p>\u000aThe parameters stdin, stdout, and stderr\u000aspecify how to handle standard input, output, and error.\u000aThe choices are DevNull (connect to /dev/null),\u000aPassThrough (connect to the current process&#39;s standard stream),\u000aPipe (connect to an operating system pipe), and\u000aMergeWithStdout (only for standard error; use the same\u000afile descriptor as was used for standard output).\u000aIf a parameter is Pipe, then the corresponding field (Stdin, Stdout, Stderr)\u000aof the returned Cmd is the other end of the pipe.\u000aOtherwise the field in Cmd is nil.\u000a</p>\u000a\u000a","name":"Run"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DevNull!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009DevNull = iota\u000a\u0009PassThrough\u000a\u0009Pipe\u000a\u0009MergeWithStdout\u000a)</pre>\u000a<p>\u000aArguments to Run.\u000a</p>\u000a\u000a","names":["DevNull","PassThrough","Pipe","MergeWithStdout"],"type":""}],"vars":[]}