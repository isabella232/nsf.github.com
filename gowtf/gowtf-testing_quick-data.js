var gowtfData = {"index":"index.html","html":"<p>\u000aThis package implements utility functions to help with black box testing.\u000a</p>\u000a","name":"quick","filenames":["/home/nsf/go/src/pkg/testing/quick/quick.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CheckEqualError!\">CheckEqualError</a></h2>\u000a<pre>type CheckEqualError struct {\u000a\u0009CheckError\u000a\u0009Out1 []interface{}\u000a\u0009Out2 []interface{}\u000a}</pre>\u000a<p>\u000aA CheckEqualError is the result CheckEqual finding an error.\u000a</p>\u000a\u000a","name":"CheckEqualError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CheckEqualError\">func (*CheckEqualError)</a> <a href=\"?m:CheckEqualError.String!\">String</a></h2>\u000a<code>func (s *CheckEqualError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CheckError!\">CheckError</a></h2>\u000a<pre>type CheckError struct {\u000a\u0009Count int\u000a\u0009In    []interface{}\u000a}</pre>\u000a<p>\u000aA CheckError is the result of Check finding an error.\u000a</p>\u000a\u000a","name":"CheckError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CheckError\">func (*CheckError)</a> <a href=\"?m:CheckError.String!\">String</a></h2>\u000a<code>func (s *CheckError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\u000a<pre>type Config struct {\u000a\u0009// MaxCount sets the maximum number of iterations. If zero,\u000a\u0009// MaxCountScale is used.\u000a\u0009MaxCount int\u000a\u0009// MaxCountScale is a non-negative scale factor applied to the default\u000a\u0009// maximum. If zero, the default is unchanged.\u000a\u0009MaxCountScale float\u000a\u0009// If non-nil, rand is a source of random numbers. Otherwise a default\u000a\u0009// pseudo-random source will be used.\u000a\u0009Rand *rand.Rand\u000a\u0009// If non-nil, Values is a function which generates a slice of arbitrary\u000a\u0009// Values that are congruent with the arguments to the function being\u000a\u0009// tested. Otherwise, Values is used to generate the values.\u000a\u0009Values func([]reflect.Value, *rand.Rand)\u000a}</pre>\u000a<p>\u000aA Config structure contains options for running a test.\u000a</p>\u000a\u000a","name":"Config","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Generator!\">Generator</a></h2>\u000a<pre>type Generator interface {\u000a\u0009// Generate returns a random instance of the type on which it is a\u000a\u0009// method using the size as a size hint.\u000a\u0009Generate(rand *rand.Rand, size int) reflect.Value\u000a}</pre>\u000a<p>\u000aA Generator can generate random values of its own type.\u000a</p>\u000a\u000a","name":"Generator","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SetupError!\">SetupError</a></h2>\u000a<pre>type SetupError string</pre>\u000a<p>\u000aA SetupError is the result of an error in the way that check is being\u000aused, independent of the functions being tested.\u000a</p>\u000a\u000a","name":"SetupError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SetupError\">func (SetupError)</a> <a href=\"?m:SetupError.String!\">String</a></h2>\u000a<code>func (s SetupError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Check!\">Check</a></h2>\u000a<code>func Check(function interface{}, config *Config) (err os.Error)</code>\u000a<p>\u000aCheck looks for an input to f, any function that returns bool,\u000asuch that f returns false.  It calls f repeatedly, with arbitrary\u000avalues for each argument.  If f returns false on a given input,\u000aCheck returns that input as a *CheckError.\u000aFor example:\u000a</p>\u000a<pre>func TestOddMultipleOfThree(t *testing.T) {\u000a\u0009f := func(x int) bool {\u000a\u0009\u0009y := OddMultipleOfThree(x)\u000a\u0009\u0009return y%2 == 1 &amp;&amp; y%3 == 0\u000a\u0009}\u000a\u0009if err := quick.Check(f, nil); err != nil {\u000a\u0009\u0009t.Error(err)\u000a\u0009}\u000a}\u000a</pre>\u000a\u000a","name":"Check"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckEqual!\">CheckEqual</a></h2>\u000a<code>func CheckEqual(f, g interface{}, config *Config) (err os.Error)</code>\u000a<p>\u000aCheckEqual looks for an input on which f and g return different results.\u000aIt calls f and g repeatedly with arbitrary values for each argument.\u000aIf f and g return different answers, CheckEqual returns a *CheckEqualError\u000adescribing the input and the outputs.\u000a</p>\u000a\u000a","name":"CheckEqual"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Value!\">Value</a></h2>\u000a<code>func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)</code>\u000a<p>\u000aValue returns an arbitrary value of the given type.\u000aIf the type implements the Generator interface, that will be used.\u000aNote: in order to create arbitrary values for structs, all the members must be public.\u000a</p>\u000a\u000a","name":"Value"}],"consts":[],"vars":[]}