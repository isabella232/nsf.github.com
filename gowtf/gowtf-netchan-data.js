var gowtfData = {"index":"index.html","html":"<p>\u000aThe netchan package implements type-safe networked channels:\u000ait allows the two ends of a channel to appear on different\u000acomputers connected by a network.  It does this by transporting\u000adata sent to a channel on one machine so it can be recovered\u000aby a receive of a channel of the same type on the other.\u000a</p>\u000a<p>\u000aAn exporter publishes a set of channels by name.  An importer\u000aconnects to the exporting machine and imports the channels\u000aby name. After importing the channels, the two machines can\u000ause the channels in the usual way.\u000a</p>\u000a<p>\u000aNetworked channels are not synchronized; they always behave\u000aas if they are buffered channels of at least one element.\u000a</p>\u000a","name":"netchan","filenames":["/home/nsf/go/src/pkg/netchan/common.go","/home/nsf/go/src/pkg/netchan/import.go","/home/nsf/go/src/pkg/netchan/export.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Dir!\">Dir</a></h2>\u000a<pre>type Dir int</pre>\u000a<p>\u000aThe direction of a connection from the client&#39;s perspective.\u000a</p>\u000a\u000a","name":"Dir","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Dir\">func (Dir)</a> <a href=\"?m:Dir.String!\">String</a></h2>\u000a<code>func (dir Dir) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Exporter!\">Exporter</a></h2>\u000a<pre>type Exporter struct {\u000a\u0009*clientSet\u000a\u0009listener net.Listener\u000a}</pre>\u000a<p>\u000aAn Exporter allows a set of channels to be published on a single\u000anetwork port.  A single machine may have multiple Exporters\u000abut they must use different ports.\u000a</p>\u000a\u000a","name":"Exporter","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Addr!\">Addr</a></h2>\u000a<code>func (exp *Exporter) Addr() net.Addr</code>\u000a<p>\u000aAddr returns the Exporter&#39;s local network address.\u000a</p>\u000a\u000a","name":"Addr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Drain!\">Drain</a></h2>\u000a<code>func (exp *Exporter) Drain(timeout int64) os.Error</code>\u000a<p>\u000aDrain waits until all messages sent from this exporter/importer, including\u000athose not yet sent to any client and possibly including those sent while\u000aDrain was executing, have been received by the importer.  In short, it\u000awaits until all the exporter&#39;s messages have been received by a client.\u000aIf the timeout (measured in nanoseconds) is positive and Drain takes\u000alonger than that to complete, an error is returned.\u000a</p>\u000a\u000a","name":"Drain"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Export!\">Export</a></h2>\u000a<code>func (exp *Exporter) Export(name string, chT interface{}, dir Dir) os.Error</code>\u000a<p>\u000aExport exports a channel of a given type and specified direction.  The\u000achannel to be exported is provided in the call and may be of arbitrary\u000achannel type.\u000aDespite the literal signature, the effective signature is\u000a</p>\u000a<pre>Export(name string, chT chan T, dir Dir)\u000a</pre>\u000a\u000a","name":"Export"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Hangup!\">Hangup</a></h2>\u000a<code>func (exp *Exporter) Hangup(name string) os.Error</code>\u000a<p>\u000aHangup disassociates the named channel from the Exporter and closes\u000athe channel.  Messages in flight for the channel may be dropped.\u000a</p>\u000a\u000a","name":"Hangup"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Sync!\">Sync</a></h2>\u000a<code>func (exp *Exporter) Sync(timeout int64) os.Error</code>\u000a<p>\u000aSync waits until all clients of the exporter have received the messages\u000athat were sent at the time Sync was invoked.  Unlike Drain, it does not\u000await for messages sent while it is running or messages that have not been\u000adispatched to any client.  If the timeout (measured in nanoseconds) is\u000apositive and Sync takes longer than that to complete, an error is\u000areturned.\u000a</p>\u000a\u000a","name":"Sync"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Importer!\">Importer</a></h2>\u000a<pre>type Importer struct {\u000a\u0009*encDec\u000a\u0009conn     net.Conn\u000a\u0009chanLock sync.Mutex // protects access to channel map\u000a\u0009chans    map[string]*chanDir\u000a\u0009errors   chan os.Error\u000a}</pre>\u000a<p>\u000aAn Importer allows a set of channels to be imported from a single\u000aremote machine/network port.  A machine may have multiple\u000aimporters, even from the same machine/network port.\u000a</p>\u000a\u000a","name":"Importer","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Errors!\">Errors</a></h2>\u000a<code>func (imp *Importer) Errors() chan os.Error</code>\u000a<p>\u000aErrors returns a channel from which transmission and protocol errors\u000acan be read. Clients of the importer are not required to read the error\u000achannel for correct execution. However, if too many errors occur\u000awithout being read from the error channel, the importer will shut down.\u000a</p>\u000a\u000a","name":"Errors"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Hangup!\">Hangup</a></h2>\u000a<code>func (imp *Importer) Hangup(name string) os.Error</code>\u000a<p>\u000aHangup disassociates the named channel from the Importer and closes\u000athe channel.  Messages in flight for the channel may be dropped.\u000a</p>\u000a\u000a","name":"Hangup"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Import!\">Import</a></h2>\u000a<code>func (imp *Importer) Import(name string, chT interface{}, dir Dir) os.Error</code>\u000a<p>\u000aImport imports a channel of the given type and specified direction.\u000aIt is equivalent to ImportNValues with a count of -1, meaning unbounded.\u000a</p>\u000a\u000a","name":"Import"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.ImportNValues!\">ImportNValues</a></h2>\u000a<code>func (imp *Importer) ImportNValues(name string, chT interface{}, dir Dir, n int) os.Error</code>\u000a<p>\u000aImportNValues imports a channel of the given type and specified direction\u000aand then receives or transmits up to n values on that channel.  A value of\u000an==-1 implies an unbounded number of values.  The channel to be bound to\u000athe remote site&#39;s channel is provided in the call and may be of arbitrary\u000achannel type.\u000aDespite the literal signature, the effective signature is\u000a</p>\u000a<pre>ImportNValues(name string, chT chan T, dir Dir, n int) os.Error\u000a</pre>\u000a<p>\u000aExample usage:\u000a</p>\u000a<pre>imp, err := NewImporter(&#34;tcp&#34;, &#34;netchanserver.mydomain.com:1234&#34;)\u000aif err != nil { log.Exit(err) }\u000ach := make(chan myType)\u000aerr = imp.ImportNValues(&#34;name&#34;, ch, Recv, 1)\u000aif err != nil { log.Exit(err) }\u000afmt.Printf(&#34;%+v\\n&#34;, &lt;-ch)\u000a</pre>\u000a\u000a","name":"ImportNValues"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewExporter!\">NewExporter</a></h2>\u000a<code>func NewExporter(network, localaddr string) (*Exporter, os.Error)</code>\u000a<p>\u000aNewExporter creates a new Exporter to export channels\u000aon the network and local address defined as in net.Listen.\u000a</p>\u000a\u000a","name":"NewExporter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewImporter!\">NewImporter</a></h2>\u000a<code>func NewImporter(network, remoteaddr string) (*Importer, os.Error)</code>\u000a<p>\u000aNewImporter creates a new Importer object to import channels\u000afrom an Exporter at the network and remote address as defined in net.Dial.\u000aThe Exporter must be available and serving when the Importer is\u000acreated.\u000a</p>\u000a\u000a","name":"NewImporter"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Dir!\">Dir</a></h2>\u000a<pre>const (\u000a\u0009Recv Dir = iota\u000a\u0009Send\u000a)</pre>\u000a\u000a","names":["Recv","Send"],"type":"Dir"}],"vars":[]}