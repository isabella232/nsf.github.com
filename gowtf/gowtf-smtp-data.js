var gowtfData = {"index":"index.html","html":"<p>\u000aPackage smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\u000aIt also implements the following extensions:\u000a</p>\u000a<pre>8BITMIME  RFC 1652\u000aAUTH      RFC 2554\u000aSTARTTLS  RFC 3207\u000a</pre>\u000a<p>\u000aAdditional extensions may be handled by clients.\u000a</p>\u000a","name":"smtp","filenames":["/home/nsf/go/src/pkg/smtp/smtp.go","/home/nsf/go/src/pkg/smtp/auth.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Auth!\">Auth</a></h2>\u000a<pre>type Auth interface {\u000a\u0009// Start begins an authentication with a server.\u000a\u0009// It returns the name of the authentication protocol\u000a\u0009// and optionally data to include in the initial AUTH message\u000a\u0009// sent to the server. It can return proto == &#34;&#34; to indicate\u000a\u0009// that the authentication should be skipped.\u000a\u0009// If it returns a non-nil os.Error, the SMTP client aborts\u000a\u0009// the authentication attempt and closes the connection.\u000a\u0009Start(server *ServerInfo) (proto string, toServer []byte, err os.Error)\u000a\u000a\u0009// Next continues the authentication. The server has just sent\u000a\u0009// the fromServer data. If more is true, the server expects a\u000a\u0009// response, which Next should return as toServer; otherwise\u000a\u0009// Next should return toServer == nil.\u000a\u0009// If Next returns a non-nil os.Error, the SMTP client aborts\u000a\u0009// the authentication attempt and closes the connection.\u000a\u0009Next(fromServer []byte, more bool) (toServer []byte, err os.Error)\u000a}</pre>\u000a<p>\u000aAuth is implemented by an SMTP authentication mechanism.\u000a</p>\u000a\u000a","name":"Auth","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Client!\">Client</a></h2>\u000a<pre>type Client struct {\u000a\u0009// Text is the textproto.Conn used by the Client. It is exported to allow for\u000a\u0009// clients to add extensions.\u000a\u0009Text *textproto.Conn\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Client represents a client connection to an SMTP server.\u000a</p>\u000a\u000a","name":"Client","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Auth!\">Auth</a></h2>\u000a<code>func (c *Client) Auth(a Auth) os.Error</code>\u000a<p>\u000aAuth authenticates a client using the provided authentication mechanism.\u000aA failed authentication closes the connection.\u000aOnly servers that advertise the AUTH extension support this function.\u000a</p>\u000a\u000a","name":"Auth"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Data!\">Data</a></h2>\u000a<code>func (c *Client) Data() (io.WriteCloser, os.Error)</code>\u000a<p>\u000aData issues a DATA command to the server and returns a writer that\u000acan be used to write the data. The caller should close the writer\u000abefore calling any more methods on c.\u000aA call to Data must be preceded by one or more calls to Rcpt.\u000a</p>\u000a\u000a","name":"Data"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Extension!\">Extension</a></h2>\u000a<code>func (c *Client) Extension(ext string) (bool, string)</code>\u000a<p>\u000aExtension reports whether an extension is support by the server.\u000aThe extension name is case-insensitive. If the extension is supported,\u000aExtension also returns a string that contains any parameters the\u000aserver specifies for the extension.\u000a</p>\u000a\u000a","name":"Extension"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Mail!\">Mail</a></h2>\u000a<code>func (c *Client) Mail(from string) os.Error</code>\u000a<p>\u000aMail issues a MAIL command to the server using the provided email address.\u000aIf the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME\u000aparameter.\u000aThis initiates a mail transaction and is followed by one or more Rcpt calls.\u000a</p>\u000a\u000a","name":"Mail"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Quit!\">Quit</a></h2>\u000a<code>func (c *Client) Quit() os.Error</code>\u000a<p>\u000aQuit sends the QUIT command and closes the connection to the server.\u000a</p>\u000a\u000a","name":"Quit"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Rcpt!\">Rcpt</a></h2>\u000a<code>func (c *Client) Rcpt(to string) os.Error</code>\u000a<p>\u000aRcpt issues a RCPT command to the server using the provided email address.\u000aA call to Rcpt must be preceded by a call to Mail and may be followed by\u000aa Data call or another Rcpt call.\u000a</p>\u000a\u000a","name":"Rcpt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Reset!\">Reset</a></h2>\u000a<code>func (c *Client) Reset() os.Error</code>\u000a<p>\u000aReset sends the RSET command to the server, aborting the current mail\u000atransaction.\u000a</p>\u000a\u000a","name":"Reset"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.StartTLS!\">StartTLS</a></h2>\u000a<code>func (c *Client) StartTLS() os.Error</code>\u000a<p>\u000aStartTLS sends the STARTTLS command and encrypts all further communication.\u000aOnly servers that advertise the STARTTLS extension support this function.\u000a</p>\u000a\u000a","name":"StartTLS"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Verify!\">Verify</a></h2>\u000a<code>func (c *Client) Verify(addr string) os.Error</code>\u000a<p>\u000aVerify checks the validity of an email address on the server.\u000aIf Verify returns nil, the address is valid. A non-nil return\u000adoes not necessarily indicate an invalid address. Many servers\u000awill not verify addresses for security reasons.\u000a</p>\u000a\u000a","name":"Verify"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerInfo!\">ServerInfo</a></h2>\u000a<pre>type ServerInfo struct {\u000a\u0009Name string   // SMTP server name\u000a\u0009TLS  bool     // using TLS, with valid certificate for Name\u000a\u0009Auth []string // advertised authentication mechanisms\u000a}</pre>\u000a<p>\u000aServerInfo records information about an SMTP server.\u000a</p>\u000a\u000a","name":"ServerInfo","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\u000a<code>func Dial(addr string) (*Client, os.Error)</code>\u000a<p>\u000aDial returns a new Client connected to an SMTP server at addr.\u000a</p>\u000a\u000a","name":"Dial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClient!\">NewClient</a></h2>\u000a<code>func NewClient(conn net.Conn, host string) (*Client, os.Error)</code>\u000a<p>\u000aNewClient returns a new Client using an existing connection and host as a\u000aserver name to be used when authenticating.\u000a</p>\u000a\u000a","name":"NewClient"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PlainAuth!\">PlainAuth</a></h2>\u000a<code>func PlainAuth(identity, username, password, host string) Auth</code>\u000a<p>\u000aPlainAuth returns an Auth that implements the PLAIN authentication\u000amechanism as defined in RFC 4616.\u000aThe returned Auth uses the given username and password to authenticate\u000aon TLS connections to host and act as identity. Usually identity will be\u000aleft blank to act as username.\u000a</p>\u000a\u000a","name":"PlainAuth"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SendMail!\">SendMail</a></h2>\u000a<code>func SendMail(addr string, a Auth, from string, to []string, msg []byte) os.Error</code>\u000a<p>\u000aSendMail connects to the server at addr, switches to TLS if possible,\u000aauthenticates with mechanism a if possible, and then sends an email from\u000aaddress from, to addresses to, with message msg.\u000a</p>\u000a\u000a","name":"SendMail"}],"consts":[],"vars":[]}