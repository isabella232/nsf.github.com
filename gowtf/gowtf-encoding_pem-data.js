var gowtfData = {"html":"<p>\u000aThis package implements the PEM data encoding, which originated in Privacy\u000aEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\u000acertificates. See RFC 1421.\u000a</p>\u000a","name":"pem","filenames":["/home/nsf/go/src/pkg/encoding/pem/pem.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Block!\">Block</a></h2>\u000a<pre>type Block struct {\u000a\u0009Type    string            // The type, taken from the preamble (i.e. &#34;RSA PRIVATE KEY&#34;).\u000a\u0009Headers map[string]string // Optional headers.\u000a\u0009Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\u000a}</pre>\u000a<p>\u000aA Block represents a PEM encoded structure.\u000a</p>\u000a<p>\u000aThe encoded form is:\u000a</p>\u000a<pre>-----BEGIN Type-----\u000aHeaders\u000abase64-encoded Bytes\u000a-----END Type-----\u000a</pre>\u000a<p>\u000awhere Headers is a possibly empty sequence of Key: Value lines.\u000a</p>\u000a\u000a","name":"Block","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Decode!\">Decode</a></h2>\u000a<code>func Decode(data []byte) (p *Block, rest []byte)</code>\u000a<p>\u000aDecode will find the next PEM formatted block (certificate, private key\u000aetc) in the input. It returns that block and the remainder of the input. If\u000ano PEM data is found, p is nil and the whole of the input is returned in\u000arest.\u000a</p>\u000a\u000a","name":"Decode"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Encode!\">Encode</a></h2>\u000a<code>func Encode(out io.Writer, b *Block) (err os.Error)</code>\u000a\u000a","name":"Encode"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodeToMemory!\">EncodeToMemory</a></h2>\u000a<code>func EncodeToMemory(b *Block) []byte</code>\u000a\u000a","name":"EncodeToMemory"}],"consts":[],"vars":[]}