var gowtfData = {"index":"index.html","html":"<p>\u000aThe reflect package implements run-time reflection, allowing a program to\u000amanipulate objects with arbitrary types.  The typical use is to take a\u000avalue with static type interface{} and extract its dynamic type\u000ainformation by calling Typeof, which returns an object with interface\u000atype Type.  That contains a pointer to a struct of type *StructType,\u000a*IntType, etc. representing the details of the underlying type.  A type\u000aswitch or type assertion can reveal which.\u000a</p>\u000a<p>\u000aA call to NewValue creates a Value representing the run-time data; it\u000acontains a *StructValue, *IntValue, etc.  MakeZero takes a Type and\u000areturns a Value representing a zero value for that type.\u000a</p>\u000a","name":"reflect","filenames":["/home/nsf/go/src/pkg/reflect/value.go","/home/nsf/go/src/pkg/reflect/deepequal.go","/home/nsf/go/src/pkg/reflect/type.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayOrSliceType!\">ArrayOrSliceType</a></h2>\u000a<pre>type ArrayOrSliceType interface {\u000a\u0009Type\u000a\u0009Elem() Type\u000a}</pre>\u000a<p>\u000aArrayOrSliceType is the common interface implemented\u000aby both ArrayType and SliceType.\u000a</p>\u000a\u000a","name":"ArrayOrSliceType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayOrSliceValue!\">ArrayOrSliceValue</a></h2>\u000a<pre>type ArrayOrSliceValue interface {\u000a\u0009Value\u000a\u0009Len() int\u000a\u0009Cap() int\u000a\u0009Elem(i int) Value\u000a\u0009addr() addr\u000a}</pre>\u000a<p>\u000aArrayOrSliceValue is the common interface\u000aimplemented by both ArrayValue and SliceValue.\u000a</p>\u000a\u000a","name":"ArrayOrSliceValue","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\u000a<pre>type ArrayType struct {\u000a\u0009commonType &#34;array&#34;\u000a\u0009elem       *runtime.Type\u000a\u0009len        uintptr\u000a}</pre>\u000a<p>\u000aArrayType represents a fixed array type.\u000a</p>\u000a\u000a","name":"ArrayType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Elem!\">Elem</a></h2>\u000a<code>func (t *ArrayType) Elem() Type</code>\u000a<p>\u000aElem returns the type of the array&#39;s elements.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Len!\">Len</a></h2>\u000a<code>func (t *ArrayType) Len() int</code>\u000a<p>\u000aLen returns the number of elements in the array.\u000a</p>\u000a\u000a","name":"Len"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayValue!\">ArrayValue</a></h2>\u000a<pre>type ArrayValue struct {\u000a\u0009value &#34;array&#34;\u000a}</pre>\u000a<p>\u000aAn ArrayValue represents an array.\u000a</p>\u000a\u000a","name":"ArrayValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Cap!\">Cap</a></h2>\u000a<code>func (v *ArrayValue) Cap() int</code>\u000a<p>\u000aCap returns the capacity of the array (equal to Len()).\u000a</p>\u000a\u000a","name":"Cap"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Elem!\">Elem</a></h2>\u000a<code>func (v *ArrayValue) Elem(i int) Value</code>\u000a<p>\u000aElem returns the i&#39;th element of v.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Len!\">Len</a></h2>\u000a<code>func (v *ArrayValue) Len() int</code>\u000a<p>\u000aLen returns the length of the array.\u000a</p>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Set!\">Set</a></h2>\u000a<code>func (v *ArrayValue) Set(x *ArrayValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *ArrayValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolType!\">BoolType</a></h2>\u000a<pre>type BoolType struct {\u000a\u0009commonType &#34;bool&#34;\u000a}</pre>\u000a<p>\u000aBoolType represents a boolean type.\u000a</p>\u000a\u000a","name":"BoolType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolValue!\">BoolValue</a></h2>\u000a<pre>type BoolValue struct {\u000a\u0009value &#34;bool&#34;\u000a}</pre>\u000a<p>\u000aBoolValue represents a bool value.\u000a</p>\u000a\u000a","name":"BoolValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.Get!\">Get</a></h2>\u000a<code>func (v *BoolValue) Get() bool</code>\u000a<p>\u000aGet returns the underlying bool value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.Set!\">Set</a></h2>\u000a<code>func (v *BoolValue) Set(x bool)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *BoolValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\u000a<pre>type ChanDir int</pre>\u000a<p>\u000aChanDir represents a channel type&#39;s direction.\u000a</p>\u000a\u000a","name":"ChanDir","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanDir\">func (ChanDir)</a> <a href=\"?m:ChanDir.String!\">String</a></h2>\u000a<code>func (d ChanDir) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\u000a<pre>type ChanType struct {\u000a\u0009commonType &#34;chan&#34;\u000a\u0009elem       *runtime.Type\u000a\u0009dir        uintptr\u000a}</pre>\u000a<p>\u000aChanType represents a channel type.\u000a</p>\u000a\u000a","name":"ChanType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.Dir!\">Dir</a></h2>\u000a<code>func (t *ChanType) Dir() ChanDir</code>\u000a<p>\u000aDir returns the channel direction.\u000a</p>\u000a\u000a","name":"Dir"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.Elem!\">Elem</a></h2>\u000a<code>func (t *ChanType) Elem() Type</code>\u000a<p>\u000aElem returns the channel&#39;s element type.\u000a</p>\u000a\u000a","name":"Elem"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanValue!\">ChanValue</a></h2>\u000a<pre>type ChanValue struct {\u000a\u0009value &#34;chan&#34;\u000a}</pre>\u000a<p>\u000aA ChanValue represents a chan.\u000a</p>\u000a\u000a","name":"ChanValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Cap!\">Cap</a></h2>\u000a<code>func (v *ChanValue) Cap() int</code>\u000a\u000a","name":"Cap"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Close!\">Close</a></h2>\u000a<code>func (v *ChanValue) Close()</code>\u000a<p>\u000aClose closes the channel.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Closed!\">Closed</a></h2>\u000a<code>func (v *ChanValue) Closed() bool</code>\u000a<p>\u000aClosed returns the result of closed(c) on the underlying channel.\u000a</p>\u000a\u000a","name":"Closed"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Get!\">Get</a></h2>\u000a<code>func (v *ChanValue) Get() uintptr</code>\u000a<p>\u000aGet returns the uintptr value of v.\u000aIt is mainly useful for printing.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *ChanValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil channel.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Len!\">Len</a></h2>\u000a<code>func (v *ChanValue) Len() int</code>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Recv!\">Recv</a></h2>\u000a<code>func (v *ChanValue) Recv() Value</code>\u000a<p>\u000aRecv receives and returns a value from the channel v.\u000a</p>\u000a\u000a","name":"Recv"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Send!\">Send</a></h2>\u000a<code>func (v *ChanValue) Send(x Value)</code>\u000a<p>\u000aSend sends x on the channel v.\u000a</p>\u000a\u000a","name":"Send"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Set!\">Set</a></h2>\u000a<code>func (v *ChanValue) Set(x *ChanValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *ChanValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.TryRecv!\">TryRecv</a></h2>\u000a<code>func (v *ChanValue) TryRecv() Value</code>\u000a<p>\u000aTryRecv attempts to receive a value from the channel v but will not block.\u000aIt returns the value if one is received, nil otherwise.\u000a</p>\u000a\u000a","name":"TryRecv"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.TrySend!\">TrySend</a></h2>\u000a<code>func (v *ChanValue) TrySend(x Value) bool</code>\u000a<p>\u000aTrySend attempts to sends x on the channel v but will not block.\u000aIt returns true if the value was sent, false otherwise.\u000a</p>\u000a\u000a","name":"TrySend"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexType!\">ComplexType</a></h2>\u000a<pre>type ComplexType struct {\u000a\u0009commonType &#34;complex&#34;\u000a}</pre>\u000a<p>\u000aComplexType represents a complex type.\u000a</p>\u000a\u000a","name":"ComplexType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexValue!\">ComplexValue</a></h2>\u000a<pre>type ComplexValue struct {\u000a\u0009value &#34;complex&#34;\u000a}</pre>\u000a<p>\u000aComplexValue represents a complex value.\u000a</p>\u000a\u000a","name":"ComplexValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.Get!\">Get</a></h2>\u000a<code>func (v *ComplexValue) Get() complex128</code>\u000a<p>\u000aGet returns the underlying complex value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.Set!\">Set</a></h2>\u000a<code>func (v *ComplexValue) Set(x complex128)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *ComplexValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatType!\">FloatType</a></h2>\u000a<pre>type FloatType struct {\u000a\u0009commonType &#34;float&#34;\u000a}</pre>\u000a<p>\u000aFloatType represents a float type.\u000a</p>\u000a\u000a","name":"FloatType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatValue!\">FloatValue</a></h2>\u000a<pre>type FloatValue struct {\u000a\u0009value &#34;float&#34;\u000a}</pre>\u000a<p>\u000aFloatValue represents a float value.\u000a</p>\u000a\u000a","name":"FloatValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Get!\">Get</a></h2>\u000a<code>func (v *FloatValue) Get() float64</code>\u000a<p>\u000aGet returns the underlying int value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Overflow!\">Overflow</a></h2>\u000a<code>func (v *FloatValue) Overflow(x float64) bool</code>\u000a<p>\u000aOverflow returns true if x cannot be represented by the type of v.\u000a</p>\u000a\u000a","name":"Overflow"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Set!\">Set</a></h2>\u000a<code>func (v *FloatValue) Set(x float64)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *FloatValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\u000a<pre>type FuncType struct {\u000a\u0009commonType &#34;func&#34;\u000a\u0009dotdotdot  bool\u000a\u0009in         []*runtime.Type\u000a\u0009out        []*runtime.Type\u000a}</pre>\u000a<p>\u000aFuncType represents a function type.\u000a</p>\u000a\u000a","name":"FuncType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.DotDotDot!\">DotDotDot</a></h2>\u000a<code>func (t *FuncType) DotDotDot() bool</code>\u000a<p>\u000aDotDotDot returns true if the final function input parameter\u000ais a &#34;...&#34; parameter.  If so, t.In(t.NumIn() - 1) returns the\u000aparameter&#39;s underlying static type []T.\u000a</p>\u000a<p>\u000aFor concreteness, if t is func(x int, y ... float), then\u000a</p>\u000a<pre>t.NumIn() == 2\u000at.In(0) is the reflect.Type for &#34;int&#34;\u000at.In(1) is the reflect.Type for &#34;[]float&#34;\u000at.DotDotDot() == true\u000a</pre>\u000a\u000a","name":"DotDotDot"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.In!\">In</a></h2>\u000a<code>func (t *FuncType) In(i int) Type</code>\u000a<p>\u000aIn returns the type of the i&#39;th function input parameter.\u000a</p>\u000a\u000a","name":"In"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.NumIn!\">NumIn</a></h2>\u000a<code>func (t *FuncType) NumIn() int</code>\u000a<p>\u000aNumIn returns the number of input parameters.\u000a</p>\u000a\u000a","name":"NumIn"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.NumOut!\">NumOut</a></h2>\u000a<code>func (t *FuncType) NumOut() int</code>\u000a<p>\u000aNumOut returns the number of function output parameters.\u000a</p>\u000a\u000a","name":"NumOut"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.Out!\">Out</a></h2>\u000a<code>func (t *FuncType) Out(i int) Type</code>\u000a<p>\u000aOut returns the type of the i&#39;th function output parameter.\u000a</p>\u000a\u000a","name":"Out"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncValue!\">FuncValue</a></h2>\u000a<pre>type FuncValue struct {\u000a\u0009value       &#34;func&#34;\u000a\u0009first       *value\u000a\u0009isInterface bool\u000a}</pre>\u000a<p>\u000aA FuncValue represents a function value.\u000a</p>\u000a\u000a","name":"FuncValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Call!\">Call</a></h2>\u000a<code>func (fv *FuncValue) Call(in []Value) []Value</code>\u000a<p>\u000aCall calls the function fv with input parameters in.\u000aIt returns the function&#39;s output parameters as Values.\u000a</p>\u000a\u000a","name":"Call"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Get!\">Get</a></h2>\u000a<code>func (v *FuncValue) Get() uintptr</code>\u000a<p>\u000aGet returns the uintptr value of v.\u000aIt is mainly useful for printing.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *FuncValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil function.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Set!\">Set</a></h2>\u000a<code>func (v *FuncValue) Set(x *FuncValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *FuncValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntType!\">IntType</a></h2>\u000a<pre>type IntType struct {\u000a\u0009commonType &#34;int&#34;\u000a}</pre>\u000a<p>\u000aIntType represents a signed integer type.\u000a</p>\u000a\u000a","name":"IntType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntValue!\">IntValue</a></h2>\u000a<pre>type IntValue struct {\u000a\u0009value &#34;int&#34;\u000a}</pre>\u000a<p>\u000aIntValue represents an int value.\u000a</p>\u000a\u000a","name":"IntValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Get!\">Get</a></h2>\u000a<code>func (v *IntValue) Get() int64</code>\u000a<p>\u000aGet returns the underlying int value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Overflow!\">Overflow</a></h2>\u000a<code>func (v *IntValue) Overflow(x int64) bool</code>\u000a<p>\u000aOverflow returns true if x cannot be represented by the type of v.\u000a</p>\u000a\u000a","name":"Overflow"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Set!\">Set</a></h2>\u000a<code>func (v *IntValue) Set(x int64)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *IntValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\u000a<pre>type InterfaceType struct {\u000a\u0009commonType &#34;interface&#34;\u000a\u0009methods    []imethod\u000a}</pre>\u000a<p>\u000aInterfaceType represents an interface type.\u000a</p>\u000a\u000a","name":"InterfaceType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.Method!\">Method</a></h2>\u000a<code>func (t *InterfaceType) Method(i int) (m Method)</code>\u000a<p>\u000aMethod returns the i&#39;th interface method.\u000a</p>\u000a\u000a","name":"Method"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.NumMethod!\">NumMethod</a></h2>\u000a<code>func (t *InterfaceType) NumMethod() int</code>\u000a<p>\u000aNumMethod returns the number of interface methods.\u000a</p>\u000a\u000a","name":"NumMethod"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceValue!\">InterfaceValue</a></h2>\u000a<pre>type InterfaceValue struct {\u000a\u0009value &#34;interface&#34;\u000a}</pre>\u000a<p>\u000aAn InterfaceValue represents an interface value.\u000a</p>\u000a\u000a","name":"InterfaceValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Elem!\">Elem</a></h2>\u000a<code>func (v *InterfaceValue) Elem() Value</code>\u000a<p>\u000aElem returns the concrete value stored in the interface value v.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Get!\">Get</a></h2>\u000a<code>func (v *InterfaceValue) Get() [2]uintptr</code>\u000a<p>\u000aGet returns the two words that represent an interface in the runtime.\u000aThose words are useful only when playing unsafe games.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *InterfaceValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil interface value.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Method!\">Method</a></h2>\u000a<code>func (v *InterfaceValue) Method(i int) *FuncValue</code>\u000a<p>\u000aMethod returns a FuncValue corresponding to v&#39;s i&#39;th method.\u000aThe arguments to a Call on the returned FuncValue\u000ashould not include a receiver; the FuncValue will use v\u000aas the receiver.\u000a</p>\u000a\u000a","name":"Method"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Set!\">Set</a></h2>\u000a<code>func (v *InterfaceValue) Set(x Value)</code>\u000a<p>\u000aSet assigns x to v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *InterfaceValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Kind!\">Kind</a></h2>\u000a<pre>type Kind uint8</pre>\u000a<p>\u000aA Kind represents the specific kind of type that a Type represents.\u000aFor numeric types, the Kind gives more information than the Type&#39;s\u000adynamic type.  For example, the Type of a float32 is FloatType, but\u000athe Kind is Float32.\u000a</p>\u000a<p>\u000aThe zero Kind is not a valid kind.\u000a</p>\u000a\u000a","name":"Kind","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Kind\">func (Kind)</a> <a href=\"?m:Kind.String!\">String</a></h2>\u000a<code>func (k Kind) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\u000a<pre>type MapType struct {\u000a\u0009commonType &#34;map&#34;\u000a\u0009key        *runtime.Type\u000a\u0009elem       *runtime.Type\u000a}</pre>\u000a<p>\u000aMapType represents a map type.\u000a</p>\u000a\u000a","name":"MapType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.Elem!\">Elem</a></h2>\u000a<code>func (t *MapType) Elem() Type</code>\u000a<p>\u000aElem returns the map element type.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.Key!\">Key</a></h2>\u000a<code>func (t *MapType) Key() Type</code>\u000a<p>\u000aKey returns the map key type.\u000a</p>\u000a\u000a","name":"Key"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapValue!\">MapValue</a></h2>\u000a<pre>type MapValue struct {\u000a\u0009value &#34;map&#34;\u000a}</pre>\u000a<p>\u000aA MapValue represents a map value.\u000a</p>\u000a\u000a","name":"MapValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Elem!\">Elem</a></h2>\u000a<code>func (v *MapValue) Elem(key Value) Value</code>\u000a<p>\u000aElem returns the value associated with key in the map v.\u000aIt returns nil if key is not found in the map.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Get!\">Get</a></h2>\u000a<code>func (v *MapValue) Get() uintptr</code>\u000a<p>\u000aGet returns the uintptr value of v.\u000aIt is mainly useful for printing.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *MapValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil map value.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Keys!\">Keys</a></h2>\u000a<code>func (v *MapValue) Keys() []Value</code>\u000a<p>\u000aKeys returns a slice containing all the keys present in the map,\u000ain unspecified order.\u000a</p>\u000a\u000a","name":"Keys"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Len!\">Len</a></h2>\u000a<code>func (v *MapValue) Len() int</code>\u000a<p>\u000aLen returns the number of keys in the map v.\u000a</p>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Set!\">Set</a></h2>\u000a<code>func (v *MapValue) Set(x *MapValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.SetElem!\">SetElem</a></h2>\u000a<code>func (v *MapValue) SetElem(key, val Value)</code>\u000a<p>\u000aSetElem sets the value associated with key in the map v to val.\u000aIf val is nil, Put deletes the key from map.\u000a</p>\u000a\u000a","name":"SetElem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *MapValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Method!\">Method</a></h2>\u000a<pre>type Method struct {\u000a\u0009PkgPath string // empty for uppercase Name\u000a\u0009Name    string\u000a\u0009Type    *FuncType\u000a\u0009Func    *FuncValue\u000a}</pre>\u000a<p>\u000aMethod represents a single method.\u000a</p>\u000a\u000a","name":"Method","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrType!\">PtrType</a></h2>\u000a<pre>type PtrType struct {\u000a\u0009commonType &#34;ptr&#34;\u000a\u0009elem       *runtime.Type\u000a}</pre>\u000a<p>\u000aPtrType represents a pointer type.\u000a</p>\u000a\u000a","name":"PtrType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrType\">func (*PtrType)</a> <a href=\"?m:PtrType.Elem!\">Elem</a></h2>\u000a<code>func (t *PtrType) Elem() Type</code>\u000a<p>\u000aElem returns the pointer element type.\u000a</p>\u000a\u000a","name":"Elem"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrValue!\">PtrValue</a></h2>\u000a<pre>type PtrValue struct {\u000a\u0009value &#34;ptr&#34;\u000a}</pre>\u000a<p>\u000aA PtrValue represents a pointer.\u000a</p>\u000a\u000a","name":"PtrValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Elem!\">Elem</a></h2>\u000a<code>func (v *PtrValue) Elem() Value</code>\u000a<p>\u000aElem returns the value that v points to.\u000aIf v is a nil pointer, Elem returns a nil Value.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Get!\">Get</a></h2>\u000a<code>func (v *PtrValue) Get() uintptr</code>\u000a<p>\u000aGet returns the uintptr value of v.\u000aIt is mainly useful for printing.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *PtrValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil pointer.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.PointTo!\">PointTo</a></h2>\u000a<code>func (v *PtrValue) PointTo(x Value)</code>\u000a<p>\u000aPointTo changes v to point to x.\u000aIf x is a nil Value, PointTo sets v to nil.\u000a</p>\u000a\u000a","name":"PointTo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Set!\">Set</a></h2>\u000a<code>func (v *PtrValue) Set(x *PtrValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *PtrValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceHeader!\">SliceHeader</a></h2>\u000a<pre>type SliceHeader struct {\u000a\u0009Data uintptr\u000a\u0009Len  int\u000a\u0009Cap  int\u000a}</pre>\u000a<p>\u000aruntime representation of slice\u000a</p>\u000a\u000a","name":"SliceHeader","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceType!\">SliceType</a></h2>\u000a<pre>type SliceType struct {\u000a\u0009commonType &#34;slice&#34;\u000a\u0009elem       *runtime.Type\u000a}</pre>\u000a<p>\u000aSliceType represents a slice type.\u000a</p>\u000a\u000a","name":"SliceType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceType\">func (*SliceType)</a> <a href=\"?m:SliceType.Elem!\">Elem</a></h2>\u000a<code>func (t *SliceType) Elem() Type</code>\u000a<p>\u000aElem returns the type of the slice&#39;s elements.\u000a</p>\u000a\u000a","name":"Elem"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceValue!\">SliceValue</a></h2>\u000a<pre>type SliceValue struct {\u000a\u0009value &#34;slice&#34;\u000a}</pre>\u000a<p>\u000aA SliceValue represents a slice.\u000a</p>\u000a\u000a","name":"SliceValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Cap!\">Cap</a></h2>\u000a<code>func (v *SliceValue) Cap() int</code>\u000a<p>\u000aCap returns the capacity of the slice.\u000a</p>\u000a\u000a","name":"Cap"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Elem!\">Elem</a></h2>\u000a<code>func (v *SliceValue) Elem(i int) Value</code>\u000a<p>\u000aElem returns the i&#39;th element of v.\u000a</p>\u000a\u000a","name":"Elem"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Get!\">Get</a></h2>\u000a<code>func (v *SliceValue) Get() uintptr</code>\u000a<p>\u000aGet returns the uintptr address of the v.Cap()&#39;th element.  This gives\u000athe same result for all slices of the same array.\u000aIt is mainly useful for printing.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.IsNil!\">IsNil</a></h2>\u000a<code>func (v *SliceValue) IsNil() bool</code>\u000a<p>\u000aIsNil returns whether v is a nil slice.\u000a</p>\u000a\u000a","name":"IsNil"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Len!\">Len</a></h2>\u000a<code>func (v *SliceValue) Len() int</code>\u000a<p>\u000aLen returns the length of the slice.\u000a</p>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Set!\">Set</a></h2>\u000a<code>func (v *SliceValue) Set(x *SliceValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.SetLen!\">SetLen</a></h2>\u000a<code>func (v *SliceValue) SetLen(n int)</code>\u000a<p>\u000aSetLen changes the length of v.\u000aThe new length n must be between 0 and the capacity, inclusive.\u000a</p>\u000a\u000a","name":"SetLen"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *SliceValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Slice!\">Slice</a></h2>\u000a<code>func (v *SliceValue) Slice(beg, end int) *SliceValue</code>\u000a<p>\u000aSlice returns a sub-slice of the slice v.\u000a</p>\u000a\u000a","name":"Slice"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringHeader!\">StringHeader</a></h2>\u000a<pre>type StringHeader struct {\u000a\u0009Data uintptr\u000a\u0009Len  int\u000a}</pre>\u000a<p>\u000aStringHeader is the runtime representation of a string.\u000a</p>\u000a\u000a","name":"StringHeader","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringType!\">StringType</a></h2>\u000a<pre>type StringType struct {\u000a\u0009commonType &#34;string&#34;\u000a}</pre>\u000a<p>\u000aStringType represents a string type.\u000a</p>\u000a\u000a","name":"StringType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringValue!\">StringValue</a></h2>\u000a<pre>type StringValue struct {\u000a\u0009value &#34;string&#34;\u000a}</pre>\u000a<p>\u000aStringValue represents a string value.\u000a</p>\u000a\u000a","name":"StringValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.Get!\">Get</a></h2>\u000a<code>func (v *StringValue) Get() string</code>\u000a<p>\u000aGet returns the underlying string value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.Set!\">Set</a></h2>\u000a<code>func (v *StringValue) Set(x string)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *StringValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructField!\">StructField</a></h2>\u000a<pre>type StructField struct {\u000a\u0009PkgPath   string // empty for uppercase Name\u000a\u0009Name      string\u000a\u0009Type      Type\u000a\u0009Tag       string\u000a\u0009Offset    uintptr\u000a\u0009Index     []int\u000a\u0009Anonymous bool\u000a}</pre>\u000a\u000a","name":"StructField","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\u000a<pre>type StructType struct {\u000a\u0009commonType &#34;struct&#34;\u000a\u0009fields     []structField\u000a}</pre>\u000a<p>\u000aStructType represents a struct type.\u000a</p>\u000a\u000a","name":"StructType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.Field!\">Field</a></h2>\u000a<code>func (t *StructType) Field(i int) (f StructField)</code>\u000a<p>\u000aField returns the i&#39;th struct field.\u000a</p>\u000a\u000a","name":"Field"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByIndex!\">FieldByIndex</a></h2>\u000a<code>func (t *StructType) FieldByIndex(index []int) (f StructField)</code>\u000a<p>\u000aFieldByIndex returns the nested field corresponding to index.\u000a</p>\u000a\u000a","name":"FieldByIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByName!\">FieldByName</a></h2>\u000a<code>func (t *StructType) FieldByName(name string) (f StructField, present bool)</code>\u000a<p>\u000aFieldByName returns the struct field with the given name\u000aand a boolean to indicate if the field was found.\u000a</p>\u000a\u000a","name":"FieldByName"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByNameFunc!\">FieldByNameFunc</a></h2>\u000a<code>func (t *StructType) FieldByNameFunc(match func(string) bool) (f StructField, present bool)</code>\u000a<p>\u000aFieldByNameFunc returns the struct field with a name that satisfies the\u000amatch function and a boolean to indicate if the field was found.\u000a</p>\u000a\u000a","name":"FieldByNameFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.NumField!\">NumField</a></h2>\u000a<code>func (t *StructType) NumField() int</code>\u000a<p>\u000aNumField returns the number of struct fields.\u000a</p>\u000a\u000a","name":"NumField"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructValue!\">StructValue</a></h2>\u000a<pre>type StructValue struct {\u000a\u0009value &#34;struct&#34;\u000a}</pre>\u000a<p>\u000aA StructValue represents a struct value.\u000a</p>\u000a\u000a","name":"StructValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.Field!\">Field</a></h2>\u000a<code>func (v *StructValue) Field(i int) Value</code>\u000a<p>\u000aField returns the i&#39;th field of the struct.\u000a</p>\u000a\u000a","name":"Field"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByIndex!\">FieldByIndex</a></h2>\u000a<code>func (t *StructValue) FieldByIndex(index []int) (v Value)</code>\u000a<p>\u000aFieldByIndex returns the nested field corresponding to index.\u000a</p>\u000a\u000a","name":"FieldByIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByName!\">FieldByName</a></h2>\u000a<code>func (t *StructValue) FieldByName(name string) Value</code>\u000a<p>\u000aFieldByName returns the struct field with the given name.\u000aThe result is nil if no field was found.\u000a</p>\u000a\u000a","name":"FieldByName"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByNameFunc!\">FieldByNameFunc</a></h2>\u000a<code>func (t *StructValue) FieldByNameFunc(match func(string) bool) Value</code>\u000a<p>\u000aFieldByNameFunc returns the struct field with a name that satisfies the\u000amatch function.\u000aThe result is nil if no field was found.\u000a</p>\u000a\u000a","name":"FieldByNameFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.NumField!\">NumField</a></h2>\u000a<code>func (v *StructValue) NumField() int</code>\u000a<p>\u000aNumField returns the number of fields in the struct.\u000a</p>\u000a\u000a","name":"NumField"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.Set!\">Set</a></h2>\u000a<code>func (v *StructValue) Set(x *StructValue)</code>\u000a<p>\u000aSet assigns x to v.\u000aThe new value x must have the same type as v.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *StructValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\u000a<pre>type Type interface {\u000a\u0009// PkgPath returns the type&#39;s package path.\u000a\u0009// The package path is a full package import path like &#34;container/vector&#34;.\u000a\u0009// PkgPath returns an empty string for unnamed types.\u000a\u0009PkgPath() string\u000a\u000a\u0009// Name returns the type&#39;s name within its package.\u000a\u0009// Name returns an empty string for unnamed types.\u000a\u0009Name() string\u000a\u000a\u0009// String returns a string representation of the type.\u000a\u0009// The string representation may use shortened package names\u000a\u0009// (e.g., vector instead of &#34;container/vector&#34;) and is not\u000a\u0009// guaranteed to be unique among types.  To test for equality,\u000a\u0009// compare the Types directly.\u000a\u0009String() string\u000a\u000a\u0009// Size returns the number of bytes needed to store\u000a\u0009// a value of the given type; it is analogous to unsafe.Sizeof.\u000a\u0009Size() uintptr\u000a\u000a\u0009// Bits returns the size of the type in bits.\u000a\u0009// It is intended for use with numeric types and may overflow\u000a\u0009// when used for composite types.\u000a\u0009Bits() int\u000a\u000a\u0009// Align returns the alignment of a value of this type\u000a\u0009// when allocated in memory.\u000a\u0009Align() int\u000a\u000a\u0009// FieldAlign returns the alignment of a value of this type\u000a\u0009// when used as a field in a struct.\u000a\u0009FieldAlign() int\u000a\u000a\u0009// Kind returns the specific kind of this type.\u000a\u0009Kind() Kind\u000a\u000a\u0009// For non-interface types, Method returns the i&#39;th method with receiver T.\u000a\u0009// For interface types, Method returns the i&#39;th method in the interface.\u000a\u0009// NumMethod returns the number of such methods.\u000a\u0009Method(int) Method\u000a\u0009NumMethod() int\u000a\u0009uncommon() *uncommonType\u000a}</pre>\u000a<p>\u000aType is the runtime representation of a Go type.\u000aEvery type implements the methods listed here.\u000aSome types implement additional interfaces;\u000ause a type switch to find out what kind of type a Type is.\u000aEach type in a program has a unique Type, so == on Types\u000acorresponds to Go&#39;s type equality.\u000a</p>\u000a\u000a","name":"Type","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintType!\">UintType</a></h2>\u000a<pre>type UintType struct {\u000a\u0009commonType &#34;uint&#34;\u000a}</pre>\u000a<p>\u000aUintType represents a uint type.\u000a</p>\u000a\u000a","name":"UintType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintValue!\">UintValue</a></h2>\u000a<pre>type UintValue struct {\u000a\u0009value &#34;uint&#34;\u000a}</pre>\u000a<p>\u000aUintValue represents a uint value.\u000a</p>\u000a\u000a","name":"UintValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Get!\">Get</a></h2>\u000a<code>func (v *UintValue) Get() uint64</code>\u000a<p>\u000aGet returns the underlying uuint value.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Overflow!\">Overflow</a></h2>\u000a<code>func (v *UintValue) Overflow(x uint64) bool</code>\u000a<p>\u000aOverflow returns true if x cannot be represented by the type of v.\u000a</p>\u000a\u000a","name":"Overflow"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Set!\">Set</a></h2>\u000a<code>func (v *UintValue) Set(x uint64)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *UintValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerType!\">UnsafePointerType</a></h2>\u000a<pre>type UnsafePointerType struct {\u000a\u0009commonType &#34;unsafe.Pointer&#34;\u000a}</pre>\u000a<p>\u000aUnsafePointerType represents an unsafe.Pointer type.\u000a</p>\u000a\u000a","name":"UnsafePointerType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerValue!\">UnsafePointerValue</a></h2>\u000a<pre>type UnsafePointerValue struct {\u000a\u0009value &#34;unsafe.Pointer&#34;\u000a}</pre>\u000a<p>\u000aUnsafePointerValue represents an unsafe.Pointer value.\u000a</p>\u000a\u000a","name":"UnsafePointerValue","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.Get!\">Get</a></h2>\u000a<code>func (v *UnsafePointerValue) Get() uintptr</code>\u000a<p>\u000aGet returns the underlying uintptr value.\u000aGet returns uintptr, not unsafe.Pointer, so that\u000aprograms that do not import &#34;unsafe&#34; cannot\u000aobtain a value of unsafe.Pointer type from &#34;reflect&#34;.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.Set!\">Set</a></h2>\u000a<code>func (v *UnsafePointerValue) Set(x unsafe.Pointer)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"Set"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.SetValue!\">SetValue</a></h2>\u000a<code>func (v *UnsafePointerValue) SetValue(x Value)</code>\u000a<p>\u000aSet sets v to the value x.\u000a</p>\u000a\u000a","name":"SetValue"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Value!\">Value</a></h2>\u000a<pre>type Value interface {\u000a\u0009// Type returns the value&#39;s type.\u000a\u0009Type() Type\u000a\u000a\u0009// Interface returns the value as an interface{}.\u000a\u0009Interface() interface{}\u000a\u000a\u0009// CanSet returns whether the value can be changed.\u000a\u0009// Values obtained by the use of non-exported struct fields\u000a\u0009// can be used in Get but not Set.\u000a\u0009// If CanSet() returns false, calling the type-specific Set\u000a\u0009// will cause a crash.\u000a\u0009CanSet() bool\u000a\u000a\u0009// SetValue assigns v to the value; v must have the same type as the value.\u000a\u0009SetValue(v Value)\u000a\u000a\u0009// Addr returns a pointer to the underlying data.\u000a\u0009// It is for advanced clients that also\u000a\u0009// import the &#34;unsafe&#34; package.\u000a\u0009Addr() uintptr\u000a\u000a\u0009// Method returns a FuncValue corresponding to the value&#39;s i&#39;th method.\u000a\u0009// The arguments to a Call on the returned FuncValue\u000a\u0009// should not include a receiver; the FuncValue will use\u000a\u0009// the value as the receiver.\u000a\u0009Method(i int) *FuncValue\u000a\u000a\u0009getAddr() addr\u000a}</pre>\u000a<p>\u000aValue is the common interface to reflection values.\u000aThe implementations of Value (e.g., ArrayValue, StructValue)\u000ahave additional type-specific methods.\u000a</p>\u000a\u000a","name":"Value","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ArrayCopy!\">ArrayCopy</a></h2>\u000a<code>func ArrayCopy(dst, src ArrayOrSliceValue) int</code>\u000a<p>\u000aArrayCopy copies the contents of src into dst until either\u000adst has been filled or src has been exhausted.\u000aIt returns the number of elements copied.\u000aThe arrays dst and src must have the same element type.\u000a</p>\u000a\u000a","name":"ArrayCopy"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DeepEqual!\">DeepEqual</a></h2>\u000a<code>func DeepEqual(a1, a2 interface{}) bool</code>\u000a<p>\u000aDeepEqual tests for deep equality. It uses normal == equality where possible\u000abut will scan members of arrays, slices, and fields of structs. It correctly\u000ahandles recursive types.\u000a</p>\u000a\u000a","name":"DeepEqual"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Indirect!\">Indirect</a></h2>\u000a<code>func Indirect(v Value) Value</code>\u000a<p>\u000aIndirect returns the value that v points to.\u000aIf v is a nil pointer, Indirect returns a nil Value.\u000aIf v is not a pointer, Indirect returns v.\u000a</p>\u000a\u000a","name":"Indirect"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeChan!\">MakeChan</a></h2>\u000a<code>func MakeChan(typ *ChanType, buffer int) *ChanValue</code>\u000a<p>\u000aMakeChan creates a new channel with the specified type and buffer size.\u000a</p>\u000a\u000a","name":"MakeChan"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeMap!\">MakeMap</a></h2>\u000a<code>func MakeMap(typ *MapType) *MapValue</code>\u000a<p>\u000aMakeMap creates a new map of the specified type.\u000a</p>\u000a\u000a","name":"MakeMap"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeSlice!\">MakeSlice</a></h2>\u000a<code>func MakeSlice(typ *SliceType, len, cap int) *SliceValue</code>\u000a<p>\u000aMakeSlice creates a new zero-initialized slice value\u000afor the specified slice type, length, and capacity.\u000a</p>\u000a\u000a","name":"MakeSlice"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeZero!\">MakeZero</a></h2>\u000a<code>func MakeZero(typ Type) Value</code>\u000a<p>\u000aMakeZero returns a zero Value for the specified Type.\u000a</p>\u000a\u000a","name":"MakeZero"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewValue!\">NewValue</a></h2>\u000a<code>func NewValue(i interface{}) Value</code>\u000a<p>\u000aNewValue returns a new Value initialized to the concrete value\u000astored in the interface i.  NewValue(nil) returns nil.\u000a</p>\u000a\u000a","name":"NewValue"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Typeof!\">Typeof</a></h2>\u000a<code>func Typeof(i interface{}) Type</code>\u000a<p>\u000aTypeof returns the reflection Type of the value in the interface{}.\u000a</p>\u000a\u000a","name":"Typeof"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\u000a<pre>const (\u000a\u0009RecvDir ChanDir = 1 &lt;&lt; iota\u000a\u0009SendDir\u000a\u0009BothDir = RecvDir | SendDir\u000a)</pre>\u000a\u000a","names":["RecvDir","SendDir","BothDir"],"type":"ChanDir"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Kind!\">Kind</a></h2>\u000a<pre>const (\u000a\u0009Bool Kind = 1 + iota\u000a\u0009Int\u000a\u0009Int8\u000a\u0009Int16\u000a\u0009Int32\u000a\u0009Int64\u000a\u0009Uint\u000a\u0009Uint8\u000a\u0009Uint16\u000a\u0009Uint32\u000a\u0009Uint64\u000a\u0009Uintptr\u000a\u0009Float\u000a\u0009Float32\u000a\u0009Float64\u000a\u0009Complex\u000a\u0009Complex64\u000a\u0009Complex128\u000a\u0009Array\u000a\u0009Chan\u000a\u0009Func\u000a\u0009Interface\u000a\u0009Map\u000a\u0009Ptr\u000a\u0009Slice\u000a\u0009String\u000a\u0009Struct\u000a\u0009UnsafePointer\u000a)</pre>\u000a\u000a","names":["Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float","Float32","Float64","Complex","Complex64","Complex128","Array","Chan","Func","Interface","Map","Ptr","Slice","String","Struct","UnsafePointer"],"type":"Kind"}],"vars":[]}