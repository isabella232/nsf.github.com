var gowtfData = {"html":"<p>\u000aThis package provides access to DWARF debugging information\u000aloaded from executable files, as defined in the DWARF 2.0 Standard\u000aat <a href=\"http://dwarfstd.org/doc/dwarf-2.0.0.pdf\">http://dwarfstd.org/doc/dwarf-2.0.0.pdf</a>\u000a</p>\u000a","name":"dwarf","filenames":["/home/nsf/go/src/pkg/debug/dwarf/buf.go","/home/nsf/go/src/pkg/debug/dwarf/entry.go","/home/nsf/go/src/pkg/debug/dwarf/open.go","/home/nsf/go/src/pkg/debug/dwarf/type.go","/home/nsf/go/src/pkg/debug/dwarf/unit.go","/home/nsf/go/src/pkg/debug/dwarf/const.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AddrType!\">AddrType</a></h2>\u000a<pre>type AddrType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aAn AddrType represents a machine address type.\u000a</p>\u000a\u000a","name":"AddrType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\u000a<pre>type ArrayType struct {\u000a\u0009CommonType\u000a\u0009Type          Type\u000a\u0009StrideBitSize int64 // if &gt; 0, number of bits to hold each element\u000a\u0009Count         int64 // if == -1, an incomplete array, like char x[].\u000a}</pre>\u000a<p>\u000aAn ArrayType represents a fixed size array type.\u000a</p>\u000a\u000a","name":"ArrayType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Size!\">Size</a></h2>\u000a<code>func (t *ArrayType) Size() int64</code>\u000a\u000a","name":"Size"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.String!\">String</a></h2>\u000a<code>func (t *ArrayType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Attr!\">Attr</a></h2>\u000a<pre>type Attr uint32</pre>\u000a<p>\u000aAn Attr identifies the attribute type in a DWARF Entry&#39;s Field.\u000a</p>\u000a\u000a","name":"Attr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Attr\">func (Attr)</a> <a href=\"?m:Attr.GoString!\">GoString</a></h2>\u000a<code>func (a Attr) GoString() string</code>\u000a\u000a","name":"GoString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Attr\">func (Attr)</a> <a href=\"?m:Attr.String!\">String</a></h2>\u000a<code>func (a Attr) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BasicType!\">BasicType</a></h2>\u000a<pre>type BasicType struct {\u000a\u0009CommonType\u000a\u0009BitSize   int64\u000a\u0009BitOffset int64\u000a}</pre>\u000a<p>\u000aA BasicType holds fields common to all basic types.\u000a</p>\u000a\u000a","name":"BasicType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:BasicType\">func (*BasicType)</a> <a href=\"?m:BasicType.Basic!\">Basic</a></h2>\u000a<code>func (b *BasicType) Basic() *BasicType</code>\u000a\u000a","name":"Basic"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:BasicType\">func (*BasicType)</a> <a href=\"?m:BasicType.String!\">String</a></h2>\u000a<code>func (t *BasicType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolType!\">BoolType</a></h2>\u000a<pre>type BoolType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA BoolType represents a boolean type.\u000a</p>\u000a\u000a","name":"BoolType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CharType!\">CharType</a></h2>\u000a<pre>type CharType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA CharType represents a signed character type.\u000a</p>\u000a\u000a","name":"CharType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommonType!\">CommonType</a></h2>\u000a<pre>type CommonType struct {\u000a\u0009ByteSize int64  // size of value of this type, in bytes\u000a\u0009Name     string // name that can be used to refer to type\u000a}</pre>\u000a<p>\u000aA CommonType holds fields common to multiple types.\u000aIf a field is not known or not applicable for a given type,\u000athe zero value is used.\u000a</p>\u000a\u000a","name":"CommonType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CommonType\">func (*CommonType)</a> <a href=\"?m:CommonType.Common!\">Common</a></h2>\u000a<code>func (c *CommonType) Common() *CommonType</code>\u000a\u000a","name":"Common"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:CommonType\">func (*CommonType)</a> <a href=\"?m:CommonType.Size!\">Size</a></h2>\u000a<code>func (c *CommonType) Size() int64</code>\u000a\u000a","name":"Size"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexType!\">ComplexType</a></h2>\u000a<pre>type ComplexType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA ComplexType represents a complex floating point type.\u000a</p>\u000a\u000a","name":"ComplexType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Data!\">Data</a></h2>\u000a<pre>type Data struct {\u000a\u0009// raw data\u000a\u0009abbrev   []byte\u000a\u0009aranges  []byte\u000a\u0009frame    []byte\u000a\u0009info     []byte\u000a\u0009line     []byte\u000a\u0009pubnames []byte\u000a\u0009ranges   []byte\u000a\u0009str      []byte\u000a\u000a\u0009// parsed data\u000a\u0009abbrevCache map[uint32]abbrevTable\u000a\u0009addrsize    int\u000a\u0009order       binary.ByteOrder\u000a\u0009typeCache   map[Offset]Type\u000a\u0009unit        []unit\u000a}</pre>\u000a<p>\u000aData represents the DWARF debugging information\u000aloaded from an executable file (for example, an ELF or Mach-O executable).\u000a</p>\u000a\u000a","name":"Data","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Data\">func (*Data)</a> <a href=\"?m:Data.Reader!\">Reader</a></h2>\u000a<code>func (d *Data) Reader() *Reader</code>\u000a<p>\u000aReader returns a new Reader for Data.\u000aThe reader is positioned at byte offset 0 in the DWARF &ldquo;info&rdquo; section.\u000a</p>\u000a\u000a","name":"Reader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Data\">func (*Data)</a> <a href=\"?m:Data.Type!\">Type</a></h2>\u000a<code>func (d *Data) Type(off Offset) (Type, os.Error)</code>\u000a\u000a","name":"Type"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DecodeError!\">DecodeError</a></h2>\u000a<pre>type DecodeError struct {\u000a\u0009Name   string\u000a\u0009Offset Offset\u000a\u0009Error  string\u000a}</pre>\u000a\u000a","name":"DecodeError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DecodeError\">func (DecodeError)</a> <a href=\"?m:DecodeError.String!\">String</a></h2>\u000a<code>func (e DecodeError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DotDotDotType!\">DotDotDotType</a></h2>\u000a<pre>type DotDotDotType struct {\u000a\u0009CommonType\u000a}</pre>\u000a<p>\u000aA DotDotDotType represents the variadic ... function parameter.\u000a</p>\u000a\u000a","name":"DotDotDotType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DotDotDotType\">func (*DotDotDotType)</a> <a href=\"?m:DotDotDotType.String!\">String</a></h2>\u000a<code>func (t *DotDotDotType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Entry!\">Entry</a></h2>\u000a<pre>type Entry struct {\u000a\u0009Offset   Offset // offset of Entry in DWARF info\u000a\u0009Tag      Tag    // tag (kind of Entry)\u000a\u0009Children bool   // whether Entry is followed by children\u000a\u0009Field    []Field\u000a}</pre>\u000a<p>\u000aAn entry is a sequence of attribute/value pairs.\u000a</p>\u000a\u000a","name":"Entry","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Entry\">func (*Entry)</a> <a href=\"?m:Entry.Val!\">Val</a></h2>\u000a<code>func (e *Entry) Val(a Attr) interface{}</code>\u000a<p>\u000aVal returns the value associated with attribute Attr in Entry,\u000aor nil if there is no such attribute.\u000a</p>\u000a<p>\u000aA common idiom is to merge the check for nil return with\u000athe check that the value has the expected dynamic type, as in:\u000a</p>\u000a<pre>v, ok := e.Val(AttrSibling).(int64);\u000a</pre>\u000a\u000a","name":"Val"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EnumType!\">EnumType</a></h2>\u000a<pre>type EnumType struct {\u000a\u0009CommonType\u000a\u0009EnumName string\u000a\u0009Val      []*EnumValue\u000a}</pre>\u000a<p>\u000aAn EnumType represents an enumerated type.\u000aThe only indication of its native integer type is its ByteSize\u000a(inside CommonType).\u000a</p>\u000a\u000a","name":"EnumType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:EnumType\">func (*EnumType)</a> <a href=\"?m:EnumType.String!\">String</a></h2>\u000a<code>func (t *EnumType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EnumValue!\">EnumValue</a></h2>\u000a<pre>type EnumValue struct {\u000a\u0009Name string\u000a\u0009Val  int64\u000a}</pre>\u000a<p>\u000aAn EnumValue represents a single enumeration value.\u000a</p>\u000a\u000a","name":"EnumValue","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Field!\">Field</a></h2>\u000a<pre>type Field struct {\u000a\u0009Attr Attr\u000a\u0009Val  interface{}\u000a}</pre>\u000a<p>\u000aA Field is a single attribute/value pair in an Entry.\u000a</p>\u000a\u000a","name":"Field","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatType!\">FloatType</a></h2>\u000a<pre>type FloatType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA FloatType represents a floating point type.\u000a</p>\u000a\u000a","name":"FloatType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\u000a<pre>type FuncType struct {\u000a\u0009CommonType\u000a\u0009ReturnType Type\u000a\u0009ParamType  []Type\u000a}</pre>\u000a<p>\u000aA FuncType represents a function type.\u000a</p>\u000a\u000a","name":"FuncType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.String!\">String</a></h2>\u000a<code>func (t *FuncType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntType!\">IntType</a></h2>\u000a<pre>type IntType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aAn IntType represents a signed integer type.\u000a</p>\u000a\u000a","name":"IntType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Offset!\">Offset</a></h2>\u000a<pre>type Offset uint32</pre>\u000a<p>\u000aAn Offset represents the location of an Entry within the DWARF info.\u000a(See Reader.Seek.)\u000a</p>\u000a\u000a","name":"Offset","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrType!\">PtrType</a></h2>\u000a<pre>type PtrType struct {\u000a\u0009CommonType\u000a\u0009Type Type\u000a}</pre>\u000a<p>\u000aA PtrType represents a pointer type.\u000a</p>\u000a\u000a","name":"PtrType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PtrType\">func (*PtrType)</a> <a href=\"?m:PtrType.String!\">String</a></h2>\u000a<code>func (t *PtrType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:QualType!\">QualType</a></h2>\u000a<pre>type QualType struct {\u000a\u0009CommonType\u000a\u0009Qual string\u000a\u0009Type Type\u000a}</pre>\u000a<p>\u000aA QualType represents a type that has the C/C++ &#34;const&#34;, &#34;restrict&#34;, or &#34;volatile&#34; qualifier.\u000a</p>\u000a\u000a","name":"QualType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:QualType\">func (*QualType)</a> <a href=\"?m:QualType.Size!\">Size</a></h2>\u000a<code>func (t *QualType) Size() int64</code>\u000a\u000a","name":"Size"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:QualType\">func (*QualType)</a> <a href=\"?m:QualType.String!\">String</a></h2>\u000a<code>func (t *QualType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\u000a<pre>type Reader struct {\u000a\u0009b            buf\u000a\u0009d            *Data\u000a\u0009err          os.Error\u000a\u0009unit         int\u000a\u0009lastChildren bool   // .Children of last entry returned by Next\u000a\u0009lastSibling  Offset // .Val(AttrSibling) of last entry returned by Next\u000a}</pre>\u000a<p>\u000aA Reader allows reading Entry structures from a DWARF &ldquo;info&rdquo; section.\u000aThe Entry structures are arranged in a tree.  The Reader&#39;s Next function\u000areturn successive entries from a pre-order traversal of the tree.\u000aIf an entry has children, its Children field will be true, and the children\u000afollow, terminated by an Entry with Tag 0.\u000a</p>\u000a\u000a","name":"Reader","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Next!\">Next</a></h2>\u000a<code>func (r *Reader) Next() (*Entry, os.Error)</code>\u000a<p>\u000aNext reads the next entry from the encoded entry stream.\u000aIt returns nil, nil when it reaches the end of the section.\u000aIt returns an error if the current offset is invalid or the data at the\u000aoffset cannot be decoded as a valid Entry.\u000a</p>\u000a\u000a","name":"Next"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Seek!\">Seek</a></h2>\u000a<code>func (r *Reader) Seek(off Offset)</code>\u000a<p>\u000aSeek positions the Reader at offset off in the encoded entry stream.\u000aOffset 0 can be used to denote the first entry.\u000a</p>\u000a\u000a","name":"Seek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.SkipChildren!\">SkipChildren</a></h2>\u000a<code>func (r *Reader) SkipChildren()</code>\u000a<p>\u000aSkipChildren skips over the child entries associated with\u000athe last Entry returned by Next.  If that Entry did not have\u000achildren or Next has not been called, SkipChildren is a no-op.\u000a</p>\u000a\u000a","name":"SkipChildren"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructField!\">StructField</a></h2>\u000a<pre>type StructField struct {\u000a\u0009Name       string\u000a\u0009Type       Type\u000a\u0009ByteOffset int64\u000a\u0009ByteSize   int64\u000a\u0009BitOffset  int64 // within the ByteSize bytes at ByteOffset\u000a\u0009BitSize    int64 // zero if not a bit field\u000a}</pre>\u000a<p>\u000aA StructField represents a field in a struct, union, or C++ class type.\u000a</p>\u000a\u000a","name":"StructField","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\u000a<pre>type StructType struct {\u000a\u0009CommonType\u000a\u0009StructName string\u000a\u0009Kind       string // &#34;struct&#34;, &#34;union&#34;, or &#34;class&#34;.\u000a\u0009Field      []*StructField\u000a\u0009Incomplete bool // if true, struct, union, class is declared but not defined\u000a}</pre>\u000a<p>\u000aA StructType represents a struct, union, or C++ class type.\u000a</p>\u000a\u000a","name":"StructType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.Defn!\">Defn</a></h2>\u000a<code>func (t *StructType) Defn() string</code>\u000a\u000a","name":"Defn"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.String!\">String</a></h2>\u000a<code>func (t *StructType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Tag!\">Tag</a></h2>\u000a<pre>type Tag uint32</pre>\u000a<p>\u000aA Tag is the classification (the type) of an Entry.\u000a</p>\u000a\u000a","name":"Tag","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Tag\">func (Tag)</a> <a href=\"?m:Tag.GoString!\">GoString</a></h2>\u000a<code>func (t Tag) GoString() string</code>\u000a\u000a","name":"GoString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Tag\">func (Tag)</a> <a href=\"?m:Tag.String!\">String</a></h2>\u000a<code>func (t Tag) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\u000a<pre>type Type interface {\u000a\u0009Common() *CommonType\u000a\u0009String() string\u000a\u0009Size() int64\u000a}</pre>\u000a<p>\u000aA Type conventionally represents a pointer to any of the\u000aspecific Type structures (CharType, StructType, etc.).\u000a</p>\u000a\u000a","name":"Type","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypedefType!\">TypedefType</a></h2>\u000a<pre>type TypedefType struct {\u000a\u0009CommonType\u000a\u0009Type Type\u000a}</pre>\u000a<p>\u000aA TypedefType represents a named type.\u000a</p>\u000a\u000a","name":"TypedefType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypedefType\">func (*TypedefType)</a> <a href=\"?m:TypedefType.Size!\">Size</a></h2>\u000a<code>func (t *TypedefType) Size() int64</code>\u000a\u000a","name":"Size"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypedefType\">func (*TypedefType)</a> <a href=\"?m:TypedefType.String!\">String</a></h2>\u000a<code>func (t *TypedefType) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UcharType!\">UcharType</a></h2>\u000a<pre>type UcharType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA UcharType represents an unsigned character type.\u000a</p>\u000a\u000a","name":"UcharType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintType!\">UintType</a></h2>\u000a<pre>type UintType struct {\u000a\u0009BasicType\u000a}</pre>\u000a<p>\u000aA UintType represents an unsigned integer type.\u000a</p>\u000a\u000a","name":"UintType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:VoidType!\">VoidType</a></h2>\u000a<pre>type VoidType struct {\u000a\u0009CommonType\u000a}</pre>\u000a<p>\u000aA VoidType represents the C void type.\u000a</p>\u000a\u000a","name":"VoidType","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:VoidType\">func (*VoidType)</a> <a href=\"?m:VoidType.String!\">String</a></h2>\u000a<code>func (t *VoidType) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:New!\">New</a></h2>\u000a<code>func New(abbrev, aranges, frame, info, line, pubnames, ranges, str []byte) (*Data, os.Error)</code>\u000a<p>\u000aNew returns a new Data object initialized from the given parameters.\u000aClients should typically use [TODO(rsc): method to be named later] instead of calling\u000aNew directly.\u000a</p>\u000a<p>\u000aThe []byte arguments are the data from the corresponding debug section\u000ain the object file; for example, for an ELF object, abbrev is the contents of\u000athe &#34;.debug_abbrev&#34; section.\u000a</p>\u000a\u000a","name":"New"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Attr!\">Attr</a></h2>\u000a<pre>const (\u000a\u0009AttrSibling        Attr = 0x01\u000a\u0009AttrLocation       Attr = 0x02\u000a\u0009AttrName           Attr = 0x03\u000a\u0009AttrOrdering       Attr = 0x09\u000a\u0009AttrByteSize       Attr = 0x0B\u000a\u0009AttrBitOffset      Attr = 0x0C\u000a\u0009AttrBitSize        Attr = 0x0D\u000a\u0009AttrStmtList       Attr = 0x10\u000a\u0009AttrLowpc          Attr = 0x11\u000a\u0009AttrHighpc         Attr = 0x12\u000a\u0009AttrLanguage       Attr = 0x13\u000a\u0009AttrDiscr          Attr = 0x15\u000a\u0009AttrDiscrValue     Attr = 0x16\u000a\u0009AttrVisibility     Attr = 0x17\u000a\u0009AttrImport         Attr = 0x18\u000a\u0009AttrStringLength   Attr = 0x19\u000a\u0009AttrCommonRef      Attr = 0x1A\u000a\u0009AttrCompDir        Attr = 0x1B\u000a\u0009AttrConstValue     Attr = 0x1C\u000a\u0009AttrContainingType Attr = 0x1D\u000a\u0009AttrDefaultValue   Attr = 0x1E\u000a\u0009AttrInline         Attr = 0x20\u000a\u0009AttrIsOptional     Attr = 0x21\u000a\u0009AttrLowerBound     Attr = 0x22\u000a\u0009AttrProducer       Attr = 0x25\u000a\u0009AttrPrototyped     Attr = 0x27\u000a\u0009AttrReturnAddr     Attr = 0x2A\u000a\u0009AttrStartScope     Attr = 0x2C\u000a\u0009AttrStrideSize     Attr = 0x2E\u000a\u0009AttrUpperBound     Attr = 0x2F\u000a\u0009AttrAbstractOrigin Attr = 0x31\u000a\u0009AttrAccessibility  Attr = 0x32\u000a\u0009AttrAddrClass      Attr = 0x33\u000a\u0009AttrArtificial     Attr = 0x34\u000a\u0009AttrBaseTypes      Attr = 0x35\u000a\u0009AttrCalling        Attr = 0x36\u000a\u0009AttrCount          Attr = 0x37\u000a\u0009AttrDataMemberLoc  Attr = 0x38\u000a\u0009AttrDeclColumn     Attr = 0x39\u000a\u0009AttrDeclFile       Attr = 0x3A\u000a\u0009AttrDeclLine       Attr = 0x3B\u000a\u0009AttrDeclaration    Attr = 0x3C\u000a\u0009AttrDiscrList      Attr = 0x3D\u000a\u0009AttrEncoding       Attr = 0x3E\u000a\u0009AttrExternal       Attr = 0x3F\u000a\u0009AttrFrameBase      Attr = 0x40\u000a\u0009AttrFriend         Attr = 0x41\u000a\u0009AttrIdentifierCase Attr = 0x42\u000a\u0009AttrMacroInfo      Attr = 0x43\u000a\u0009AttrNamelistItem   Attr = 0x44\u000a\u0009AttrPriority       Attr = 0x45\u000a\u0009AttrSegment        Attr = 0x46\u000a\u0009AttrSpecification  Attr = 0x47\u000a\u0009AttrStaticLink     Attr = 0x48\u000a\u0009AttrType           Attr = 0x49\u000a\u0009AttrUseLocation    Attr = 0x4A\u000a\u0009AttrVarParam       Attr = 0x4B\u000a\u0009AttrVirtuality     Attr = 0x4C\u000a\u0009AttrVtableElemLoc  Attr = 0x4D\u000a\u0009AttrAllocated      Attr = 0x4E\u000a\u0009AttrAssociated     Attr = 0x4F\u000a\u0009AttrDataLocation   Attr = 0x50\u000a\u0009AttrStride         Attr = 0x51\u000a\u0009AttrEntrypc        Attr = 0x52\u000a\u0009AttrUseUTF8        Attr = 0x53\u000a\u0009AttrExtension      Attr = 0x54\u000a\u0009AttrRanges         Attr = 0x55\u000a\u0009AttrTrampoline     Attr = 0x56\u000a\u0009AttrCallColumn     Attr = 0x57\u000a\u0009AttrCallFile       Attr = 0x58\u000a\u0009AttrCallLine       Attr = 0x59\u000a\u0009AttrDescription    Attr = 0x5A\u000a)</pre>\u000a\u000a","names":["AttrSibling","AttrLocation","AttrName","AttrOrdering","AttrByteSize","AttrBitOffset","AttrBitSize","AttrStmtList","AttrLowpc","AttrHighpc","AttrLanguage","AttrDiscr","AttrDiscrValue","AttrVisibility","AttrImport","AttrStringLength","AttrCommonRef","AttrCompDir","AttrConstValue","AttrContainingType","AttrDefaultValue","AttrInline","AttrIsOptional","AttrLowerBound","AttrProducer","AttrPrototyped","AttrReturnAddr","AttrStartScope","AttrStrideSize","AttrUpperBound","AttrAbstractOrigin","AttrAccessibility","AttrAddrClass","AttrArtificial","AttrBaseTypes","AttrCalling","AttrCount","AttrDataMemberLoc","AttrDeclColumn","AttrDeclFile","AttrDeclLine","AttrDeclaration","AttrDiscrList","AttrEncoding","AttrExternal","AttrFrameBase","AttrFriend","AttrIdentifierCase","AttrMacroInfo","AttrNamelistItem","AttrPriority","AttrSegment","AttrSpecification","AttrStaticLink","AttrType","AttrUseLocation","AttrVarParam","AttrVirtuality","AttrVtableElemLoc","AttrAllocated","AttrAssociated","AttrDataLocation","AttrStride","AttrEntrypc","AttrUseUTF8","AttrExtension","AttrRanges","AttrTrampoline","AttrCallColumn","AttrCallFile","AttrCallLine","AttrDescription"],"type":"Attr"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Tag!\">Tag</a></h2>\u000a<pre>const (\u000a\u0009TagArrayType              Tag = 0x01\u000a\u0009TagClassType              Tag = 0x02\u000a\u0009TagEntryPoint             Tag = 0x03\u000a\u0009TagEnumerationType        Tag = 0x04\u000a\u0009TagFormalParameter        Tag = 0x05\u000a\u0009TagImportedDeclaration    Tag = 0x08\u000a\u0009TagLabel                  Tag = 0x0A\u000a\u0009TagLexDwarfBlock          Tag = 0x0B\u000a\u0009TagMember                 Tag = 0x0D\u000a\u0009TagPointerType            Tag = 0x0F\u000a\u0009TagReferenceType          Tag = 0x10\u000a\u0009TagCompileUnit            Tag = 0x11\u000a\u0009TagStringType             Tag = 0x12\u000a\u0009TagStructType             Tag = 0x13\u000a\u0009TagSubroutineType         Tag = 0x15\u000a\u0009TagTypedef                Tag = 0x16\u000a\u0009TagUnionType              Tag = 0x17\u000a\u0009TagUnspecifiedParameters  Tag = 0x18\u000a\u0009TagVariant                Tag = 0x19\u000a\u0009TagCommonDwarfBlock       Tag = 0x1A\u000a\u0009TagCommonInclusion        Tag = 0x1B\u000a\u0009TagInheritance            Tag = 0x1C\u000a\u0009TagInlinedSubroutine      Tag = 0x1D\u000a\u0009TagModule                 Tag = 0x1E\u000a\u0009TagPtrToMemberType        Tag = 0x1F\u000a\u0009TagSetType                Tag = 0x20\u000a\u0009TagSubrangeType           Tag = 0x21\u000a\u0009TagWithStmt               Tag = 0x22\u000a\u0009TagAccessDeclaration      Tag = 0x23\u000a\u0009TagBaseType               Tag = 0x24\u000a\u0009TagCatchDwarfBlock        Tag = 0x25\u000a\u0009TagConstType              Tag = 0x26\u000a\u0009TagConstant               Tag = 0x27\u000a\u0009TagEnumerator             Tag = 0x28\u000a\u0009TagFileType               Tag = 0x29\u000a\u0009TagFriend                 Tag = 0x2A\u000a\u0009TagNamelist               Tag = 0x2B\u000a\u0009TagNamelistItem           Tag = 0x2C\u000a\u0009TagPackedType             Tag = 0x2D\u000a\u0009TagSubprogram             Tag = 0x2E\u000a\u0009TagTemplateTypeParameter  Tag = 0x2F\u000a\u0009TagTemplateValueParameter Tag = 0x30\u000a\u0009TagThrownType             Tag = 0x31\u000a\u0009TagTryDwarfBlock          Tag = 0x32\u000a\u0009TagVariantPart            Tag = 0x33\u000a\u0009TagVariable               Tag = 0x34\u000a\u0009TagVolatileType           Tag = 0x35\u000a\u0009TagDwarfProcedure         Tag = 0x36\u000a\u0009TagRestrictType           Tag = 0x37\u000a\u0009TagInterfaceType          Tag = 0x38\u000a\u0009TagNamespace              Tag = 0x39\u000a\u0009TagImportedModule         Tag = 0x3A\u000a\u0009TagUnspecifiedType        Tag = 0x3B\u000a\u0009TagPartialUnit            Tag = 0x3C\u000a\u0009TagImportedUnit           Tag = 0x3D\u000a\u0009TagMutableType            Tag = 0x3E\u000a)</pre>\u000a\u000a","names":["TagArrayType","TagClassType","TagEntryPoint","TagEnumerationType","TagFormalParameter","TagImportedDeclaration","TagLabel","TagLexDwarfBlock","TagMember","TagPointerType","TagReferenceType","TagCompileUnit","TagStringType","TagStructType","TagSubroutineType","TagTypedef","TagUnionType","TagUnspecifiedParameters","TagVariant","TagCommonDwarfBlock","TagCommonInclusion","TagInheritance","TagInlinedSubroutine","TagModule","TagPtrToMemberType","TagSetType","TagSubrangeType","TagWithStmt","TagAccessDeclaration","TagBaseType","TagCatchDwarfBlock","TagConstType","TagConstant","TagEnumerator","TagFileType","TagFriend","TagNamelist","TagNamelistItem","TagPackedType","TagSubprogram","TagTemplateTypeParameter","TagTemplateValueParameter","TagThrownType","TagTryDwarfBlock","TagVariantPart","TagVariable","TagVolatileType","TagDwarfProcedure","TagRestrictType","TagInterfaceType","TagNamespace","TagImportedModule","TagUnspecifiedType","TagPartialUnit","TagImportedUnit","TagMutableType"],"type":"Tag"}],"vars":[]}