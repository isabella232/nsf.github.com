var gowtfData = {"index":"index.html","html":"<p>\u000aA library for EBNF grammars. The input is text ([]byte) satisfying\u000athe following grammar (represented itself in EBNF):\u000a</p>\u000a<pre>Production  = name &#34;=&#34; Expression &#34;.&#34; .\u000aExpression  = Alternative { &#34;|&#34; Alternative } .\u000aAlternative = Term { Term } .\u000aTerm        = name | token [ &#34;...&#34; token ] | Group | Option | Repetition .\u000aGroup       = &#34;(&#34; Expression &#34;)&#34; .\u000aOption      = &#34;[&#34; Expression &#34;]&#34; .\u000aRepetition  = &#34;{&#34; Expression &#34;}&#34; .\u000a</pre>\u000a<p>\u000aA name is a Go identifier, a token is a Go string, and comments\u000aand white space follow the same rules as for the Go language.\u000aProduction names starting with an uppercase Unicode letter denote\u000anon-terminal productions (i.e., productions which allow white-space\u000aand comments between tokens); all other production names denote\u000alexical productions.\u000a</p>\u000a","name":"ebnf","filenames":["/home/nsf/go/src/pkg/ebnf/parser.go","/home/nsf/go/src/pkg/ebnf/ebnf.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alternative!\">Alternative</a></h2>\u000a<pre>type Alternative []Expression // x | y | z\u000a</pre>\u000a<p>\u000aAn Alternative node represents a non-empty list of alternative expressions.\u000a</p>\u000a\u000a","name":"Alternative","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Alternative\">func (Alternative)</a> <a href=\"?m:Alternative.Pos!\">Pos</a></h2>\u000a<code>func (x Alternative) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Expression!\">Expression</a></h2>\u000a<pre>type Expression interface {\u000a\u0009// Pos is the position of the first character of the syntactic construct\u000a\u0009Pos() token.Position\u000a}</pre>\u000a<p>\u000aAn Expression node represents a production expression.\u000a</p>\u000a\u000a","name":"Expression","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Grammar!\">Grammar</a></h2>\u000a<pre>type Grammar map[string]*Production</pre>\u000a<p>\u000aA Grammar is a set of EBNF productions. The map\u000ais indexed by production name.\u000a</p>\u000a\u000a","name":"Grammar","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Group!\">Group</a></h2>\u000a<pre>type Group struct {\u000a\u0009token.Position\u000a\u0009Body Expression // (body)\u000a}</pre>\u000a<p>\u000aA Group node represents a grouped expression.\u000a</p>\u000a\u000a","name":"Group","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\u000a<pre>type Name struct {\u000a\u0009token.Position\u000a\u0009String string\u000a}</pre>\u000a<p>\u000aA Name node represents a production name.\u000a</p>\u000a\u000a","name":"Name","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Option!\">Option</a></h2>\u000a<pre>type Option struct {\u000a\u0009token.Position\u000a\u0009Body Expression // [body]\u000a}</pre>\u000a<p>\u000aAn Option node represents an optional expression.\u000a</p>\u000a\u000a","name":"Option","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Production!\">Production</a></h2>\u000a<pre>type Production struct {\u000a\u0009Name *Name\u000a\u0009Expr Expression\u000a}</pre>\u000a<p>\u000aA Production node represents an EBNF production.\u000a</p>\u000a\u000a","name":"Production","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Production\">func (*Production)</a> <a href=\"?m:Production.Pos!\">Pos</a></h2>\u000a<code>func (p *Production) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Range!\">Range</a></h2>\u000a<pre>type Range struct {\u000a\u0009Begin, End *Token // begin ... end\u000a}</pre>\u000a<p>\u000aA List node represents a range of characters.\u000a</p>\u000a\u000a","name":"Range","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Range\">func (Range)</a> <a href=\"?m:Range.Pos!\">Pos</a></h2>\u000a<code>func (x Range) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Repetition!\">Repetition</a></h2>\u000a<pre>type Repetition struct {\u000a\u0009token.Position\u000a\u0009Body Expression // {body}\u000a}</pre>\u000a<p>\u000aA Repetition node represents a repeated expression.\u000a</p>\u000a\u000a","name":"Repetition","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Sequence!\">Sequence</a></h2>\u000a<pre>type Sequence []Expression // x y z\u000a</pre>\u000a<p>\u000aA Sequence node represents a non-empty list of sequential expressions.\u000a</p>\u000a\u000a","name":"Sequence","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Sequence\">func (Sequence)</a> <a href=\"?m:Sequence.Pos!\">Pos</a></h2>\u000a<code>func (x Sequence) Pos() token.Position</code>\u000a\u000a","name":"Pos"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Token!\">Token</a></h2>\u000a<pre>type Token struct {\u000a\u0009token.Position\u000a\u0009String string\u000a}</pre>\u000a<p>\u000aA Token node represents a literal.\u000a</p>\u000a\u000a","name":"Token","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\u000a<code>func Parse(filename string, src []byte) (Grammar, os.Error)</code>\u000a<p>\u000aParse parses a set of EBNF productions from source src.\u000aIt returns a set of productions. Errors are reported\u000afor incorrect syntax and if a production is declared\u000amore than once.\u000a</p>\u000a\u000a","name":"Parse"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Verify!\">Verify</a></h2>\u000a<code>func Verify(grammar Grammar, start string) os.Error</code>\u000a<p>\u000aVerify checks that:\u000a</p>\u000a<pre>- all productions used are defined\u000a- all productions defined are used when beginning at start\u000a- lexical productions refer only to other lexical productions\u000a</pre>\u000a\u000a","name":"Verify"}],"consts":[],"vars":[]}