var gowtfData = {"index":"index.html","html":"<p>\u000aThis package implements hexadecimal encoding and decoding.\u000a</p>\u000a","name":"hex","filenames":["/home/nsf/go/src/pkg/encoding/hex/hex.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidHexCharError!\">InvalidHexCharError</a></h2>\u000a<pre>type InvalidHexCharError byte</pre>\u000a<p>\u000aInvalidHexCharError results from finding an invalid character in a hex string.\u000a</p>\u000a\u000a","name":"InvalidHexCharError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidHexCharError\">func (InvalidHexCharError)</a> <a href=\"?m:InvalidHexCharError.String!\">String</a></h2>\u000a<code>func (e InvalidHexCharError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:OddLengthInputError!\">OddLengthInputError</a></h2>\u000a<pre>type OddLengthInputError struct{}</pre>\u000a<p>\u000aOddLengthInputError results from decoding an odd length slice.\u000a</p>\u000a\u000a","name":"OddLengthInputError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:OddLengthInputError\">func (OddLengthInputError)</a> <a href=\"?m:OddLengthInputError.String!\">String</a></h2>\u000a<code>func (OddLengthInputError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Decode!\">Decode</a></h2>\u000a<code>func Decode(dst, src []byte) (int, os.Error)</code>\u000a<p>\u000aDecode decodes src into DecodedLen(len(src)) bytes, returning the actual\u000anumber of bytes written to dst.\u000a</p>\u000a<p>\u000aIf Decode encounters invalid input, it returns an OddLengthInputError or an\u000aInvalidHexCharError.\u000a</p>\u000a\u000a","name":"Decode"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeString!\">DecodeString</a></h2>\u000a<code>func DecodeString(s string) ([]byte, os.Error)</code>\u000a<p>\u000aDecodeString returns the bytes represented by the hexadecimal string s.\u000a</p>\u000a\u000a","name":"DecodeString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodedLen!\">DecodedLen</a></h2>\u000a<code>func DecodedLen(x int) int</code>\u000a\u000a","name":"DecodedLen"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Encode!\">Encode</a></h2>\u000a<code>func Encode(dst, src []byte) int</code>\u000a<p>\u000aEncode encodes src into EncodedLen(len(src))\u000abytes of dst.  As a convenience, it returns the number\u000aof bytes written to dst, but this value is always EncodedLen(len(src)).\u000aEncode implements hexadecimal encoding.\u000a</p>\u000a\u000a","name":"Encode"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodeToString!\">EncodeToString</a></h2>\u000a<code>func EncodeToString(src []byte) string</code>\u000a<p>\u000aEncodeToString returns the hexadecimal encoding of src.\u000a</p>\u000a\u000a","name":"EncodeToString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodedLen!\">EncodedLen</a></h2>\u000a<code>func EncodedLen(n int) int</code>\u000a<p>\u000aEncodedLen returns the length of an encoding of n source bytes.\u000a</p>\u000a\u000a","name":"EncodedLen"}],"consts":[],"vars":[]}