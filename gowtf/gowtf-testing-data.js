var gowtfData = {"html":"<p>\u000aThe testing package provides support for automated testing of Go packages.\u000aIt is intended to be used in concert with the &ldquo;gotest&rdquo; utility, which automates\u000aexecution of any function of the form\u000a</p>\u000a<pre>func TestXxx(*testing.T)\u000a</pre>\u000a<p>\u000awhere Xxx can be any alphanumeric string (but the first letter must not be in\u000a[a-z]) and serves to identify the test routine.\u000aThese TestXxx routines should be declared within the package they are testing.\u000a</p>\u000a<p>\u000aFunctions of the form\u000a</p>\u000a<pre>func BenchmarkXxx(*testing.B)\u000a</pre>\u000a<p>\u000aare considered benchmarks, and are executed by gotest when the -benchmarks\u000aflag is provided.\u000a</p>\u000a<p>\u000aA sample benchmark function looks like this:\u000a</p>\u000a<pre>func BenchmarkHello(b *testing.B) {\u000a    for i := 0; i &lt; b.N; i++ {\u000a        fmt.Sprintf(&#34;hello&#34;)\u000a    }\u000a}\u000a</pre>\u000a<p>\u000aThe benchmark package will vary b.N until the benchmark function lasts\u000along enough to be timed reliably.  The output\u000a</p>\u000a<pre>testing.BenchmarkHello\u0009500000\u0009      4076 ns/op\u000a</pre>\u000a<p>\u000ameans that the loop ran 500000 times at a speed of 4076 ns per loop.\u000a</p>\u000a<p>\u000aIf a benchmark needs some expensive setup before running, the timer\u000amay be stopped:\u000a</p>\u000a<pre>func BenchmarkBigLen(b *testing.B) {\u000a    b.StopTimer()\u000a    big := NewBig()\u000a    b.StartTimer()\u000a    for i := 0; i &lt; b.N; i++ {\u000a        big.Len()\u000a    }\u000a}\u000a</pre>\u000a","name":"testing","filenames":["/home/nsf/go/src/pkg/testing/testing.go","/home/nsf/go/src/pkg/testing/benchmark.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:B!\">B</a></h2>\u000a<pre>type B struct {\u000a\u0009N         int\u000a\u0009benchmark Benchmark\u000a\u0009ns        int64\u000a\u0009bytes     int64\u000a\u0009start     int64\u000a}</pre>\u000a<p>\u000aB is a type passed to Benchmark functions to manage benchmark\u000atiming and to specify the number of iterations to run.\u000a</p>\u000a\u000a","name":"B","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.ResetTimer!\">ResetTimer</a></h2>\u000a<code>func (b *B) ResetTimer()</code>\u000a<p>\u000aResetTimer stops the timer and sets the elapsed benchmark time to zero.\u000a</p>\u000a\u000a","name":"ResetTimer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.SetBytes!\">SetBytes</a></h2>\u000a<code>func (b *B) SetBytes(n int64)</code>\u000a<p>\u000aSetBytes records the number of bytes processed in a single operation.\u000aIf this is called, the benchmark will report ns/op and MB/s.\u000a</p>\u000a\u000a","name":"SetBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.StartTimer!\">StartTimer</a></h2>\u000a<code>func (b *B) StartTimer()</code>\u000a<p>\u000aStartTimer starts timing a test.  This function is called automatically\u000abefore a benchmark starts, but it can also used to resume timing after\u000aa call to StopTimer.\u000a</p>\u000a\u000a","name":"StartTimer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.StopTimer!\">StopTimer</a></h2>\u000a<code>func (b *B) StopTimer()</code>\u000a<p>\u000aStopTimer stops timing a test.  This can be used to pause the timer\u000awhile performing complex initialization that you don&#39;t\u000awant to measure.\u000a</p>\u000a\u000a","name":"StopTimer"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Benchmark!\">Benchmark</a></h2>\u000a<pre>type Benchmark struct {\u000a\u0009Name string\u000a\u0009F    func(b *B)\u000a}</pre>\u000a<p>\u000aAn internal type but exported because it is cross-package; part of the implementation\u000aof gotest.\u000a</p>\u000a\u000a","name":"Benchmark","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:T!\">T</a></h2>\u000a<pre>type T struct {\u000a\u0009errors string\u000a\u0009failed bool\u000a\u0009ch     chan *T\u000a}</pre>\u000a<p>\u000aT is a type passed to Test functions to manage test state and support formatted test logs.\u000aLogs are accumulated during execution and dumped to standard error when done.\u000a</p>\u000a\u000a","name":"T","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Error!\">Error</a></h2>\u000a<code>func (t *T) Error(args ...interface{})</code>\u000a<p>\u000aError is equivalent to Log() followed by Fail().\u000a</p>\u000a\u000a","name":"Error"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Errorf!\">Errorf</a></h2>\u000a<code>func (t *T) Errorf(format string, args ...interface{})</code>\u000a<p>\u000aErrorf is equivalent to Logf() followed by Fail().\u000a</p>\u000a\u000a","name":"Errorf"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fail!\">Fail</a></h2>\u000a<code>func (t *T) Fail()</code>\u000a<p>\u000aFail marks the Test function as having failed but continues execution.\u000a</p>\u000a\u000a","name":"Fail"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.FailNow!\">FailNow</a></h2>\u000a<code>func (t *T) FailNow()</code>\u000a<p>\u000aFailNow marks the Test function as having failed and stops its execution.\u000aExecution will continue at the next Test.\u000a</p>\u000a\u000a","name":"FailNow"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Failed!\">Failed</a></h2>\u000a<code>func (t *T) Failed() bool</code>\u000a<p>\u000aFailed returns whether the Test function has failed.\u000a</p>\u000a\u000a","name":"Failed"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fatal!\">Fatal</a></h2>\u000a<code>func (t *T) Fatal(args ...interface{})</code>\u000a<p>\u000aFatal is equivalent to Log() followed by FailNow().\u000a</p>\u000a\u000a","name":"Fatal"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fatalf!\">Fatalf</a></h2>\u000a<code>func (t *T) Fatalf(format string, args ...interface{})</code>\u000a<p>\u000aFatalf is equivalent to Logf() followed by FailNow().\u000a</p>\u000a\u000a","name":"Fatalf"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Log!\">Log</a></h2>\u000a<code>func (t *T) Log(args ...interface{})</code>\u000a<p>\u000aLog formats its arguments using default formatting, analogous to Print(),\u000aand records the text in the error log.\u000a</p>\u000a\u000a","name":"Log"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Logf!\">Logf</a></h2>\u000a<code>func (t *T) Logf(format string, args ...interface{})</code>\u000a<p>\u000aLog formats its arguments according to the format, analogous to Printf(),\u000aand records the text in the error log.\u000a</p>\u000a\u000a","name":"Logf"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Test!\">Test</a></h2>\u000a<pre>type Test struct {\u000a\u0009Name string\u000a\u0009F    func(*T)\u000a}</pre>\u000a<p>\u000aAn internal type but exported because it is cross-package; part of the implementation\u000aof gotest.\u000a</p>\u000a\u000a","name":"Test","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Main!\">Main</a></h2>\u000a<code>func Main(matchString func(pat, str string) (bool, os.Error), tests []Test)</code>\u000a<p>\u000aAn internal function but exported because it is cross-package; part of the implementation\u000aof gotest.\u000a</p>\u000a\u000a","name":"Main"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RunBenchmarks!\">RunBenchmarks</a></h2>\u000a<code>func RunBenchmarks(matchString func(pat, str string) (bool, os.Error), benchmarks []Benchmark)</code>\u000a<p>\u000aAn internal function but exported because it is cross-package; part of the implementation\u000aof gotest.\u000a</p>\u000a\u000a","name":"RunBenchmarks"}],"consts":[],"vars":[]}