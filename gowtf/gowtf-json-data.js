var gowtfData = {"index":"index.html","html":"<p>\u000aThe json package implements encoding and decoding of JSON objects as\u000adefined in RFC 4627.\u000a</p>\u000a","name":"json","filenames":["/home/nsf/go/src/pkg/json/decode.go","/home/nsf/go/src/pkg/json/encode.go","/home/nsf/go/src/pkg/json/indent.go","/home/nsf/go/src/pkg/json/scanner.go","/home/nsf/go/src/pkg/json/stream.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decoder!\">Decoder</a></h2>\u000a<pre>type Decoder struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Decoder reads and decodes JSON objects from an input stream.\u000a</p>\u000a\u000a","name":"Decoder","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.Decode!\">Decode</a></h2>\u000a<code>func (dec *Decoder) Decode(v interface{}) os.Error</code>\u000a<p>\u000aDecode reads the next JSON-encoded value from the\u000aconnection and stores it in the value pointed to by v.\u000a</p>\u000a<p>\u000aSee the documentation for Unmarshal for details about\u000athe conversion of JSON into a Go value.\u000a</p>\u000a\u000a","name":"Decode"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Encoder!\">Encoder</a></h2>\u000a<pre>type Encoder struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aAn Encoder writes JSON objects to an output stream.\u000a</p>\u000a\u000a","name":"Encoder","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.Encode!\">Encode</a></h2>\u000a<code>func (enc *Encoder) Encode(v interface{}) os.Error</code>\u000a<p>\u000aEncode writes the JSON encoding of v to the connection.\u000a</p>\u000a<p>\u000aSee the documentation for Marshal for details about the\u000aconversion of Go values to JSON.\u000a</p>\u000a\u000a","name":"Encode"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidUnmarshalError!\">InvalidUnmarshalError</a></h2>\u000a<pre>type InvalidUnmarshalError struct {\u000a\u0009Type reflect.Type\u000a}</pre>\u000a<p>\u000aAn InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\u000a(The argument to Unmarshal must be a non-nil pointer.)\u000a</p>\u000a\u000a","name":"InvalidUnmarshalError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidUnmarshalError\">func (*InvalidUnmarshalError)</a> <a href=\"?m:InvalidUnmarshalError.String!\">String</a></h2>\u000a<code>func (e *InvalidUnmarshalError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Marshaler!\">Marshaler</a></h2>\u000a<pre>type Marshaler interface {\u000a\u0009MarshalJSON() ([]byte, os.Error)\u000a}</pre>\u000a<p>\u000aMarshaler is the interface implemented by objects that\u000acan marshal themselves into valid JSON.\u000a</p>\u000a\u000a","name":"Marshaler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MarshalerError!\">MarshalerError</a></h2>\u000a<pre>type MarshalerError struct {\u000a\u0009Type  reflect.Type\u000a\u0009Error os.Error\u000a}</pre>\u000a\u000a","name":"MarshalerError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:MarshalerError\">func (*MarshalerError)</a> <a href=\"?m:MarshalerError.String!\">String</a></h2>\u000a<code>func (e *MarshalerError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawMessage!\">RawMessage</a></h2>\u000a<pre>type RawMessage []byte</pre>\u000a<p>\u000aRawMessage is a raw encoded JSON object.\u000aIt implements Marshaler and Unmarshaler and can\u000abe used to delay JSON decoding or precompute a JSON encoding.\u000a</p>\u000a\u000a","name":"RawMessage","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RawMessage\">func (*RawMessage)</a> <a href=\"?m:RawMessage.MarshalJSON!\">MarshalJSON</a></h2>\u000a<code>func (m *RawMessage) MarshalJSON() ([]byte, os.Error)</code>\u000a<p>\u000aMarshalJSON returns *m as the JSON encoding of m.\u000a</p>\u000a\u000a","name":"MarshalJSON"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:RawMessage\">func (*RawMessage)</a> <a href=\"?m:RawMessage.UnmarshalJSON!\">UnmarshalJSON</a></h2>\u000a<code>func (m *RawMessage) UnmarshalJSON(data []byte) os.Error</code>\u000a<p>\u000aUnmarshalJSON sets *m to a copy of data.\u000a</p>\u000a\u000a","name":"UnmarshalJSON"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SyntaxError!\">SyntaxError</a></h2>\u000a<pre>type SyntaxError string</pre>\u000a<p>\u000aA SyntaxError is a description of a JSON syntax error.\u000a</p>\u000a\u000a","name":"SyntaxError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SyntaxError\">func (SyntaxError)</a> <a href=\"?m:SyntaxError.String!\">String</a></h2>\u000a<code>func (e SyntaxError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnmarshalFieldError!\">UnmarshalFieldError</a></h2>\u000a<pre>type UnmarshalFieldError struct {\u000a\u0009Key   string\u000a\u0009Type  *reflect.StructType\u000a\u0009Field reflect.StructField\u000a}</pre>\u000a<p>\u000aAn UnmarshalFieldError describes a JSON object key that\u000aled to an unexported (and therefore unwritable) struct field.\u000a</p>\u000a\u000a","name":"UnmarshalFieldError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnmarshalFieldError\">func (*UnmarshalFieldError)</a> <a href=\"?m:UnmarshalFieldError.String!\">String</a></h2>\u000a<code>func (e *UnmarshalFieldError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnmarshalTypeError!\">UnmarshalTypeError</a></h2>\u000a<pre>type UnmarshalTypeError struct {\u000a\u0009Value string       // description of JSON value - &#34;bool&#34;, &#34;array&#34;, &#34;number -5&#34;\u000a\u0009Type  reflect.Type // type of Go value it could not be assigned to\u000a}</pre>\u000a<p>\u000aAn UnmarshalTypeError describes a JSON value that was\u000anot appropriate for a value of a specific Go type.\u000a</p>\u000a\u000a","name":"UnmarshalTypeError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnmarshalTypeError\">func (*UnmarshalTypeError)</a> <a href=\"?m:UnmarshalTypeError.String!\">String</a></h2>\u000a<code>func (e *UnmarshalTypeError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Unmarshaler!\">Unmarshaler</a></h2>\u000a<pre>type Unmarshaler interface {\u000a\u0009UnmarshalJSON([]byte) os.Error\u000a}</pre>\u000a<p>\u000aUnmarshaler is the interface implemented by objects\u000athat can unmarshal a JSON description of themselves.\u000aThe input can be assumed to be a valid JSON object\u000aencoding.  UnmarshalJSON must copy the JSON data\u000aif it wishes to retain the data after returning.\u000a</p>\u000a\u000a","name":"Unmarshaler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsupportedTypeError!\">UnsupportedTypeError</a></h2>\u000a<pre>type UnsupportedTypeError struct {\u000a\u0009Type reflect.Type\u000a}</pre>\u000a\u000a","name":"UnsupportedTypeError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnsupportedTypeError\">func (*UnsupportedTypeError)</a> <a href=\"?m:UnsupportedTypeError.String!\">String</a></h2>\u000a<code>func (e *UnsupportedTypeError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Compact!\">Compact</a></h2>\u000a<code>func Compact(dst *bytes.Buffer, src []byte) os.Error</code>\u000a<p>\u000aCompact appends to dst the JSON-encoded src with\u000ainsignificant space characters elided.\u000a</p>\u000a\u000a","name":"Compact"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HTMLEscape!\">HTMLEscape</a></h2>\u000a<code>func HTMLEscape(dst *bytes.Buffer, src []byte)</code>\u000a<p>\u000aHTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, and &amp;\u000acharacters inside string literals changed to \\u003c, \\u003e, \\u0026\u000aso that the JSON will be safe to embed inside HTML &lt;script&gt; tags.\u000aFor historical reasons, web browsers don&#39;t honor standard HTML\u000aescaping within &lt;script&gt; tags, so an alternative JSON encoding must\u000abe used.\u000a</p>\u000a\u000a","name":"HTMLEscape"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Indent!\">Indent</a></h2>\u000a<code>func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) os.Error</code>\u000a<p>\u000aIndent appends to dst an indented form of the JSON-encoded src.\u000aEach element in a JSON object or array begins on a new,\u000aindented line beginning with prefix followed by one or more\u000acopies of indent according to the indentation nesting.\u000aThe data appended to dst has no trailing newline, to make it easier\u000ato embed inside other formatted JSON data.\u000a</p>\u000a\u000a","name":"Indent"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Marshal!\">Marshal</a></h2>\u000a<code>func Marshal(v interface{}) ([]byte, os.Error)</code>\u000a<p>\u000aMarshal returns the JSON encoding of v.\u000a</p>\u000a<p>\u000aMarshal traverses the value v recursively.\u000aIf an encountered value implements the Marshaler interface,\u000aMarshal calls its MarshalJSON method to produce JSON.\u000a</p>\u000a<p>\u000aOtherwise, Marshal uses the following type-dependent default encodings:\u000a</p>\u000a<p>\u000aBoolean values encode as JSON booleans.\u000a</p>\u000a<p>\u000aFloating point and integer values encode as JSON numbers.\u000a</p>\u000a<p>\u000aString values encode as JSON strings, with each invalid UTF-8 sequence\u000areplaced by the encoding of the Unicode replacement character U+FFFD.\u000a</p>\u000a<p>\u000aArray and slice values encode as JSON arrays.\u000a</p>\u000a<p>\u000aStruct values encode as JSON objects.  Each struct field becomes\u000aa member of the object.  By default the object&#39;s key name is the\u000astruct field name converted to lower case.  If the struct field\u000ahas a tag, that tag will be used as the name instead.\u000a</p>\u000a<p>\u000aMap values encode as JSON objects.\u000aThe map&#39;s key type must be string; the object keys are used directly\u000aas map keys.\u000a</p>\u000a<p>\u000aPointer values encode as the value pointed to.\u000aA nil pointer encodes as the null JSON object.\u000a</p>\u000a<p>\u000aInterface values encode as the value contained in the interface.\u000aA nil interface value encodes as the null JSON object.\u000a</p>\u000a<p>\u000aChannel, complex, and function values cannot be encoded in JSON.\u000aAttempting to encode such a value causes Marshal to return\u000aan InvalidTypeError.\u000a</p>\u000a<p>\u000aJSON cannot represent cyclic data structures and Marshal does not\u000ahandle them.  Passing cyclic structures to Marshal will result in\u000aan infinite recursion.\u000a</p>\u000a\u000a","name":"Marshal"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalForHTML!\">MarshalForHTML</a></h2>\u000a<code>func MarshalForHTML(v interface{}) ([]byte, os.Error)</code>\u000a<p>\u000aMarshalForHTML is like Marshal but applies HTMLEscape to the output.\u000a</p>\u000a\u000a","name":"MarshalForHTML"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalIndent!\">MarshalIndent</a></h2>\u000a<code>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, os.Error)</code>\u000a<p>\u000aMarshalIndent is like Marshal but applies Indent to format the output.\u000a</p>\u000a\u000a","name":"MarshalIndent"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewDecoder!\">NewDecoder</a></h2>\u000a<code>func NewDecoder(r io.Reader) *Decoder</code>\u000a<p>\u000aNewDecoder returns a new decoder that reads from r.\u000a</p>\u000a\u000a","name":"NewDecoder"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEncoder!\">NewEncoder</a></h2>\u000a<code>func NewEncoder(w io.Writer) *Encoder</code>\u000a<p>\u000aNewEncoder returns a new encoder that writes to w.\u000a</p>\u000a\u000a","name":"NewEncoder"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Unmarshal!\">Unmarshal</a></h2>\u000a<code>func Unmarshal(data []byte, v interface{}) os.Error</code>\u000a<p>\u000aUnmarshal parses the JSON-encoded data and stores the result\u000ain the value pointed to by v.\u000a</p>\u000a<p>\u000aUnmarshal traverses the value v recursively.\u000aIf an encountered value implements the Unmarshaler interface,\u000aUnmarshal calls its UnmarshalJSON method with a well-formed\u000aJSON encoding.\u000a</p>\u000a<p>\u000aOtherwise, Unmarshal uses the inverse of the encodings that\u000aMarshal uses, allocating maps, slices, and pointers as necessary,\u000awith the following additional rules:\u000a</p>\u000a<p>\u000aTo unmarshal a JSON value into a nil interface value, the\u000atype stored in the interface value is one of:\u000a</p>\u000a<pre>bool, for JSON booleans\u000afloat64, for JSON numbers\u000astring, for JSON strings\u000a[]interface{}, for JSON arrays\u000amap[string]interface{}, for JSON objects\u000anil for JSON null\u000a</pre>\u000a<p>\u000aIf a JSON value is not appropriate for a given target type,\u000aor if a JSON number overflows the target type, Unmarshal\u000askips that field and completes the unmarshalling as best it can.\u000aIf no more serious errors are encountered, Unmarshal returns\u000aan UnmarshalTypeError describing the earliest such error.\u000a</p>\u000a\u000a","name":"Unmarshal"}],"consts":[],"vars":[]}