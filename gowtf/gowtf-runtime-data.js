var gowtfData = {"index":"index.html","html":"<p>\u000aThe runtime package contains operations that interact with Go&#39;s runtime system,\u000asuch as functions to control goroutines. It also includes the low-level type information\u000aused by the reflect package; see reflect&#39;s documentation for the programmable\u000ainterface to the run-time type system.\u000a</p>\u000a","name":"runtime","filenames":["/home/nsf/go/src/pkg/runtime/error.go","/home/nsf/go/src/pkg/runtime/softfloat64.go","/home/nsf/go/src/pkg/runtime/debug.go","/home/nsf/go/src/pkg/runtime/version.go","/home/nsf/go/src/pkg/runtime/sig.go","/home/nsf/go/src/pkg/runtime/type.go","/home/nsf/go/src/pkg/runtime/extern.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\u000a<pre>type ArrayType struct {\u000a\u0009commonType\u000a\u0009elem *Type // array element type\u000a\u0009len  uintptr\u000a}</pre>\u000a<p>\u000aArrayType represents a fixed array type.\u000a</p>\u000a\u000a","name":"ArrayType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolType!\">BoolType</a></h2>\u000a<pre>type BoolType commonType</pre>\u000a<p>\u000aBoolType represents a boolean type.\u000a</p>\u000a\u000a","name":"BoolType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\u000a<pre>type ChanDir int</pre>\u000a<p>\u000aChanDir represents a channel type&#39;s direction.\u000a</p>\u000a\u000a","name":"ChanDir","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\u000a<pre>type ChanType struct {\u000a\u0009commonType\u000a\u0009elem *Type   // channel element type\u000a\u0009dir  uintptr // channel direction (ChanDir)\u000a}</pre>\u000a<p>\u000aChanType represents a channel type.\u000a</p>\u000a\u000a","name":"ChanType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexType!\">ComplexType</a></h2>\u000a<pre>type ComplexType commonType</pre>\u000a<p>\u000aComplexType represents a complex type.\u000a</p>\u000a\u000a","name":"ComplexType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error interface {\u000a\u0009String() string\u000a\u000a\u0009// RuntimeError is a no-op function but\u000a\u0009// serves to distinguish types that are runtime\u000a\u0009// errors from ordinary os.Errors: a type is a\u000a\u0009// runtime error if it has a RuntimeError method.\u000a\u0009RuntimeError()\u000a}</pre>\u000a<p>\u000aThe Error interface identifies a run time error.\u000a</p>\u000a\u000a","name":"Error","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatType!\">FloatType</a></h2>\u000a<pre>type FloatType commonType</pre>\u000a<p>\u000aFloatType represents a float type.\u000a</p>\u000a\u000a","name":"FloatType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Func!\">Func</a></h2>\u000a<pre>type Func struct {\u000a\u0009name   string\u000a\u0009typ    string\u000a\u0009src    string\u000a\u0009pcln   []byte\u000a\u0009entry  uintptr\u000a\u0009pc0    uintptr\u000a\u0009ln0    int32\u000a\u0009frame  int32\u000a\u0009args   int32\u000a\u0009locals int32\u000a}</pre>\u000a<p>\u000aFunc records information about a function in the program,\u000ain particular  the mapping from program counters to source\u000aline numbers within that function.\u000a</p>\u000a\u000a","name":"Func","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.Entry!\">Entry</a></h2>\u000a<code>func (f *Func) Entry() uintptr</code>\u000a<p>\u000aEntry returns the entry address of the function.\u000a</p>\u000a\u000a","name":"Entry"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.FileLine!\">FileLine</a></h2>\u000a<code>func (f *Func) FileLine(pc uintptr) (file string, line int)</code>\u000a<p>\u000aFileLine returns the file name and line number of the\u000asource code corresponding to the program counter pc.\u000aThe result will not be accurate if pc is not a program\u000acounter within f.\u000a</p>\u000a\u000a","name":"FileLine"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.Name!\">Name</a></h2>\u000a<code>func (f *Func) Name() string</code>\u000a<p>\u000aName returns the name of the function.\u000a</p>\u000a\u000a","name":"Name"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\u000a<pre>type FuncType struct {\u000a\u0009commonType\u000a\u0009dotdotdot bool    // last input parameter is ...\u000a\u0009in        []*Type // input parameter types\u000a\u0009out       []*Type // output parameter types\u000a}</pre>\u000a<p>\u000aFuncType represents a function type.\u000a</p>\u000a\u000a","name":"FuncType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntType!\">IntType</a></h2>\u000a<pre>type IntType commonType</pre>\u000a<p>\u000aIntType represents an int type.\u000a</p>\u000a\u000a","name":"IntType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\u000a<pre>type InterfaceType struct {\u000a\u0009commonType\u000a\u0009methods []imethod // sorted by hash\u000a}</pre>\u000a<p>\u000aInterfaceType represents an interface type.\u000a</p>\u000a\u000a","name":"InterfaceType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Itable!\">Itable</a></h2>\u000a<pre>type Itable struct {\u000a\u0009Itype  *Type // (*tab.inter).(*InterfaceType) is the interface type\u000a\u0009Type   *Type\u000a\u0009link   *Itable\u000a\u0009bad    int32\u000a\u0009unused int32\u000a\u0009Fn     [100000]uintptr // bigger than we&#39;ll ever see\u000a}</pre>\u000a<p>\u000a* Must match iface.c:/Itab and compilers.\u000a</p>\u000a\u000a","name":"Itable","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\u000a<pre>type MapType struct {\u000a\u0009commonType\u000a\u0009key  *Type // map key type\u000a\u0009elem *Type // map element (value) type\u000a}</pre>\u000a<p>\u000aMapType represents a map type.\u000a</p>\u000a\u000a","name":"MapType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MemProfileRecord!\">MemProfileRecord</a></h2>\u000a<pre>type MemProfileRecord struct {\u000a\u0009AllocBytes, FreeBytes     int64       // number of bytes allocated, freed\u000a\u0009AllocObjects, FreeObjects int64       // number of objects allocated, freed\u000a\u0009Stack0                    [32]uintptr // stack trace for this record; ends at first 0 entry\u000a}</pre>\u000a<p>\u000aA MemProfileRecord describes the live objects allocated\u000aby a particular call sequence (stack trace).\u000a</p>\u000a\u000a","name":"MemProfileRecord","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.InUseBytes!\">InUseBytes</a></h2>\u000a<code>func (r *MemProfileRecord) InUseBytes() int64</code>\u000a<p>\u000aInUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).\u000a</p>\u000a\u000a","name":"InUseBytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.InUseObjects!\">InUseObjects</a></h2>\u000a<code>func (r *MemProfileRecord) InUseObjects() int64</code>\u000a<p>\u000aInUseObjects returns the number of objects in use (AllocObjects - FreeObjects).\u000a</p>\u000a\u000a","name":"InUseObjects"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.Stack!\">Stack</a></h2>\u000a<code>func (r *MemProfileRecord) Stack() []uintptr</code>\u000a<p>\u000aStack returns the stack trace associated with the record,\u000aa prefix of r.Stack0.\u000a</p>\u000a\u000a","name":"Stack"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MemStatsType!\">MemStatsType</a></h2>\u000a<pre>type MemStatsType struct {\u000a\u0009// General statistics.\u000a\u0009// Not locked during update; approximate.\u000a\u0009Alloc      uint64 // bytes allocated and still in use\u000a\u0009TotalAlloc uint64 // bytes allocated (even if freed)\u000a\u0009Sys        uint64 // bytes obtained from system (should be sum of XxxSys below)\u000a\u0009Lookups    uint64 // number of pointer lookups\u000a\u0009Mallocs    uint64 // number of mallocs\u000a\u000a\u000a\u0009// Main allocation heap statistics.\u000a\u0009HeapAlloc   uint64 // bytes allocated and still in use\u000a\u0009HeapSys     uint64 // bytes obtained from system\u000a\u0009HeapIdle    uint64 // bytes in idle spans\u000a\u0009HeapInuse   uint64 // bytes in non-idle span\u000a\u0009HeapObjects uint64 // total number of allocated objects\u000a\u000a\u000a\u0009// Low-level fixed-size structure allocator statistics.\u000a\u0009//\u0009Inuse is bytes used now.\u000a\u0009//\u0009Sys is bytes obtained from system.\u000a\u0009StackInuse  uint64 // bootstrap stacks\u000a\u0009StackSys    uint64\u000a\u0009MSpanInuse  uint64 // mspan structures\u000a\u0009MSpanSys    uint64\u000a\u0009MCacheInuse uint64 // mcache structures\u000a\u0009MCacheSys   uint64\u000a\u0009MHeapMapSys uint64 // heap map\u000a\u0009BuckHashSys uint64 // profiling bucket hash table\u000a\u000a\u000a\u0009// Garbage collector statistics.\u000a\u0009NextGC   uint64\u000a\u0009PauseNs  uint64\u000a\u0009NumGC    uint32\u000a\u0009EnableGC bool\u000a\u0009DebugGC  bool\u000a\u000a\u0009// Per-size allocation statistics.\u000a\u0009// Not locked during update; approximate.\u000a\u0009BySize [67]struct {\u000a\u0009\u0009Size    uint32\u000a\u0009\u0009Mallocs uint64\u000a\u0009\u0009Frees   uint64\u000a\u0009}\u000a}</pre>\u000a\u000a","name":"MemStatsType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrType!\">PtrType</a></h2>\u000a<pre>type PtrType struct {\u000a\u0009commonType\u000a\u0009elem *Type // pointer element (pointed at) type\u000a}</pre>\u000a<p>\u000aPtrType represents a pointer type.\u000a</p>\u000a\u000a","name":"PtrType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceType!\">SliceType</a></h2>\u000a<pre>type SliceType struct {\u000a\u0009commonType\u000a\u0009elem *Type // slice element type\u000a}</pre>\u000a<p>\u000aSliceType represents a slice type.\u000a</p>\u000a\u000a","name":"SliceType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringType!\">StringType</a></h2>\u000a<pre>type StringType commonType</pre>\u000a<p>\u000aStringType represents a string type.\u000a</p>\u000a\u000a","name":"StringType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\u000a<pre>type StructType struct {\u000a\u0009commonType\u000a\u0009fields []structField // sorted by offset\u000a}</pre>\u000a<p>\u000aStructType represents a struct type.\u000a</p>\u000a\u000a","name":"StructType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\u000a<pre>type Type interface{}</pre>\u000a<p>\u000aThe compiler can only construct empty interface values at\u000acompile time; non-empty interface values get created\u000aduring initialization.  Type is an empty interface\u000aso that the compiler can lay out references as data.\u000a</p>\u000a\u000a","name":"Type","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeAssertionError!\">TypeAssertionError</a></h2>\u000a<pre>type TypeAssertionError struct {\u000a\u0009interfaceType   Type // interface had this type\u000a\u0009concreteType    Type // concrete value had this type\u000a\u0009assertedType    Type // asserted type\u000a\u0009interfaceString string\u000a\u0009concreteString  string\u000a\u0009assertedString  string\u000a\u0009missingMethod   string // one method needed by Interface, missing from Concrete\u000a}</pre>\u000a<p>\u000aA TypeAssertionError explains a failed type assertion.\u000a</p>\u000a\u000a","name":"TypeAssertionError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.Asserted!\">Asserted</a></h2>\u000a<code>func (e *TypeAssertionError) Asserted() Type</code>\u000a<p>\u000aAsserted returns the type incorrectly asserted by the type assertion.\u000a</p>\u000a\u000a","name":"Asserted"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.Concrete!\">Concrete</a></h2>\u000a<code>func (e *TypeAssertionError) Concrete() Type</code>\u000a<p>\u000aConcrete returns the type of the concrete value in the failed type assertion.\u000aIf the interface value was nil, Concrete returns nil.\u000a</p>\u000a\u000a","name":"Concrete"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.MissingMethod!\">MissingMethod</a></h2>\u000a<code>func (e *TypeAssertionError) MissingMethod() string</code>\u000a<p>\u000aIf the type assertion is to an interface type, MissingMethod returns the\u000aname of a method needed to satisfy that interface type but not implemented\u000aby Concrete.  If there are multiple such methods,\u000aMissingMethod returns one; which one is unspecified.\u000aIf the type assertion is not to an interface type, MissingMethod returns an empty string.\u000a</p>\u000a\u000a","name":"MissingMethod"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.RuntimeError!\">RuntimeError</a></h2>\u000a<code>func (*TypeAssertionError) RuntimeError()</code>\u000a\u000a","name":"RuntimeError"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.String!\">String</a></h2>\u000a<code>func (e *TypeAssertionError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintType!\">UintType</a></h2>\u000a<pre>type UintType commonType</pre>\u000a<p>\u000aUintType represents a uint type.\u000a</p>\u000a\u000a","name":"UintType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintptrType!\">UintptrType</a></h2>\u000a<pre>type UintptrType commonType</pre>\u000a<p>\u000aUintptrType represents a uintptr type.\u000a</p>\u000a\u000a","name":"UintptrType","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerType!\">UnsafePointerType</a></h2>\u000a<pre>type UnsafePointerType commonType</pre>\u000a<p>\u000aUnsafePointerType represents an unsafe.Pointer type.\u000a</p>\u000a\u000a","name":"UnsafePointerType","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Alloc!\">Alloc</a></h2>\u000a<code>func Alloc(uintptr) *byte</code>\u000a<p>\u000aAlloc allocates a block of the given size.\u000aFOR TESTING AND DEBUGGING ONLY.\u000a</p>\u000a\u000a","name":"Alloc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Breakpoint!\">Breakpoint</a></h2>\u000a<code>func Breakpoint()</code>\u000a<p>\u000aBreakpoint() executes a breakpoint trap.\u000a</p>\u000a\u000a","name":"Breakpoint"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Caller!\">Caller</a></h2>\u000a<code>func Caller(skip int) (pc uintptr, file string, line int, ok bool)</code>\u000a<p>\u000aCaller reports file and line number information about function invocations on\u000athe calling goroutine&#39;s stack.  The argument skip is the number of stack frames to\u000aascend, with 0 identifying the the caller of Caller.  The return values report the\u000aprogram counter, file name, and line number within the file of the corresponding\u000acall.  The boolean ok is false if it was not possible to recover the information.\u000a</p>\u000a\u000a","name":"Caller"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Callers!\">Callers</a></h2>\u000a<code>func Callers(skip int, pc []uintptr) int</code>\u000a<p>\u000aCallers fills the slice pc with the program counters of function invocations\u000aon the calling goroutine&#39;s stack.  The argument skip is the number of stack frames\u000ato skip before recording in pc, with 0 starting at the caller of Caller.\u000aIt returns the number of entries written to pc.\u000a</p>\u000a\u000a","name":"Callers"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Cgocalls!\">Cgocalls</a></h2>\u000a<code>func Cgocalls() int64</code>\u000a<p>\u000aCgocalls returns the number of cgo calls made by the current process.\u000a</p>\u000a\u000a","name":"Cgocalls"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Free!\">Free</a></h2>\u000a<code>func Free(*byte)</code>\u000a<p>\u000aFree frees the block starting at the given pointer.\u000aFOR TESTING AND DEBUGGING ONLY.\u000a</p>\u000a\u000a","name":"Free"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FuncForPC!\">FuncForPC</a></h2>\u000a<code>func FuncForPC(pc uintptr) *Func</code>\u000a<p>\u000aFuncForPC returns a *Func describing the function that contains the\u000agiven program counter address, or else nil.\u000a</p>\u000a\u000a","name":"FuncForPC"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GC!\">GC</a></h2>\u000a<code>func GC()</code>\u000a<p>\u000aGC runs a garbage collection.\u000a</p>\u000a\u000a","name":"GC"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GOMAXPROCS!\">GOMAXPROCS</a></h2>\u000a<code>func GOMAXPROCS(n int) int</code>\u000a<p>\u000aGOMAXPROCS sets the maximum number of CPUs that can be executing\u000asimultaneously and returns the previous setting.  If n &lt; 1, it does not\u000achange the current setting.\u000aThis call will go away when the scheduler improves.\u000a</p>\u000a\u000a","name":"GOMAXPROCS"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GOROOT!\">GOROOT</a></h2>\u000a<code>func GOROOT() string</code>\u000a<p>\u000aGOROOT returns the root of the Go tree.\u000aIt uses the GOROOT environment variable, if set,\u000aor else the root used during the Go build.\u000a</p>\u000a\u000a","name":"GOROOT"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Goexit!\">Goexit</a></h2>\u000a<code>func Goexit()</code>\u000a<p>\u000aGoexit terminates the goroutine that calls it.  No other goroutine is affected.\u000aGoexit runs all deferred calls before terminating the goroutine.\u000a</p>\u000a\u000a","name":"Goexit"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Gosched!\">Gosched</a></h2>\u000a<code>func Gosched()</code>\u000a<p>\u000aGosched yields the processor, allowing other goroutines to run.  It does not\u000asuspend the current goroutine, so execution resumes automatically.\u000a</p>\u000a\u000a","name":"Gosched"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LockOSThread!\">LockOSThread</a></h2>\u000a<code>func LockOSThread()</code>\u000a<p>\u000aLockOSThread wires the calling goroutine to its current operating system thread.\u000aUntil the calling goroutine exits or calls UnlockOSThread, it will always\u000aexecute in that thread, and no other goroutine can.\u000aLockOSThread cannot be used during init functions.\u000a</p>\u000a\u000a","name":"LockOSThread"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lookup!\">Lookup</a></h2>\u000a<code>func Lookup(*byte) (*byte, uintptr)</code>\u000a<p>\u000aLookup returns the base and size of the block containing the given pointer.\u000aFOR TESTING AND DEBUGGING ONLY.\u000a</p>\u000a\u000a","name":"Lookup"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MemProfile!\">MemProfile</a></h2>\u000a<code>func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</code>\u000a<p>\u000aMemProfile returns n, the number of records in the current memory profile.\u000aIf len(p) &gt;= n, MemProfile copies the profile into p and returns n, true.\u000aIf len(p) &lt; n, MemProfile does not change p and returns n, false.\u000a</p>\u000a<p>\u000aIf inuseZero is true, the profile includes allocation records\u000awhere r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes.\u000aThese are sites where memory was allocated, but it has all\u000abeen released back to the runtime.\u000a</p>\u000a\u000a","name":"MemProfile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Semacquire!\">Semacquire</a></h2>\u000a<code>func Semacquire(s *uint32)</code>\u000a<p>\u000aSemacquire waits until *s &gt; 0 and then atomically decrements it.\u000aIt is intended as a simple sleep primitive for use by the synchronization\u000alibrary and should not be used directly.\u000a</p>\u000a\u000a","name":"Semacquire"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Semrelease!\">Semrelease</a></h2>\u000a<code>func Semrelease(s *uint32)</code>\u000a<p>\u000aSemrelease atomically increments *s and notifies a waiting goroutine\u000aif one is blocked in Semacquire.\u000aIt is intended as a simple wakeup primitive for use by the synchronization\u000alibrary and should not be used directly.\u000a</p>\u000a\u000a","name":"Semrelease"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SetFinalizer!\">SetFinalizer</a></h2>\u000a<code>func SetFinalizer(x, f interface{})</code>\u000a<p>\u000aSetFinalizer sets the finalizer associated with x to f.\u000aWhen the garbage collector finds an unreachable block\u000awith an associated finalizer, it clears the association and runs\u000af(x) in a separate goroutine.  This makes x reachable again, but\u000anow without an associated finalizer.  Assuming that SetFinalizer\u000ais not called again, the next time the garbage collector sees\u000athat x is unreachable, it will free x.\u000a</p>\u000a<p>\u000aSetFinalizer(x, nil) clears any finalizer associated with x.\u000a</p>\u000a<p>\u000aThe argument x must be a pointer to an object allocated by\u000acalling new or by taking the address of a composite literal.\u000aThe argument f must be a function that takes a single argument\u000aof x&#39;s type and returns no arguments.  If either of these is not\u000atrue, SetFinalizer aborts the program.\u000a</p>\u000a<p>\u000aFinalizers are run in dependency order: if A points at B, both have\u000afinalizers, and they are otherwise unreachable, only the finalizer\u000afor A runs; once A is freed, the finalizer for B can run.\u000aIf a cyclic structure includes a block with a finalizer, that\u000acycle is not guaranteed to be garbage collected and the finalizer\u000ais not guaranteed to run, because there is no ordering that\u000arespects the dependencies.\u000a</p>\u000a<p>\u000aThe finalizer for x is scheduled to run at some arbitrary time after\u000ax becomes unreachable.\u000aThere is no guarantee that finalizers will run before a program exits,\u000aso typically they are useful only for releasing non-memory resources\u000aassociated with an object during a long-running program.\u000aFor example, an os.File object could use a finalizer to close the\u000aassociated operating system file descriptor when a program discards\u000aan os.File without calling Close, but it would be a mistake\u000ato depend on a finalizer to flush an in-memory I/O buffer such as a\u000abufio.Writer, because the buffer would not be flushed at program exit.\u000a</p>\u000a<p>\u000aA single goroutine runs all finalizers for a program, sequentially.\u000aIf a finalizer must run for a long time, it should do so by starting\u000aa new goroutine.\u000a</p>\u000a<p>\u000aTODO(rsc): allow f to have (ignored) return values\u000a</p>\u000a\u000a","name":"SetFinalizer"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Siginit!\">Siginit</a></h2>\u000a<code>func Siginit()</code>\u000a<p>\u000aSiginit enables receipt of signals via Sigrecv.  It should typically\u000abe called during initialization.\u000a</p>\u000a\u000a","name":"Siginit"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Signame!\">Signame</a></h2>\u000a<code>func Signame(sig int32) string</code>\u000a<p>\u000aSigname returns a string describing the signal, or &#34;&#34; if the signal is unknown.\u000a</p>\u000a\u000a","name":"Signame"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sigrecv!\">Sigrecv</a></h2>\u000a<code>func Sigrecv() uint32</code>\u000a<p>\u000aSigrecv returns a bitmask of signals that have arrived since the last call to Sigrecv.\u000aIt blocks until at least one signal arrives.\u000a</p>\u000a\u000a","name":"Sigrecv"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnlockOSThread!\">UnlockOSThread</a></h2>\u000a<code>func UnlockOSThread()</code>\u000a<p>\u000aUnlockOSThread unwires the calling goroutine from its fixed operating system thread.\u000aIf the calling goroutine has not called LockOSThread, UnlockOSThread is a no-op.\u000a</p>\u000a\u000a","name":"UnlockOSThread"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Version!\">Version</a></h2>\u000a<code>func Version() string</code>\u000a<p>\u000aVersion returns the Go tree&#39;s version string.\u000aIt is either a sequence number or, when possible,\u000aa release tag like &#34;release.2010-03-04&#34;.\u000aA trailing + indicates that the tree had local modifications\u000aat the time of the build.\u000a</p>\u000a\u000a","name":"Version"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\u000a<pre>const (\u000a\u0009RecvDir ChanDir             = 1 &lt;&lt; iota // &lt;-chan\u000a\u0009SendDir                                 // chan&lt;-\u000a\u0009BothDir = RecvDir | SendDir             // chan\u000a)</pre>\u000a\u000a","names":["RecvDir","SendDir","BothDir"],"type":"ChanDir"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GOOS!\">GOOS</a></h2>\u000a<pre>const GOOS string = theGoos</pre>\u000a<p>\u000aGOOS is the Go tree&#39;s operating system target:\u000aone of darwin, freebsd, linux, and so on.\u000a</p>\u000a\u000a","names":["GOOS"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GOARCH!\">GOARCH</a></h2>\u000a<pre>const GOARCH string = theGoarch</pre>\u000a<p>\u000aGOARCH is the Go tree&#39;s architecture target:\u000a386, amd64, or arm.\u000a</p>\u000a\u000a","names":["GOARCH"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:MemStats!\">MemStats</a></h2>\u000a<pre>var MemStats MemStatsType</pre>\u000a<p>\u000aMemStats holds statistics about the memory system.\u000aThe statistics are only approximate, as they are not interlocked on update.\u000a</p>\u000a\u000a","names":["MemStats"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:MemProfileRate!\">MemProfileRate</a></h2>\u000a<pre>var MemProfileRate int = 512 * 1024</pre>\u000a<p>\u000aMemProfileRate controls the fraction of memory allocations\u000athat are recorded and reported in the memory profile.\u000aThe profiler aims to sample an average of\u000aone allocation per MemProfileRate bytes allocated.\u000a</p>\u000a<p>\u000aTo include every allocated block in the profile, set MemProfileRate to 1.\u000aTo turn off profiling entirely, set MemProfileRate to 0.\u000a</p>\u000a<p>\u000aThe tools that process the memory profiles assume that the\u000aprofile rate is constant across the lifetime of the program\u000aand equal to the current value.  Programs that change the\u000amemory profiling rate should do so just once, as early as\u000apossible in the execution of the program (for example,\u000aat the beginning of main).\u000a</p>\u000a\u000a","names":["MemProfileRate"],"type":""}]}