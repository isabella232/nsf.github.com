var gowtfData = {"index":"index.html","html":"<p>\u000aThis package provides basic interfaces to I/O primitives.\u000aIts primary job is to wrap existing implementations of such primitives,\u000asuch as those in package os, into shared public interfaces that\u000aabstract the functionality, plus some other related primitives.\u000a</p>\u000a","name":"io","filenames":["/home/nsf/go/src/pkg/io/pipe.go","/home/nsf/go/src/pkg/io/io.go","/home/nsf/go/src/pkg/io/multi.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Closer!\">Closer</a></h2>\u000a<pre>type Closer interface {\u000a\u0009Close() os.Error\u000a}</pre>\u000a<p>\u000aCloser is the interface that wraps the basic Close method.\u000a</p>\u000a\u000a","name":"Closer","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error struct {\u000a\u0009os.ErrorString\u000a}</pre>\u000a<p>\u000aError represents an unexpected I/O behavior.\u000a</p>\u000a\u000a","name":"Error","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PipeReader!\">PipeReader</a></h2>\u000a<pre>type PipeReader struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA PipeReader is the read half of a pipe.\u000a</p>\u000a\u000a","name":"PipeReader","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.Close!\">Close</a></h2>\u000a<code>func (r *PipeReader) Close() os.Error</code>\u000a<p>\u000aClose closes the reader; subsequent writes to the\u000awrite half of the pipe will return the error os.EPIPE.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.CloseWithError!\">CloseWithError</a></h2>\u000a<code>func (r *PipeReader) CloseWithError(err os.Error) os.Error</code>\u000a<p>\u000aCloseWithError closes the reader; subsequent writes\u000ato the write half of the pipe will return the error err.\u000a</p>\u000a\u000a","name":"CloseWithError"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.Read!\">Read</a></h2>\u000a<code>func (r *PipeReader) Read(data []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead implements the standard Read interface:\u000ait reads data from the pipe, blocking until a writer\u000aarrives or the write end is closed.\u000aIf the write end is closed with an error, that error is\u000areturned as err; otherwise err is nil.\u000a</p>\u000a\u000a","name":"Read"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PipeWriter!\">PipeWriter</a></h2>\u000a<pre>type PipeWriter struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA PipeWriter is the write half of a pipe.\u000a</p>\u000a\u000a","name":"PipeWriter","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.Close!\">Close</a></h2>\u000a<code>func (w *PipeWriter) Close() os.Error</code>\u000a<p>\u000aClose closes the writer; subsequent reads from the\u000aread half of the pipe will return no bytes and os.EOF.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.CloseWithError!\">CloseWithError</a></h2>\u000a<code>func (w *PipeWriter) CloseWithError(err os.Error) os.Error</code>\u000a<p>\u000aCloseWithError closes the writer; subsequent reads from the\u000aread half of the pipe will return no bytes and the error err.\u000a</p>\u000a\u000a","name":"CloseWithError"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.Write!\">Write</a></h2>\u000a<code>func (w *PipeWriter) Write(data []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite implements the standard Write interface:\u000ait writes data to the pipe, blocking until readers\u000ahave consumed all the data or the read end is closed.\u000aIf the read end is closed with an error, that err is\u000areturned as err; otherwise err is os.EPIPE.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadByter!\">ReadByter</a></h2>\u000a<pre>type ReadByter interface {\u000a\u0009ReadByte() (c byte, err os.Error)\u000a}</pre>\u000a<p>\u000aReadByter is the interface that wraps the ReadByte method.\u000a</p>\u000a<p>\u000aReadByte reads and returns the next byte from the input.\u000aIf no byte is available, err will be set.\u000a</p>\u000a\u000a","name":"ReadByter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadCloser!\">ReadCloser</a></h2>\u000a<pre>type ReadCloser interface {\u000a\u0009Reader\u000a\u0009Closer\u000a}</pre>\u000a<p>\u000aReadCloser is the interface that groups the basic Read and Close methods.\u000a</p>\u000a\u000a","name":"ReadCloser","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadSeeker!\">ReadSeeker</a></h2>\u000a<pre>type ReadSeeker interface {\u000a\u0009Reader\u000a\u0009Seeker\u000a}</pre>\u000a<p>\u000aReadSeeker is the interface that groups the basic Read and Seek methods.\u000a</p>\u000a\u000a","name":"ReadSeeker","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriteCloser!\">ReadWriteCloser</a></h2>\u000a<pre>type ReadWriteCloser interface {\u000a\u0009Reader\u000a\u0009Writer\u000a\u0009Closer\u000a}</pre>\u000a<p>\u000aReadWriteCloser is the interface that groups the basic Read, Write and Close methods.\u000a</p>\u000a\u000a","name":"ReadWriteCloser","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriteSeeker!\">ReadWriteSeeker</a></h2>\u000a<pre>type ReadWriteSeeker interface {\u000a\u0009Reader\u000a\u0009Writer\u000a\u0009Seeker\u000a}</pre>\u000a<p>\u000aReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.\u000a</p>\u000a\u000a","name":"ReadWriteSeeker","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriter!\">ReadWriter</a></h2>\u000a<pre>type ReadWriter interface {\u000a\u0009Reader\u000a\u0009Writer\u000a}</pre>\u000a<p>\u000aReadWriter is the interface that groups the basic Read and Write methods.\u000a</p>\u000a\u000a","name":"ReadWriter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\u000a<pre>type Reader interface {\u000a\u0009Read(p []byte) (n int, err os.Error)\u000a}</pre>\u000a<p>\u000aReader is the interface that wraps the basic Read method.\u000a</p>\u000a<p>\u000aRead reads up to len(p) bytes into p.  It returns the number of bytes\u000aread (0 &lt;= n &lt;= len(p)) and any error encountered.\u000aEven if Read returns n &lt; len(p),\u000ait may use all of p as scratch space during the call.\u000aIf some data is available but not len(p) bytes, Read conventionally\u000areturns what is available rather than block waiting for more.\u000a</p>\u000a<p>\u000aAt the end of the input stream, Read returns 0, os.EOF.\u000aRead may return a non-zero number of bytes with a non-nil err.\u000aIn particular, a Read that exhausts the input may return n &gt; 0, os.EOF.\u000a</p>\u000a\u000a","name":"Reader","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReaderAt!\">ReaderAt</a></h2>\u000a<pre>type ReaderAt interface {\u000a\u0009ReadAt(p []byte, off int64) (n int, err os.Error)\u000a}</pre>\u000a<p>\u000aReaderAt is the interface that wraps the basic ReadAt method.\u000a</p>\u000a<p>\u000aReadAt reads len(p) bytes into p starting at offset off in the\u000aunderlying data stream.  It returns the number of bytes\u000aread (0 &lt;= n &lt;= len(p)) and any error encountered.\u000a</p>\u000a<p>\u000aEven if ReadAt returns n &lt; len(p),\u000ait may use all of p as scratch space during the call.\u000aIf some data is available but not len(p) bytes, ReadAt blocks\u000auntil either all the data is available or an error occurs.\u000a</p>\u000a<p>\u000aAt the end of the input stream, ReadAt returns 0, os.EOF.\u000aReadAt may return a non-zero number of bytes with a non-nil err.\u000aIn particular, a ReadAt that exhausts the input may return n &gt; 0, os.EOF.\u000a</p>\u000a\u000a","name":"ReaderAt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReaderFrom!\">ReaderFrom</a></h2>\u000a<pre>type ReaderFrom interface {\u000a\u0009ReadFrom(r Reader) (n int64, err os.Error)\u000a}</pre>\u000a<p>\u000aReaderFrom is the interface that wraps the ReadFrom method.\u000a</p>\u000a\u000a","name":"ReaderFrom","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SectionReader!\">SectionReader</a></h2>\u000a<pre>type SectionReader struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aSectionReader implements Read, Seek, and ReadAt on a section\u000aof an underlying ReaderAt.\u000a</p>\u000a\u000a","name":"SectionReader","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Read!\">Read</a></h2>\u000a<code>func (s *SectionReader) Read(p []byte) (n int, err os.Error)</code>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.ReadAt!\">ReadAt</a></h2>\u000a<code>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err os.Error)</code>\u000a\u000a","name":"ReadAt"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Seek!\">Seek</a></h2>\u000a<code>func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error)</code>\u000a\u000a","name":"Seek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Size!\">Size</a></h2>\u000a<code>func (s *SectionReader) Size() int64</code>\u000a<p>\u000aSize returns the size of the section in bytes.\u000a</p>\u000a\u000a","name":"Size"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Seeker!\">Seeker</a></h2>\u000a<pre>type Seeker interface {\u000a\u0009Seek(offset int64, whence int) (ret int64, err os.Error)\u000a}</pre>\u000a<p>\u000aSeeker is the interface that wraps the basic Seek method.\u000a</p>\u000a<p>\u000aSeek sets the offset for the next Read or Write to offset,\u000ainterpreted according to whence: 0 means relative to the origin of\u000athe file, 1 means relative to the current offset, and 2 means\u000arelative to the end.  Seek returns the new offset and an Error, if\u000aany.\u000a</p>\u000a\u000a","name":"Seeker","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteCloser!\">WriteCloser</a></h2>\u000a<pre>type WriteCloser interface {\u000a\u0009Writer\u000a\u0009Closer\u000a}</pre>\u000a<p>\u000aWriteCloser is the interface that groups the basic Write and Close methods.\u000a</p>\u000a\u000a","name":"WriteCloser","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteSeeker!\">WriteSeeker</a></h2>\u000a<pre>type WriteSeeker interface {\u000a\u0009Writer\u000a\u0009Seeker\u000a}</pre>\u000a<p>\u000aWriteSeeker is the interface that groups the basic Write and Seek methods.\u000a</p>\u000a\u000a","name":"WriteSeeker","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\u000a<pre>type Writer interface {\u000a\u0009Write(p []byte) (n int, err os.Error)\u000a}</pre>\u000a<p>\u000aWriter is the interface that wraps the basic Write method.\u000a</p>\u000a<p>\u000aWrite writes len(p) bytes from p to the underlying data stream.\u000aIt returns the number of bytes written from p (0 &lt;= n &lt;= len(p))\u000aand any error encountered that caused the write to stop early.\u000aWrite must return a non-nil error if it returns n &lt; len(p).\u000a</p>\u000a\u000a","name":"Writer","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriterAt!\">WriterAt</a></h2>\u000a<pre>type WriterAt interface {\u000a\u0009WriteAt(p []byte, off int64) (n int, err os.Error)\u000a}</pre>\u000a<p>\u000aWriterAt is the interface that wraps the basic WriteAt method.\u000a</p>\u000a<p>\u000aWriteAt writes len(p) bytes from p to the underlying data stream\u000aat offset off.  It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))\u000aand any error encountered that caused the write to stop early.\u000aWriteAt must return a non-nil error if it returns n &lt; len(p).\u000a</p>\u000a\u000a","name":"WriterAt","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriterTo!\">WriterTo</a></h2>\u000a<pre>type WriterTo interface {\u000a\u0009WriteTo(w Writer) (n int64, err os.Error)\u000a}</pre>\u000a<p>\u000aWriterTo is the interface that wraps the WriteTo method.\u000a</p>\u000a\u000a","name":"WriterTo","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Copy!\">Copy</a></h2>\u000a<code>func Copy(dst Writer, src Reader) (written int64, err os.Error)</code>\u000a<p>\u000aCopy copies from src to dst until either EOF is reached\u000aon src or an error occurs.  It returns the number of bytes\u000acopied and the error, if any.\u000a</p>\u000a<p>\u000aIf dst implements the ReaderFrom interface,\u000athe copy is implemented by calling dst.ReadFrom(src).\u000aOtherwise, if src implements the WriterTo interface,\u000athe copy is implemented by calling src.WriteTo(dst).\u000a</p>\u000a\u000a","name":"Copy"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Copyn!\">Copyn</a></h2>\u000a<code>func Copyn(dst Writer, src Reader, n int64) (written int64, err os.Error)</code>\u000a<p>\u000aCopyn copies n bytes (or until an error) from src to dst.\u000aIt returns the number of bytes copied and the error, if any.\u000a</p>\u000a<p>\u000aIf dst implements the ReaderFrom interface,\u000athe copy is implemented by calling dst.ReadFrom(src).\u000a</p>\u000a\u000a","name":"Copyn"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LimitReader!\">LimitReader</a></h2>\u000a<code>func LimitReader(r Reader, n int64) Reader</code>\u000a<p>\u000aLimitReader returns a Reader that reads from r\u000abut stops with os.EOF after n bytes.\u000a</p>\u000a\u000a","name":"LimitReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MultiReader!\">MultiReader</a></h2>\u000a<code>func MultiReader(readers ...Reader) Reader</code>\u000a<p>\u000aMultiReader returns a Reader that&#39;s the logical concatenation of\u000athe provided input readers.  They&#39;re read sequentially.  Once all\u000ainputs are drained, Read will return os.EOF.\u000a</p>\u000a\u000a","name":"MultiReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MultiWriter!\">MultiWriter</a></h2>\u000a<code>func MultiWriter(writers ...Writer) Writer</code>\u000a<p>\u000aMultiWriter creates a writer that duplicates its writes to all the\u000aprovided writers, similar to the Unix tee(1) command.\u000a</p>\u000a\u000a","name":"MultiWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewSectionReader!\">NewSectionReader</a></h2>\u000a<code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</code>\u000a<p>\u000aNewSectionReader returns a SectionReader that reads from r\u000astarting at offset off and stops with os.EOF after n bytes.\u000a</p>\u000a\u000a","name":"NewSectionReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pipe!\">Pipe</a></h2>\u000a<code>func Pipe() (*PipeReader, *PipeWriter)</code>\u000a<p>\u000aPipe creates a synchronous in-memory pipe.\u000aIt can be used to connect code expecting an io.Reader\u000awith code expecting an io.Writer.\u000aReads on one end are matched with writes on the other,\u000acopying data directly between the two; there is no internal buffering.\u000a</p>\u000a\u000a","name":"Pipe"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadAtLeast!\">ReadAtLeast</a></h2>\u000a<code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error)</code>\u000a<p>\u000aReadAtLeast reads from r into buf until it has read at least min bytes.\u000aIt returns the number of bytes copied and an error if fewer bytes were read.\u000aThe error is os.EOF only if no bytes were read.\u000aIf an EOF happens after reading fewer than min bytes,\u000aReadAtLeast returns ErrUnexpectedEOF.\u000aIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\u000a</p>\u000a\u000a","name":"ReadAtLeast"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadFull!\">ReadFull</a></h2>\u000a<code>func ReadFull(r Reader, buf []byte) (n int, err os.Error)</code>\u000a<p>\u000aReadFull reads exactly len(buf) bytes from r into buf.\u000aIt returns the number of bytes copied and an error if fewer bytes were read.\u000aThe error is os.EOF only if no bytes were read.\u000aIf an EOF happens after reading some but not all the bytes,\u000aReadFull returns ErrUnexpectedEOF.\u000a</p>\u000a\u000a","name":"ReadFull"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:WriteString!\">WriteString</a></h2>\u000a<code>func WriteString(w Writer, s string) (n int, err os.Error)</code>\u000a<p>\u000aWriteString writes the contents of the string s to w, which accepts an array of bytes.\u000a</p>\u000a\u000a","name":"WriteString"}],"consts":[],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrShortWrite!\">ErrShortWrite</a></h2>\u000a<pre>var ErrShortWrite os.Error = &amp;Error{&#34;short write&#34;}</pre>\u000a<p>\u000aErrShortWrite means that a write accepted fewer bytes than requested\u000abut failed to return an explicit error.\u000a</p>\u000a\u000a","names":["ErrShortWrite"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrShortBuffer!\">ErrShortBuffer</a></h2>\u000a<pre>var ErrShortBuffer os.Error = &amp;Error{&#34;short buffer&#34;}</pre>\u000a<p>\u000aErrShortBuffer means that a read required a longer buffer than was provided.\u000a</p>\u000a\u000a","names":["ErrShortBuffer"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrUnexpectedEOF!\">ErrUnexpectedEOF</a></h2>\u000a<pre>var ErrUnexpectedEOF os.Error = &amp;Error{&#34;unexpected EOF&#34;}</pre>\u000a<p>\u000aErrUnexpectedEOF means that os.EOF was encountered in the\u000amiddle of reading a fixed-size block or data structure.\u000a</p>\u000a\u000a","names":["ErrUnexpectedEOF"],"type":""}]}