var gowtfData = {"html":"<p>\u000aThe block package implements standard block cipher modes\u000athat can be wrapped around low-level block cipher implementations.\u000aSee <a href=\"http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\">http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html</a>\u000aand NIST Special Publication 800-38A.\u000a</p>\u000a","name":"block","filenames":["/home/nsf/go/src/pkg/crypto/block/cipher.go","/home/nsf/go/src/pkg/crypto/block/eax.go","/home/nsf/go/src/pkg/crypto/block/cbc.go","/home/nsf/go/src/pkg/crypto/block/xor.go","/home/nsf/go/src/pkg/crypto/block/ctr.go","/home/nsf/go/src/pkg/crypto/block/ofb.go","/home/nsf/go/src/pkg/crypto/block/ecb.go","/home/nsf/go/src/pkg/crypto/block/cmac.go","/home/nsf/go/src/pkg/crypto/block/cfb.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cipher!\">Cipher</a></h2>\u000a<pre>type Cipher interface {\u000a\u0009// BlockSize returns the cipher&#39;s block size.\u000a\u0009BlockSize() int\u000a\u000a\u0009// Encrypt encrypts the first block in src into dst.\u000a\u0009// Src and dst may point at the same memory.\u000a\u0009Encrypt(src, dst []byte)\u000a\u000a\u0009// Decrypt decrypts the first block in src into dst.\u000a\u0009// Src and dst may point at the same memory.\u000a\u0009Decrypt(src, dst []byte)\u000a}</pre>\u000a<p>\u000aA Cipher represents an implementation of block cipher\u000ausing a given key.  It provides the capability to encrypt\u000aor decrypt individual blocks.  The mode implementations\u000aextend that capability to streams of blocks.\u000a</p>\u000a\u000a","name":"Cipher","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EAXTagError!\">EAXTagError</a></h2>\u000a<pre>type EAXTagError struct {\u000a\u0009Read     []byte\u000a\u0009Computed []byte\u000a}</pre>\u000a<p>\u000aAn EAXTagError is returned when the message has failed to authenticate,\u000abecause the tag at the end of the message stream (Read) does not match\u000athe tag computed from the message itself (Computed).\u000a</p>\u000a\u000a","name":"EAXTagError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:EAXTagError\">func (*EAXTagError)</a> <a href=\"?m:EAXTagError.String!\">String</a></h2>\u000a<code>func (e *EAXTagError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCBCDecrypter!\">NewCBCDecrypter</a></h2>\u000a<code>func NewCBCDecrypter(c Cipher, iv []byte, r io.Reader) io.Reader</code>\u000a<p>\u000aNewCBCDecrypter returns a reader that reads data from r and decrypts it using c\u000ain cipher block chaining (CBC) mode with the initialization vector iv.\u000aThe returned Reader does not buffer or read ahead except\u000aas required by the cipher&#39;s block size.\u000a</p>\u000a\u000a","name":"NewCBCDecrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCBCEncrypter!\">NewCBCEncrypter</a></h2>\u000a<code>func NewCBCEncrypter(c Cipher, iv []byte, w io.Writer) io.Writer</code>\u000a<p>\u000aNewCBCEncrypter returns a writer that encrypts data using c\u000ain cipher block chaining (CBC) mode with the initialization vector iv\u000aand writes the encrypted data to w.\u000aThe returned Writer does no buffering except as required\u000aby the cipher&#39;s block size, so there is no need for a Flush method.\u000a</p>\u000a\u000a","name":"NewCBCEncrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCFBDecrypter!\">NewCFBDecrypter</a></h2>\u000a<code>func NewCFBDecrypter(c Cipher, s int, iv []byte, r io.Reader) io.Reader</code>\u000a<p>\u000aNewCFBDecrypter returns a reader that reads data from r and decrypts it using c\u000ain s-bit cipher feedback (CFB) mode with the initialization vector iv.\u000aThe returned Reader does not buffer or read ahead except\u000aas required by the cipher&#39;s block size.\u000aModes for s not a multiple of 8 are unimplemented.\u000a</p>\u000a\u000a","name":"NewCFBDecrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCFBEncrypter!\">NewCFBEncrypter</a></h2>\u000a<code>func NewCFBEncrypter(c Cipher, s int, iv []byte, w io.Writer) io.Writer</code>\u000a<p>\u000aNewCFBEncrypter returns a writer that encrypts data using c\u000ain s-bit cipher feedback (CFB) mode with the initialization vector iv\u000aand writes the encrypted data to w.\u000aThe returned Writer does no buffering except as required\u000aby the cipher&#39;s block size, so there is no need for a Flush method.\u000aModes for s not a multiple of 8 are unimplemented.\u000a</p>\u000a\u000a","name":"NewCFBEncrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCMAC!\">NewCMAC</a></h2>\u000a<code>func NewCMAC(c Cipher) hash.Hash</code>\u000a<p>\u000aNewCMAC returns a new instance of a CMAC message authentication code\u000adigest using the given Cipher.\u000a</p>\u000a\u000a","name":"NewCMAC"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCTRReader!\">NewCTRReader</a></h2>\u000a<code>func NewCTRReader(c Cipher, iv []byte, r io.Reader) io.Reader</code>\u000a<p>\u000aNewCTRReader returns a reader that reads data from r, decrypts (or encrypts)\u000ait using c in counter (CTR) mode with the initialization vector iv.\u000aThe returned Reader does not buffer and has no block size.\u000aIn CTR mode, encryption and decryption are the same operation:\u000aa CTR reader applied to an encrypted stream produces a decrypted\u000astream and vice versa.\u000a</p>\u000a\u000a","name":"NewCTRReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCTRWriter!\">NewCTRWriter</a></h2>\u000a<code>func NewCTRWriter(c Cipher, iv []byte, w io.Writer) io.Writer</code>\u000a<p>\u000aNewCTRWriter returns a writer that encrypts (or decrypts) data using c\u000ain counter (CTR) mode with the initialization vector iv\u000aand writes the encrypted data to w.\u000aThe returned Writer does not buffer and has no block size.\u000aIn CTR mode, encryption and decryption are the same operation:\u000aa CTR writer applied to an decrypted stream produces an encrypted\u000astream and vice versa.\u000a</p>\u000a\u000a","name":"NewCTRWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEAXDecrypter!\">NewEAXDecrypter</a></h2>\u000a<code>func NewEAXDecrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, r io.Reader) io.Reader</code>\u000a<p>\u000aNewEAXDecrypter creates and returns a new EAX decrypter\u000ausing the given cipher c, initialization vector iv, associated data hdr,\u000aand tag length tagBytes.  The encrypter&#39;s Read method decrypts and\u000areturns data read from r.  At r&#39;s EOF, the encrypter checks the final\u000aauthenticating tag and returns an EAXTagError if the tag is invalid.\u000aIn that case, the message should be discarded.\u000aNote that the data stream returned from Read cannot be\u000aassumed to be valid, authenticated data until Read returns\u000a0, nil to signal the end of the data.\u000a</p>\u000a\u000a","name":"NewEAXDecrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEAXEncrypter!\">NewEAXEncrypter</a></h2>\u000a<code>func NewEAXEncrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, w io.Writer) io.WriteCloser</code>\u000a<p>\u000aNewEAXEncrypter creates and returns a new EAX encrypter\u000ausing the given cipher c, initialization vector iv, associated data hdr,\u000aand tag length tagBytes.  The encrypter&#39;s Write method encrypts\u000athe data it receives and writes that data to w.\u000aThe encrypter&#39;s Close method writes a final authenticating tag to w.\u000a</p>\u000a\u000a","name":"NewEAXEncrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewECBDecrypter!\">NewECBDecrypter</a></h2>\u000a<code>func NewECBDecrypter(c Cipher, r io.Reader) io.Reader</code>\u000a<p>\u000aNewECBDecrypter returns a reader that reads data from r and decrypts it using c.\u000aIt decrypts by calling c.Decrypt on each block in sequence;\u000athis mode is known as electronic codebook mode, or ECB.\u000aThe returned Reader does not buffer or read ahead except\u000aas required by the cipher&#39;s block size.\u000a</p>\u000a\u000a","name":"NewECBDecrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewECBEncrypter!\">NewECBEncrypter</a></h2>\u000a<code>func NewECBEncrypter(c Cipher, w io.Writer) io.Writer</code>\u000a<p>\u000aNewECBEncrypter returns a writer that encrypts data using c and writes it to w.\u000aIt encrypts by calling c.Encrypt on each block in sequence;\u000athis mode is known as electronic codebook mode, or ECB.\u000aThe returned Writer does no buffering except as required\u000aby the cipher&#39;s block size, so there is no need for a Flush method.\u000a</p>\u000a\u000a","name":"NewECBEncrypter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewOFBReader!\">NewOFBReader</a></h2>\u000a<code>func NewOFBReader(c Cipher, iv []byte, r io.Reader) io.Reader</code>\u000a<p>\u000aNewOFBReader returns a reader that reads data from r, decrypts (or encrypts)\u000ait using c in output feedback (OFB) mode with the initialization vector iv.\u000aThe returned Reader does not buffer and has no block size.\u000aIn OFB mode, encryption and decryption are the same operation:\u000aan OFB reader applied to an encrypted stream produces a decrypted\u000astream and vice versa.\u000a</p>\u000a\u000a","name":"NewOFBReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewOFBWriter!\">NewOFBWriter</a></h2>\u000a<code>func NewOFBWriter(c Cipher, iv []byte, w io.Writer) io.Writer</code>\u000a<p>\u000aNewOFBWriter returns a writer that encrypts (or decrypts) data using c\u000ain cipher feedback (OFB) mode with the initialization vector iv\u000aand writes the encrypted data to w.\u000aThe returned Writer does not buffer and has no block size.\u000aIn OFB mode, encryption and decryption are the same operation:\u000aan OFB writer applied to an decrypted stream produces an encrypted\u000astream and vice versa.\u000a</p>\u000a\u000a","name":"NewOFBWriter"}],"consts":[],"vars":[]}