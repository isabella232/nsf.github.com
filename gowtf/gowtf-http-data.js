var gowtfData = {"index":"index.html","html":"<p>\u000aThe http package implements parsing of HTTP requests, replies,\u000aand URLs and provides an extensible HTTP server and a basic\u000aHTTP client.\u000a</p>\u000a","name":"http","filenames":["/home/nsf/go/src/pkg/http/request.go","/home/nsf/go/src/pkg/http/lex.go","/home/nsf/go/src/pkg/http/response.go","/home/nsf/go/src/pkg/http/transfer.go","/home/nsf/go/src/pkg/http/chunked.go","/home/nsf/go/src/pkg/http/server.go","/home/nsf/go/src/pkg/http/status.go","/home/nsf/go/src/pkg/http/url.go","/home/nsf/go/src/pkg/http/fs.go","/home/nsf/go/src/pkg/http/dump.go","/home/nsf/go/src/pkg/http/client.go","/home/nsf/go/src/pkg/http/persist.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ClientConn!\">ClientConn</a></h2>\u000a<pre>type ClientConn struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA ClientConn sends request and receives headers over an underlying\u000aconnection, while respecting the HTTP keepalive logic. ClientConn is not\u000aresponsible for closing the underlying connection. One must call Close to\u000aregain control of that connection and deal with it as desired.\u000a</p>\u000a\u000a","name":"ClientConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Close!\">Close</a></h2>\u000a<code>func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader)</code>\u000a<p>\u000aClose detaches the ClientConn and returns the underlying connection as well\u000aas the read-side bufio which may have some left over data. Close may be\u000acalled before the user or Read have signaled the end of the keep-alive\u000alogic. The user should not call Close while Read or Write is in progress.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Pending!\">Pending</a></h2>\u000a<code>func (cc *ClientConn) Pending() int</code>\u000a<p>\u000aPending returns the number of unanswered requests\u000athat have been sent on the connection.\u000a</p>\u000a\u000a","name":"Pending"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Read!\">Read</a></h2>\u000a<code>func (cc *ClientConn) Read() (resp *Response, err os.Error)</code>\u000a<p>\u000aRead reads the next response from the wire. A valid response might be\u000areturned together with an ErrPersistEOF, which means that the remote\u000arequested that this be the last request serviced. Read can be called\u000aconcurrently with Write, but not with another Read.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Write!\">Write</a></h2>\u000a<code>func (cc *ClientConn) Write(req *Request) os.Error</code>\u000a<p>\u000aWrite writes a request. An ErrPersistEOF error is returned if the connection\u000ahas been closed in an HTTP keepalive sense. If req.Close equals true, the\u000akeepalive connection is logically closed after this request and the opposing\u000aserver is informed. An ErrUnexpectedEOF indicates the remote closed the\u000aunderlying TCP connection, which is usually considered as graceful close.\u000aWrite can be called concurrently with Read, but not with another Write.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Handler!\">Handler</a></h2>\u000a<pre>type Handler interface {\u000a\u0009ServeHTTP(ResponseWriter, *Request)\u000a}</pre>\u000a<p>\u000aObjects implementing the Handler interface can be\u000aregistered to serve a particular path or subtree\u000ain the HTTP server.\u000a</p>\u000a<p>\u000aServeHTTP should write reply headers and data to the ResponseWriter\u000aand then return.  Returning signals that the request is finished\u000aand that the HTTP server can move on to the next request on\u000athe connection.\u000a</p>\u000a\u000a","name":"Handler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HandlerFunc!\">HandlerFunc</a></h2>\u000a<pre>type HandlerFunc func(ResponseWriter, *Request)</pre>\u000a<p>\u000aThe HandlerFunc type is an adapter to allow the use of\u000aordinary functions as HTTP handlers.  If f is a function\u000awith the appropriate signature, HandlerFunc(f) is a\u000aHandler object that calls f.\u000a</p>\u000a\u000a","name":"HandlerFunc","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:HandlerFunc\">func (HandlerFunc)</a> <a href=\"?m:HandlerFunc.ServeHTTP!\">ServeHTTP</a></h2>\u000a<code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</code>\u000a<p>\u000aServeHTTP calls f(w, req).\u000a</p>\u000a\u000a","name":"ServeHTTP"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProtocolError!\">ProtocolError</a></h2>\u000a<pre>type ProtocolError struct {\u000a\u0009os.ErrorString\u000a}</pre>\u000a<p>\u000aHTTP request parsing errors.\u000a</p>\u000a\u000a","name":"ProtocolError","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Request!\">Request</a></h2>\u000a<pre>type Request struct {\u000a\u0009Method     string // GET, POST, PUT, etc.\u000a\u0009RawURL     string // The raw URL given in the request.\u000a\u0009URL        *URL   // Parsed URL.\u000a\u0009Proto      string // &#34;HTTP/1.0&#34;\u000a\u0009ProtoMajor int    // 1\u000a\u0009ProtoMinor int    // 0\u000a\u000a\u000a\u0009// A header maps request lines to their values.\u000a\u0009// If the header says\u000a\u0009//\u000a\u0009//\u0009accept-encoding: gzip, deflate\u000a\u0009//\u0009Accept-Language: en-us\u000a\u0009//\u0009Connection: keep-alive\u000a\u0009//\u000a\u0009// then\u000a\u0009//\u000a\u0009//\u0009Header = map[string]string{\u000a\u0009//\u0009\u0009&#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,\u000a\u0009//\u0009\u0009&#34;Accept-Language&#34;: &#34;en-us&#34;,\u000a\u0009//\u0009\u0009&#34;Connection&#34;: &#34;keep-alive&#34;,\u000a\u0009//\u0009}\u000a\u0009//\u000a\u0009// HTTP defines that header names are case-insensitive.\u000a\u0009// The request parser implements this by canonicalizing the\u000a\u0009// name, making the first character and any characters\u000a\u0009// following a hyphen uppercase and the rest lowercase.\u000a\u0009Header map[string]string\u000a\u000a\u0009// The message body.\u000a\u0009Body io.ReadCloser\u000a\u000a\u0009// ContentLength records the length of the associated content.\u000a\u0009// The value -1 indicates that the length is unknown.\u000a\u0009// Values &gt;= 0 indicate that the given number of bytes may be read from Body.\u000a\u0009ContentLength int64\u000a\u000a\u0009// TransferEncoding lists the transfer encodings from outermost to innermost.\u000a\u0009// An empty list denotes the &#34;identity&#34; encoding.\u000a\u0009TransferEncoding []string\u000a\u000a\u0009// Whether to close the connection after replying to this request.\u000a\u0009Close bool\u000a\u000a\u0009// The host on which the URL is sought.\u000a\u0009// Per RFC 2616, this is either the value of the Host: header\u000a\u0009// or the host name given in the URL itself.\u000a\u0009Host string\u000a\u000a\u0009// The referring URL, if sent in the request.\u000a\u0009//\u000a\u0009// Referer is misspelled as in the request itself,\u000a\u0009// a mistake from the earliest days of HTTP.\u000a\u0009// This value can also be fetched from the Header map\u000a\u0009// as Header[&#34;Referer&#34;]; the benefit of making it\u000a\u0009// available as a structure field is that the compiler\u000a\u0009// can diagnose programs that use the alternate\u000a\u0009// (correct English) spelling req.Referrer but cannot\u000a\u0009// diagnose programs that use Header[&#34;Referrer&#34;].\u000a\u0009Referer string\u000a\u000a\u0009// The User-Agent: header string, if sent in the request.\u000a\u0009UserAgent string\u000a\u000a\u0009// The parsed form. Only available after ParseForm is called.\u000a\u0009Form map[string][]string\u000a\u000a\u0009// Trailer maps trailer keys to values.  Like for Header, if the\u000a\u0009// response has multiple trailer lines with the same key, they will be\u000a\u0009// concatenated, delimited by commas.\u000a\u0009Trailer map[string]string\u000a}</pre>\u000a<p>\u000aA Request represents a parsed HTTP request header.\u000a</p>\u000a\u000a","name":"Request","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.FormValue!\">FormValue</a></h2>\u000a<code>func (r *Request) FormValue(key string) string</code>\u000a<p>\u000aFormValue returns the first value for the named component of the query.\u000aFormValue calls ParseForm if necessary.\u000a</p>\u000a\u000a","name":"FormValue"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.MultipartReader!\">MultipartReader</a></h2>\u000a<code>func (r *Request) MultipartReader() (multipart.Reader, os.Error)</code>\u000a<p>\u000aMultipartReader returns a MIME multipart reader if this is a\u000amultipart/form-data POST request, else returns nil and an error.\u000a</p>\u000a\u000a","name":"MultipartReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ParseForm!\">ParseForm</a></h2>\u000a<code>func (r *Request) ParseForm() (err os.Error)</code>\u000a<p>\u000aParseForm parses the request body as a form for POST requests, or the raw query for GET requests.\u000aIt is idempotent.\u000a</p>\u000a\u000a","name":"ParseForm"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ProtoAtLeast!\">ProtoAtLeast</a></h2>\u000a<code>func (r *Request) ProtoAtLeast(major, minor int) bool</code>\u000a<p>\u000aProtoAtLeast returns whether the HTTP protocol used\u000ain the request is at least major.minor.\u000a</p>\u000a\u000a","name":"ProtoAtLeast"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.Write!\">Write</a></h2>\u000a<code>func (req *Request) Write(w io.Writer) os.Error</code>\u000a<p>\u000aWrite writes an HTTP/1.1 request -- header and body -- in wire format.\u000aThis method consults the following fields of req:\u000a</p>\u000a<pre>Host\u000aRawURL, if non-empty, or else URL\u000aMethod (defaults to &#34;GET&#34;)\u000aUserAgent (defaults to defaultUserAgent)\u000aReferer\u000aHeader\u000aBody\u000a</pre>\u000a<p>\u000aIf Body is present, Write forces &#34;Transfer-Encoding: chunked&#34; as a header\u000aand then closes Body when finished sending it.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Response!\">Response</a></h2>\u000a<pre>type Response struct {\u000a\u0009Status     string // e.g. &#34;200 OK&#34;\u000a\u0009StatusCode int    // e.g. 200\u000a\u0009Proto      string // e.g. &#34;HTTP/1.0&#34;\u000a\u0009ProtoMajor int    // e.g. 1\u000a\u0009ProtoMinor int    // e.g. 0\u000a\u000a\u000a\u0009// RequestMethod records the method used in the HTTP request.\u000a\u0009// Header fields such as Content-Length have method-specific meaning.\u000a\u0009RequestMethod string // e.g. &#34;HEAD&#34;, &#34;CONNECT&#34;, &#34;GET&#34;, etc.\u000a\u000a\u000a\u0009// Header maps header keys to values.  If the response had multiple\u000a\u0009// headers with the same key, they will be concatenated, with comma\u000a\u0009// delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers\u000a\u0009// be semantically equivalent to a comma-delimited sequence.) Values\u000a\u0009// duplicated by other fields in this struct (e.g., ContentLength) are\u000a\u0009// omitted from Header.\u000a\u0009//\u000a\u0009// Keys in the map are canonicalized (see CanonicalHeaderKey).\u000a\u0009Header map[string]string\u000a\u000a\u0009// Body represents the response body.\u000a\u0009Body io.ReadCloser\u000a\u000a\u0009// ContentLength records the length of the associated content.  The\u000a\u0009// value -1 indicates that the length is unknown.  Unless RequestMethod\u000a\u0009// is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may\u000a\u0009// be read from Body.\u000a\u0009ContentLength int64\u000a\u000a\u0009// Contains transfer encodings from outer-most to inner-most. Value is\u000a\u0009// nil, means that &#34;identity&#34; encoding is used.\u000a\u0009TransferEncoding []string\u000a\u000a\u0009// Close records whether the header directed that the connection be\u000a\u0009// closed after reading Body.  The value is advice for clients: neither\u000a\u0009// ReadResponse nor Response.Write ever closes a connection.\u000a\u0009Close bool\u000a\u000a\u0009// Trailer maps trailer keys to values.  Like for Header, if the\u000a\u0009// response has multiple trailer lines with the same key, they will be\u000a\u0009// concatenated, delimited by commas.\u000a\u0009Trailer map[string]string\u000a}</pre>\u000a<p>\u000aResponse represents the response from an HTTP request.\u000a</p>\u000a\u000a","name":"Response","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.AddHeader!\">AddHeader</a></h2>\u000a<code>func (r *Response) AddHeader(key, value string)</code>\u000a<p>\u000aAddHeader adds a value under the given key.  Keys are not case sensitive.\u000a</p>\u000a\u000a","name":"AddHeader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.GetHeader!\">GetHeader</a></h2>\u000a<code>func (r *Response) GetHeader(key string) (value string)</code>\u000a<p>\u000aGetHeader returns the value of the response header with the given key.\u000aIf there were multiple headers with this key, their values are concatenated,\u000awith a comma delimiter.  If there were no response headers with the given\u000akey, GetHeader returns an empty string.  Keys are not case sensitive.\u000a</p>\u000a\u000a","name":"GetHeader"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.ProtoAtLeast!\">ProtoAtLeast</a></h2>\u000a<code>func (r *Response) ProtoAtLeast(major, minor int) bool</code>\u000a<p>\u000aProtoAtLeast returns whether the HTTP protocol used\u000ain the response is at least major.minor.\u000a</p>\u000a\u000a","name":"ProtoAtLeast"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.Write!\">Write</a></h2>\u000a<code>func (resp *Response) Write(w io.Writer) os.Error</code>\u000a<p>\u000aWrites the response (header, body and trailer) in wire format. This method\u000aconsults the following fields of resp:\u000a</p>\u000a<pre>StatusCode\u000aProtoMajor\u000aProtoMinor\u000aRequestMethod\u000aTransferEncoding\u000aTrailer\u000aBody\u000aContentLength\u000aHeader, values for non-canonical keys will have unpredictable behavior\u000a</pre>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ResponseWriter!\">ResponseWriter</a></h2>\u000a<pre>type ResponseWriter interface {\u000a\u0009// RemoteAddr returns the address of the client that sent the current request\u000a\u0009RemoteAddr() string\u000a\u000a\u0009// UsingTLS returns true if the client is connected using TLS\u000a\u0009UsingTLS() bool\u000a\u000a\u0009// SetHeader sets a header line in the eventual response.\u000a\u0009// For example, SetHeader(&#34;Content-Type&#34;, &#34;text/html; charset=utf-8&#34;)\u000a\u0009// will result in the header line\u000a\u0009//\u000a\u0009//\u0009Content-Type: text/html; charset=utf-8\u000a\u0009//\u000a\u0009// being sent.  UTF-8 encoded HTML is the default setting for\u000a\u0009// Content-Type in this library, so users need not make that\u000a\u0009// particular call.  Calls to SetHeader after WriteHeader (or Write)\u000a\u0009// are ignored.\u000a\u0009SetHeader(string, string)\u000a\u000a\u0009// Write writes the data to the connection as part of an HTTP reply.\u000a\u0009// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\u000a\u0009// before writing the data.\u000a\u0009Write([]byte) (int, os.Error)\u000a\u000a\u0009// WriteHeader sends an HTTP response header with status code.\u000a\u0009// If WriteHeader is not called explicitly, the first call to Write\u000a\u0009// will trigger an implicit WriteHeader(http.StatusOK).\u000a\u0009// Thus explicit calls to WriteHeader are mainly used to\u000a\u0009// send error codes.\u000a\u0009WriteHeader(int)\u000a\u000a\u0009// Flush sends any buffered data to the client.\u000a\u0009Flush()\u000a\u000a\u0009// Hijack lets the caller take over the connection.\u000a\u0009// After a call to Hijack(), the HTTP server library\u000a\u0009// will not do anything else with the connection.\u000a\u0009// It becomes the caller&#39;s responsibility to manage\u000a\u0009// and close the connection.\u000a\u0009Hijack() (io.ReadWriteCloser, *bufio.ReadWriter, os.Error)\u000a}</pre>\u000a<p>\u000aA ResponseWriter interface is used by an HTTP handler to\u000aconstruct an HTTP response.\u000a</p>\u000a\u000a","name":"ResponseWriter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServeMux!\">ServeMux</a></h2>\u000a<pre>type ServeMux struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aServeMux is an HTTP request multiplexer.\u000aIt matches the URL of each incoming request against a list of registered\u000apatterns and calls the handler for the pattern that\u000amost closely matches the URL.\u000a</p>\u000a<p>\u000aPatterns named fixed paths, like &#34;/favicon.ico&#34;,\u000aor subtrees, like &#34;/images/&#34; (note the trailing slash).\u000aPatterns must begin with /.\u000aLonger patterns take precedence over shorter ones, so that\u000aif there are handlers registered for both &#34;/images/&#34;\u000aand &#34;/images/thumbnails/&#34;, the latter handler will be\u000acalled for paths beginning &#34;/images/thumbnails/&#34; and the\u000aformer will receiver requests for any other paths in the\u000a&#34;/images/&#34; subtree.\u000a</p>\u000a<p>\u000aIn the future, the pattern syntax may be relaxed to allow\u000aan optional host-name at the beginning of the pattern,\u000aso that a handler might register for the two patterns\u000a&#34;/codesearch&#34; and &#34;codesearch.google.com/&#34;\u000awithout taking over requests for <a href=\"http://www.google.com/\">http://www.google.com/</a>.\u000a</p>\u000a<p>\u000aServeMux also takes care of sanitizing the URL request path,\u000aredirecting any request containing . or .. elements to an\u000aequivalent .- and ..-free URL.\u000a</p>\u000a\u000a","name":"ServeMux","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.Handle!\">Handle</a></h2>\u000a<code>func (mux *ServeMux) Handle(pattern string, handler Handler)</code>\u000a<p>\u000aHandle registers the handler for the given pattern.\u000a</p>\u000a\u000a","name":"Handle"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.HandleFunc!\">HandleFunc</a></h2>\u000a<code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\u000a<p>\u000aHandleFunc registers the handler function for the given pattern.\u000a</p>\u000a\u000a","name":"HandleFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.ServeHTTP!\">ServeHTTP</a></h2>\u000a<code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</code>\u000a<p>\u000aServeHTTP dispatches the request to the handler whose\u000apattern most closely matches the request URL.\u000a</p>\u000a\u000a","name":"ServeHTTP"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerConn!\">ServerConn</a></h2>\u000a<pre>type ServerConn struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA ServerConn reads requests and sends responses over an underlying\u000aconnection, until the HTTP keepalive logic commands an end. ServerConn\u000adoes not close the underlying connection. Instead, the user calls Close\u000aand regains control over the connection. ServerConn supports pipe-lining,\u000ai.e. requests can be read out of sync (but in the same order) while the\u000arespective responses are sent.\u000a</p>\u000a\u000a","name":"ServerConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Close!\">Close</a></h2>\u000a<code>func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader)</code>\u000a<p>\u000aClose detaches the ServerConn and returns the underlying connection as well\u000aas the read-side bufio which may have some left over data. Close may be\u000acalled before Read has signaled the end of the keep-alive logic. The user\u000ashould not call Close while Read or Write is in progress.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Pending!\">Pending</a></h2>\u000a<code>func (sc *ServerConn) Pending() int</code>\u000a<p>\u000aPending returns the number of unanswered requests\u000athat have been received on the connection.\u000a</p>\u000a\u000a","name":"Pending"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Read!\">Read</a></h2>\u000a<code>func (sc *ServerConn) Read() (req *Request, err os.Error)</code>\u000a<p>\u000aRead returns the next request on the wire. An ErrPersistEOF is returned if\u000ait is gracefully determined that there are no more requests (e.g. after the\u000afirst request on an HTTP/1.0 connection, or after a Connection:close on a\u000aHTTP/1.1 connection). Read can be called concurrently with Write, but not\u000awith another Read.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Write!\">Write</a></h2>\u000a<code>func (sc *ServerConn) Write(resp *Response) os.Error</code>\u000a<p>\u000aWrite writes a repsonse. To close the connection gracefully, set the\u000aResponse.Close field to true. Write should be considered operational until\u000ait returns an error, regardless of any errors returned on the Read side.\u000aWrite can be called concurrently with Read, but not with another Write.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URL!\">URL</a></h2>\u000a<pre>type URL struct {\u000a\u0009Raw          string // the original string\u000a\u0009Scheme       string // scheme\u000a\u0009RawAuthority string // [userinfo@]host\u000a\u0009RawUserinfo  string // userinfo\u000a\u0009Host         string // host\u000a\u0009RawPath      string // /path[?query][#fragment]\u000a\u0009Path         string // /path\u000a\u0009OpaquePath   bool   // path is opaque (unrooted when scheme is present)\u000a\u0009RawQuery     string // query\u000a\u0009Fragment     string // fragment\u000a}</pre>\u000a<p>\u000aA URL represents a parsed URL (technically, a URI reference).\u000aThe general form represented is:\u000a</p>\u000a<pre>scheme://[userinfo@]host/path[?query][#fragment]\u000a</pre>\u000a<p>\u000aThe Raw, RawAuthority, RawPath, and RawQuery fields are in &#34;wire format&#34;\u000a(special characters must be hex-escaped if not meant to have special meaning).\u000aAll other fields are logical values; &#39;+&#39; or &#39;%&#39; represent themselves.\u000a</p>\u000a<p>\u000aThe various Raw values are supplied in wire format because\u000aclients typically have to split them into pieces before further\u000adecoding.\u000a</p>\u000a\u000a","name":"URL","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.String!\">String</a></h2>\u000a<code>func (url *URL) String() string</code>\u000a<p>\u000aString reassembles url into a valid URL string.\u000a</p>\u000a<p>\u000aThere are redundant fields stored in the URL structure:\u000athe String method consults Scheme, Path, Host, RawUserinfo,\u000aRawQuery, and Fragment, but not Raw, RawPath or Authority.\u000a</p>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLError!\">URLError</a></h2>\u000a<pre>type URLError struct {\u000a\u0009Op    string\u000a\u0009URL   string\u000a\u0009Error os.Error\u000a}</pre>\u000a<p>\u000aURLError reports an error and the operation and URL that caused it.\u000a</p>\u000a\u000a","name":"URLError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:URLError\">func (*URLError)</a> <a href=\"?m:URLError.String!\">String</a></h2>\u000a<code>func (e *URLError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLEscapeError!\">URLEscapeError</a></h2>\u000a<pre>type URLEscapeError string</pre>\u000a\u000a","name":"URLEscapeError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:URLEscapeError\">func (URLEscapeError)</a> <a href=\"?m:URLEscapeError.String!\">String</a></h2>\u000a<code>func (e URLEscapeError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalHeaderKey!\">CanonicalHeaderKey</a></h2>\u000a<code>func CanonicalHeaderKey(s string) string</code>\u000a<p>\u000aCanonicalHeaderKey returns the canonical format of the\u000aHTTP header key s.  The canonicalization converts the first\u000aletter and any letter following a hyphen to upper case;\u000athe rest are converted to lowercase.  For example, the\u000acanonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.\u000a</p>\u000a\u000a","name":"CanonicalHeaderKey"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalPath!\">CanonicalPath</a></h2>\u000a<code>func CanonicalPath(path string) string</code>\u000a<p>\u000aCanonicalPath applies the algorithm specified in RFC 2396 to\u000asimplify the path, removing unnecessary  . and .. elements.\u000a</p>\u000a\u000a","name":"CanonicalPath"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpRequest!\">DumpRequest</a></h2>\u000a<code>func DumpRequest(req *Request, body bool) (dump []byte, err os.Error)</code>\u000a<p>\u000aDumpRequest returns the wire representation of req,\u000aoptionally including the request body, for debugging.\u000aDumpRequest is semantically a no-op, but in order to\u000adump the body, it reads the body data into memory and\u000achanges req.Body to refer to the in-memory copy.\u000a</p>\u000a\u000a","name":"DumpRequest"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpResponse!\">DumpResponse</a></h2>\u000a<code>func DumpResponse(resp *Response, body bool) (dump []byte, err os.Error)</code>\u000a<p>\u000aDumpResponse is like DumpRequest but dumps a response.\u000a</p>\u000a\u000a","name":"DumpResponse"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Error!\">Error</a></h2>\u000a<code>func Error(w ResponseWriter, error string, code int)</code>\u000a<p>\u000aError replies to the request with the specified error message and HTTP code.\u000a</p>\u000a\u000a","name":"Error"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EscapeUserinfo!\">EscapeUserinfo</a></h2>\u000a<code>func EscapeUserinfo(user, password string) string</code>\u000a<p>\u000aEscapeUserinfo combines user and password in the form\u000auser:password (or just user if password is empty) and then\u000aescapes it for use as the URL.RawUserinfo field.\u000a</p>\u000a<p>\u000aThis functionality should only be used with legacy web sites.\u000aRFC 2396 warns that interpreting Userinfo this way\u000a&ldquo;is NOT RECOMMENDED, because the passing of authentication\u000ainformation in clear text (such as URI) has proven to be a\u000asecurity risk in almost every case where it has been used.&rdquo;\u000a</p>\u000a\u000a","name":"EscapeUserinfo"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileServer!\">FileServer</a></h2>\u000a<code>func FileServer(root, prefix string) Handler</code>\u000a<p>\u000aFileServer returns a handler that serves HTTP requests\u000awith the contents of the file system rooted at root.\u000aIt strips prefix from the incoming requests before\u000alooking up the file name in the file system.\u000a</p>\u000a\u000a","name":"FileServer"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Get!\">Get</a></h2>\u000a<code>func Get(url string) (r *Response, finalURL string, err os.Error)</code>\u000a<p>\u000aGet issues a GET to the specified URL.  If the response is one of the following\u000aredirect codes, it follows the redirect, up to a maximum of 10 redirects:\u000a</p>\u000a<pre>301 (Moved Permanently)\u000a302 (Found)\u000a303 (See Other)\u000a307 (Temporary Redirect)\u000a</pre>\u000a<p>\u000afinalURL is the URL from which the response was fetched -- identical to the\u000ainput URL unless redirects were followed.\u000a</p>\u000a<p>\u000aCaller should close r.Body when done reading it.\u000a</p>\u000a\u000a","name":"Get"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Handle!\">Handle</a></h2>\u000a<code>func Handle(pattern string, handler Handler)</code>\u000a<p>\u000aHandle registers the handler for the given pattern\u000ain the DefaultServeMux.\u000a</p>\u000a\u000a","name":"Handle"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HandleFunc!\">HandleFunc</a></h2>\u000a<code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\u000a<p>\u000aHandleFunc registers the handler function for the given pattern\u000ain the DefaultServeMux.\u000a</p>\u000a\u000a","name":"HandleFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Head!\">Head</a></h2>\u000a<code>func Head(url string) (r *Response, err os.Error)</code>\u000a<p>\u000aHead issues a HEAD to the specified URL.\u000a</p>\u000a\u000a","name":"Head"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServe!\">ListenAndServe</a></h2>\u000a<code>func ListenAndServe(addr string, handler Handler) os.Error</code>\u000a<p>\u000aListenAndServe listens on the TCP network address addr\u000aand then calls Serve with handler to handle requests\u000aon incoming connections.  Handler is typically nil,\u000ain which case the DefaultServeMux is used.\u000a</p>\u000a<p>\u000aA trivial example server is:\u000a</p>\u000a<pre>package main\u000a\u000aimport (\u000a\u0009&#34;http&#34;\u000a\u0009&#34;io&#34;\u000a\u0009&#34;log&#34;\u000a)\u000a\u000a// hello world, the web server\u000afunc HelloServer(w http.ResponseWriter, req *http.Request) {\u000a\u0009io.WriteString(w, &#34;hello, world!\\n&#34;)\u000a}\u000a\u000afunc main() {\u000a\u0009http.HandleFunc(&#34;/hello&#34;, HelloServer)\u000a\u0009err := http.ListenAndServe(&#34;:12345&#34;, nil)\u000a\u0009if err != nil {\u000a\u0009\u0009log.Exit(&#34;ListenAndServe: &#34;, err.String())\u000a\u0009}\u000a}\u000a</pre>\u000a\u000a","name":"ListenAndServe"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServeTLS!\">ListenAndServeTLS</a></h2>\u000a<code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) os.Error</code>\u000a<p>\u000aListenAndServeTLS acts identically to ListenAndServe, except that it\u000aexpects HTTPS connections. Additionally, files containing a certificate and\u000amatching private key for the server must be provided.\u000a</p>\u000a<p>\u000aA trivial example server is:\u000a</p>\u000a<pre>import (\u000a\u0009&#34;http&#34;\u000a\u0009&#34;log&#34;\u000a)\u000a\u000afunc handler(w http.ResponseWriter, req *http.Request) {\u000a\u0009w.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)\u000a\u0009w.Write([]byte(&#34;This is an example server.\\n&#34;))\u000a}\u000a\u000afunc main() {\u000a\u0009http.HandleFunc(&#34;/&#34;, handler)\u000a\u0009log.Printf(&#34;About to listen on 10443. Go to <a href=\"https://127.0.0.1:10443/\">https://127.0.0.1:10443/</a>&#34;)\u000a\u0009err := http.ListenAndServeTLS(&#34;:10443&#34;, &#34;cert.pem&#34;, &#34;key.pem&#34;, nil)\u000a\u0009if err != nil {\u000a\u0009\u0009log.Exit(err)\u000a\u0009}\u000a}\u000a</pre>\u000a<p>\u000aOne can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.\u000a</p>\u000a\u000a","name":"ListenAndServeTLS"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewChunkedWriter!\">NewChunkedWriter</a></h2>\u000a<code>func NewChunkedWriter(w io.Writer) io.WriteCloser</code>\u000a<p>\u000aNewChunkedWriter returns a new writer that translates writes into HTTP\u000a&#34;chunked&#34; format before writing them to w.  Closing the returned writer\u000asends the final 0-length chunk that marks the end of the stream.\u000a</p>\u000a\u000a","name":"NewChunkedWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClientConn!\">NewClientConn</a></h2>\u000a<code>func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</code>\u000a<p>\u000aNewClientConn returns a new ClientConn reading and writing c.  If r is not\u000anil, it is the buffer to use when reading c.\u000a</p>\u000a\u000a","name":"NewClientConn"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServeMux!\">NewServeMux</a></h2>\u000a<code>func NewServeMux() *ServeMux</code>\u000a<p>\u000aNewServeMux allocates and returns a new ServeMux.\u000a</p>\u000a\u000a","name":"NewServeMux"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServerConn!\">NewServerConn</a></h2>\u000a<code>func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</code>\u000a<p>\u000aNewServerConn returns a new ServerConn reading and writing c.  If r is not\u000anil, it is the buffer to use when reading c.\u000a</p>\u000a\u000a","name":"NewServerConn"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFound!\">NotFound</a></h2>\u000a<code>func NotFound(w ResponseWriter, r *Request)</code>\u000a<p>\u000aNotFound replies to the request with an HTTP 404 not found error.\u000a</p>\u000a\u000a","name":"NotFound"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFoundHandler!\">NotFoundHandler</a></h2>\u000a<code>func NotFoundHandler() Handler</code>\u000a<p>\u000aNotFoundHandler returns a simple request handler\u000athat replies to each request with a &ldquo;404 page not found&rdquo; reply.\u000a</p>\u000a\u000a","name":"NotFoundHandler"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseQuery!\">ParseQuery</a></h2>\u000a<code>func ParseQuery(query string) (m map[string][]string, err os.Error)</code>\u000a<p>\u000aParseQuery parses the URL-encoded query string and returns\u000aa map listing the values specified for each key.\u000aParseQuery always returns a non-nil map containing all the\u000avalid query parameters found; err describes the first decoding error\u000aencountered, if any.\u000a</p>\u000a\u000a","name":"ParseQuery"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURL!\">ParseURL</a></h2>\u000a<code>func ParseURL(rawurl string) (url *URL, err os.Error)</code>\u000a<p>\u000aParseURL parses rawurl into a URL structure.\u000aThe string rawurl is assumed not to have a #fragment suffix.\u000a(Web browsers strip #fragment before sending the URL to a web server.)\u000a</p>\u000a\u000a","name":"ParseURL"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURLReference!\">ParseURLReference</a></h2>\u000a<code>func ParseURLReference(rawurlref string) (url *URL, err os.Error)</code>\u000a<p>\u000aParseURLReference is like ParseURL but allows a trailing #fragment.\u000a</p>\u000a\u000a","name":"ParseURLReference"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Post!\">Post</a></h2>\u000a<code>func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error)</code>\u000a<p>\u000aPost issues a POST to the specified URL.\u000a</p>\u000a<p>\u000aCaller should close r.Body when done reading it.\u000a</p>\u000a\u000a","name":"Post"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PostForm!\">PostForm</a></h2>\u000a<code>func PostForm(url string, data map[string]string) (r *Response, err os.Error)</code>\u000a<p>\u000aPostForm issues a POST to the specified URL,\u000awith data&#39;s keys and values urlencoded as the request body.\u000a</p>\u000a<p>\u000aCaller should close r.Body when done reading it.\u000a</p>\u000a\u000a","name":"PostForm"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadRequest!\">ReadRequest</a></h2>\u000a<code>func ReadRequest(b *bufio.Reader) (req *Request, err os.Error)</code>\u000a<p>\u000aReadRequest reads and parses a request from b.\u000a</p>\u000a\u000a","name":"ReadRequest"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadResponse!\">ReadResponse</a></h2>\u000a<code>func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error)</code>\u000a<p>\u000aReadResponse reads and returns an HTTP response from r.  The RequestMethod\u000aparameter specifies the method used in the corresponding request (e.g.,\u000a&#34;GET&#34;, &#34;HEAD&#34;).  Clients must call resp.Body.Close when finished reading\u000aresp.Body.  After that call, clients can inspect resp.Trailer to find\u000akey/value pairs included in the response trailer.\u000a</p>\u000a\u000a","name":"ReadResponse"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Redirect!\">Redirect</a></h2>\u000a<code>func Redirect(w ResponseWriter, r *Request, url string, code int)</code>\u000a<p>\u000aRedirect replies to the request with a redirect to url,\u000awhich may be a path relative to the request path.\u000a</p>\u000a\u000a","name":"Redirect"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RedirectHandler!\">RedirectHandler</a></h2>\u000a<code>func RedirectHandler(url string, code int) Handler</code>\u000a<p>\u000aRedirectHandler returns a request handler that redirects\u000aeach request it receives to the given url using the given\u000astatus code.\u000a</p>\u000a\u000a","name":"RedirectHandler"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Serve!\">Serve</a></h2>\u000a<code>func Serve(l net.Listener, handler Handler) os.Error</code>\u000a<p>\u000aServe accepts incoming HTTP connections on the listener l,\u000acreating a new service thread for each.  The service threads\u000aread requests and then call handler to reply to them.\u000aHandler is typically nil, in which case the DefaultServeMux is used.\u000a</p>\u000a\u000a","name":"Serve"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeFile!\">ServeFile</a></h2>\u000a<code>func ServeFile(w ResponseWriter, r *Request, name string)</code>\u000a<p>\u000aServeFile replies to the request with the contents of the named file or directory.\u000a</p>\u000a\u000a","name":"ServeFile"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:StatusText!\">StatusText</a></h2>\u000a<code>func StatusText(code int) string</code>\u000a<p>\u000aStatusText returns a text for the HTTP status code. It returns the empty\u000astring if the code is unknown.\u000a</p>\u000a\u000a","name":"StatusText"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLEscape!\">URLEscape</a></h2>\u000a<code>func URLEscape(s string) string</code>\u000a<p>\u000aURLEscape converts a string into &ldquo;URL encoded&rdquo; form.\u000aDespite the name, this encoding applies only to individual\u000acomponents of the query portion of the URL.\u000a</p>\u000a\u000a","name":"URLEscape"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLUnescape!\">URLUnescape</a></h2>\u000a<code>func URLUnescape(s string) (string, os.Error)</code>\u000a<p>\u000aURLUnescape unescapes a string in &ldquo;URL encoded&rdquo; form,\u000aconverting %AB into the byte 0xAB and &#39;+&#39; into &#39; &#39; (space).\u000aIt returns an error if any % is not followed\u000aby two hexadecimal digits.\u000aDespite the name, this encoding applies only to individual\u000acomponents of the query portion of the URL.\u000a</p>\u000a\u000a","name":"URLUnescape"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnescapeUserinfo!\">UnescapeUserinfo</a></h2>\u000a<code>func UnescapeUserinfo(rawUserinfo string) (user, password string, err os.Error)</code>\u000a<p>\u000aUnescapeUserinfo parses the RawUserinfo field of a URL\u000aas the form user or user:password and unescapes and returns\u000athe two halves.\u000a</p>\u000a<p>\u000aThis functionality should only be used with legacy web sites.\u000aRFC 2396 warns that interpreting Userinfo this way\u000a&ldquo;is NOT RECOMMENDED, because the passing of authentication\u000ainformation in clear text (such as URI) has proven to be a\u000asecurity risk in almost every case where it has been used.&rdquo;\u000a</p>\u000a\u000a","name":"UnescapeUserinfo"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TimeFormat!\">TimeFormat</a></h2>\u000a<pre>const TimeFormat = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;</pre>\u000a<p>\u000aTimeFormat is the time format to use with\u000atime.Parse and time.Time.Format when parsing\u000aor generating times in HTTP headers.\u000aIt is like time.RFC1123 but hard codes GMT as the time zone.\u000a</p>\u000a\u000a","names":["TimeFormat"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:StatusContinue!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009StatusContinue           = 100\u000a\u0009StatusSwitchingProtocols = 101\u000a\u000a\u0009StatusOK                   = 200\u000a\u0009StatusCreated              = 201\u000a\u0009StatusAccepted             = 202\u000a\u0009StatusNonAuthoritativeInfo = 203\u000a\u0009StatusNoContent            = 204\u000a\u0009StatusResetContent         = 205\u000a\u0009StatusPartialContent       = 206\u000a\u000a\u0009StatusMultipleChoices   = 300\u000a\u0009StatusMovedPermanently  = 301\u000a\u0009StatusFound             = 302\u000a\u0009StatusSeeOther          = 303\u000a\u0009StatusNotModified       = 304\u000a\u0009StatusUseProxy          = 305\u000a\u0009StatusTemporaryRedirect = 307\u000a\u000a\u0009StatusBadRequest                   = 400\u000a\u0009StatusUnauthorized                 = 401\u000a\u0009StatusPaymentRequired              = 402\u000a\u0009StatusForbidden                    = 403\u000a\u0009StatusNotFound                     = 404\u000a\u0009StatusMethodNotAllowed             = 405\u000a\u0009StatusNotAcceptable                = 406\u000a\u0009StatusProxyAuthRequired            = 407\u000a\u0009StatusRequestTimeout               = 408\u000a\u0009StatusConflict                     = 409\u000a\u0009StatusGone                         = 410\u000a\u0009StatusLengthRequired               = 411\u000a\u0009StatusPreconditionFailed           = 412\u000a\u0009StatusRequestEntityTooLarge        = 413\u000a\u0009StatusRequestURITooLong            = 414\u000a\u0009StatusUnsupportedMediaType         = 415\u000a\u0009StatusRequestedRangeNotSatisfiable = 416\u000a\u0009StatusExpectationFailed            = 417\u000a\u000a\u0009StatusInternalServerError     = 500\u000a\u0009StatusNotImplemented          = 501\u000a\u0009StatusBadGateway              = 502\u000a\u0009StatusServiceUnavailable      = 503\u000a\u0009StatusGatewayTimeout          = 504\u000a\u0009StatusHTTPVersionNotSupported = 505\u000a)</pre>\u000a<p>\u000aHTTP status codes, defined in RFC 2616.\u000a</p>\u000a\u000a","names":["StatusContinue","StatusSwitchingProtocols","StatusOK","StatusCreated","StatusAccepted","StatusNonAuthoritativeInfo","StatusNoContent","StatusResetContent","StatusPartialContent","StatusMultipleChoices","StatusMovedPermanently","StatusFound","StatusSeeOther","StatusNotModified","StatusUseProxy","StatusTemporaryRedirect","StatusBadRequest","StatusUnauthorized","StatusPaymentRequired","StatusForbidden","StatusNotFound","StatusMethodNotAllowed","StatusNotAcceptable","StatusProxyAuthRequired","StatusRequestTimeout","StatusConflict","StatusGone","StatusLengthRequired","StatusPreconditionFailed","StatusRequestEntityTooLarge","StatusRequestURITooLong","StatusUnsupportedMediaType","StatusRequestedRangeNotSatisfiable","StatusExpectationFailed","StatusInternalServerError","StatusNotImplemented","StatusBadGateway","StatusServiceUnavailable","StatusGatewayTimeout","StatusHTTPVersionNotSupported"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrLineTooLong!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009ErrLineTooLong          = &amp;ProtocolError{&#34;header line too long&#34;}\u000a\u0009ErrHeaderTooLong        = &amp;ProtocolError{&#34;header too long&#34;}\u000a\u0009ErrShortBody            = &amp;ProtocolError{&#34;entity body too short&#34;}\u000a\u0009ErrNotSupported         = &amp;ProtocolError{&#34;feature not supported&#34;}\u000a\u0009ErrUnexpectedTrailer    = &amp;ProtocolError{&#34;trailer header without chunked transfer encoding&#34;}\u000a\u0009ErrMissingContentLength = &amp;ProtocolError{&#34;missing ContentLength in HEAD response&#34;}\u000a\u0009ErrNotMultipart         = &amp;ProtocolError{&#34;request Content-Type isn&#39;t multipart/form-data&#34;}\u000a\u0009ErrMissingBoundary      = &amp;ProtocolError{&#34;no multipart boundary param Content-Type&#34;}\u000a)</pre>\u000a\u000a","names":["ErrLineTooLong","ErrHeaderTooLong","ErrShortBody","ErrNotSupported","ErrUnexpectedTrailer","ErrMissingContentLength","ErrNotMultipart","ErrMissingBoundary"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrWriteAfterFlush!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009ErrWriteAfterFlush = os.NewError(&#34;Conn.Write called after Flush&#34;)\u000a\u0009ErrBodyNotAllowed  = os.NewError(&#34;http: response status code does not allow body&#34;)\u000a\u0009ErrHijacked        = os.NewError(&#34;Conn has been hijacked&#34;)\u000a)</pre>\u000a<p>\u000aErrors introduced by the HTTP server.\u000a</p>\u000a\u000a","names":["ErrWriteAfterFlush","ErrBodyNotAllowed","ErrHijacked"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultServeMux!\">DefaultServeMux</a></h2>\u000a<pre>var DefaultServeMux = NewServeMux()</pre>\u000a<p>\u000aDefaultServeMux is the default ServeMux used by Serve.\u000a</p>\u000a\u000a","names":["DefaultServeMux"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrPersistEOF!\">ErrPersistEOF</a></h2>\u000a<pre>var ErrPersistEOF = &amp;ProtocolError{&#34;persistent connection closed&#34;}</pre>\u000a\u000a","names":["ErrPersistEOF"],"type":""}]}