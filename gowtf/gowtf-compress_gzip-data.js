var gowtfData = {"index":"index.html","html":"<p>\u000aThe gzip package implements reading and writing of\u000agzip format compressed files, as specified in RFC 1952.\u000a</p>\u000a","name":"gzip","filenames":["/home/nsf/go/src/pkg/compress/gzip/gzip.go","/home/nsf/go/src/pkg/compress/gzip/gunzip.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Compressor!\">Compressor</a></h2>\u000a<pre>type Compressor struct {\u000a\u0009Header\u000a\u0009w          io.Writer\u000a\u0009level      int\u000a\u0009compressor io.WriteCloser\u000a\u0009digest     hash.Hash32\u000a\u0009size       uint32\u000a\u0009closed     bool\u000a\u0009buf        [10]byte\u000a\u0009err        os.Error\u000a}</pre>\u000a<p>\u000aA Compressor is an io.WriteCloser that satisfies writes by compressing data written\u000ato its wrapped io.Writer.\u000a</p>\u000a\u000a","name":"Compressor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Compressor\">func (*Compressor)</a> <a href=\"?m:Compressor.Close!\">Close</a></h2>\u000a<code>func (z *Compressor) Close() os.Error</code>\u000a<p>\u000aCalling Close does not close the wrapped io.Writer originally passed to NewWriter.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Compressor\">func (*Compressor)</a> <a href=\"?m:Compressor.Write!\">Write</a></h2>\u000a<code>func (z *Compressor) Write(p []byte) (int, os.Error)</code>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decompressor!\">Decompressor</a></h2>\u000a<pre>type Decompressor struct {\u000a\u0009Header\u000a\u0009r            flate.Reader\u000a\u0009decompressor io.ReadCloser\u000a\u0009digest       hash.Hash32\u000a\u0009size         uint32\u000a\u0009flg          byte\u000a\u0009buf          [512]byte\u000a\u0009err          os.Error\u000a}</pre>\u000a<p>\u000aAn Decompressor is an io.Reader that can be read to retrieve\u000auncompressed data from a gzip-format compressed file.\u000a</p>\u000a<p>\u000aIn general, a gzip file can be a concatenation of gzip files,\u000aeach with its own header.  Reads from the Decompressor\u000areturn the concatenation of the uncompressed data of each.\u000aOnly the first header is recorded in the Decompressor fields.\u000a</p>\u000a<p>\u000aGzip files store a length and checksum of the uncompressed data.\u000aThe Decompressor will return a ChecksumError when Read\u000areaches the end of the uncompressed data if it does not\u000ahave the expected length or checksum.  Clients should treat data\u000areturned by Read as tentative until they receive the successful\u000a(zero length, nil error) Read marking the end of the data.\u000a</p>\u000a\u000a","name":"Decompressor","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Decompressor\">func (*Decompressor)</a> <a href=\"?m:Decompressor.Close!\">Close</a></h2>\u000a<code>func (z *Decompressor) Close() os.Error</code>\u000a<p>\u000aCalling Close does not close the wrapped io.Reader originally passed to NewReader.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Decompressor\">func (*Decompressor)</a> <a href=\"?m:Decompressor.Read!\">Read</a></h2>\u000a<code>func (z *Decompressor) Read(p []byte) (n int, err os.Error)</code>\u000a\u000a","name":"Read"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Header!\">Header</a></h2>\u000a<pre>type Header struct {\u000a\u0009Comment string // comment\u000a\u0009Extra   []byte // &#34;extra data&#34;\u000a\u0009Mtime   uint32 // modification time (seconds since January 1, 1970)\u000a\u0009Name    string // file name\u000a\u0009OS      byte   // operating system type\u000a}</pre>\u000a<p>\u000aThe gzip file stores a header giving metadata about the compressed file.\u000aThat header is exposed as the fields of the Compressor and Decompressor structs.\u000a</p>\u000a\u000a","name":"Header","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\u000a<code>func NewReader(r io.Reader) (*Decompressor, os.Error)</code>\u000a<p>\u000aNewReader creates a new Decompressor reading the given reader.\u000aThe implementation buffers input and may read more data than necessary from r.\u000aIt is the caller&#39;s responsibility to call Close on the Decompressor when done.\u000a</p>\u000a\u000a","name":"NewReader"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\u000a<code>func NewWriter(w io.Writer) (*Compressor, os.Error)</code>\u000a<p>\u000aNewWriter calls NewWriterLevel with the default compression level.\u000a</p>\u000a\u000a","name":"NewWriter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriterLevel!\">NewWriterLevel</a></h2>\u000a<code>func NewWriterLevel(w io.Writer, level int) (*Compressor, os.Error)</code>\u000a<p>\u000aNewWriterLevel creates a new Compressor writing to the given writer.\u000aWrites may be buffered and not flushed until Close.\u000aCallers that wish to set the fields in Compressor.Header must\u000ado so before the first call to Write or Close.\u000aIt is the caller&#39;s responsibility to call Close on the WriteCloser when done.\u000alevel is the compression level, which can be DefaultCompression, NoCompression,\u000aor any integer value between BestSpeed and BestCompression (inclusive).\u000a</p>\u000a\u000a","name":"NewWriterLevel"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:NoCompression!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009NoCompression      = flate.NoCompression\u000a\u0009BestSpeed          = flate.BestSpeed\u000a\u0009BestCompression    = flate.BestCompression\u000a\u0009DefaultCompression = flate.DefaultCompression\u000a)</pre>\u000a<p>\u000aThese constants are copied from the flate package, so that code that imports\u000a&#34;compress/gzip&#34; does not also have to import &#34;compress/flate&#34;.\u000a</p>\u000a\u000a","names":["NoCompression","BestSpeed","BestCompression","DefaultCompression"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:HeaderError!\">HeaderError</a></h2>\u000a<pre>var HeaderError os.Error = os.ErrorString(&#34;invalid gzip header&#34;)</pre>\u000a\u000a","names":["HeaderError"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ChecksumError!\">ChecksumError</a></h2>\u000a<pre>var ChecksumError os.Error = os.ErrorString(&#34;gzip checksum error&#34;)</pre>\u000a\u000a","names":["ChecksumError"],"type":""}]}