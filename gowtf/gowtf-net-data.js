var gowtfData = {"index":"index.html","html":"<p>\u000aThe net package provides a portable interface to Unix\u000anetworks sockets, including TCP/IP, UDP, domain name\u000aresolution, and Unix domain sockets.\u000a</p>\u000a","name":"net","filenames":["/home/nsf/go/src/pkg/net/hosts.go","/home/nsf/go/src/pkg/net/pipe.go","/home/nsf/go/src/pkg/net/newpollserver.go","/home/nsf/go/src/pkg/net/dnsmsg.go","/home/nsf/go/src/pkg/net/parse.go","/home/nsf/go/src/pkg/net/ipsock.go","/home/nsf/go/src/pkg/net/udpsock.go","/home/nsf/go/src/pkg/net/dnsconfig.go","/home/nsf/go/src/pkg/net/dnsclient.go","/home/nsf/go/src/pkg/net/port.go","/home/nsf/go/src/pkg/net/iprawsock.go","/home/nsf/go/src/pkg/net/ip.go","/home/nsf/go/src/pkg/net/net.go","/home/nsf/go/src/pkg/net/sock.go","/home/nsf/go/src/pkg/net/fd.go","/home/nsf/go/src/pkg/net/tcpsock.go","/home/nsf/go/src/pkg/net/unixsock.go","/home/nsf/go/src/pkg/net/dial.go","/home/nsf/go/src/pkg/net/fd_linux.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Addr!\">Addr</a></h2>\u000a<pre>type Addr interface {\u000a\u0009Network() string // name of the network\u000a\u0009String() string  // string form of address\u000a}</pre>\u000a<p>\u000aAddr represents a network end point address.\u000a</p>\u000a\u000a","name":"Addr","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AddrError!\">AddrError</a></h2>\u000a<pre>type AddrError struct {\u000a\u0009Error string\u000a\u0009Addr  string\u000a}</pre>\u000a\u000a","name":"AddrError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.String!\">String</a></h2>\u000a<code>func (e *AddrError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.Temporary!\">Temporary</a></h2>\u000a<code>func (e *AddrError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.Timeout!\">Timeout</a></h2>\u000a<code>func (e *AddrError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\u000a<pre>type Conn interface {\u000a\u0009// Read reads data from the connection.\u000a\u0009// Read can be made to time out and return a net.Error with Timeout() == true\u000a\u0009// after a fixed time limit; see SetTimeout and SetReadTimeout.\u000a\u0009Read(b []byte) (n int, err os.Error)\u000a\u000a\u0009// Write writes data to the connection.\u000a\u0009// Write can be made to time out and return a net.Error with Timeout() == true\u000a\u0009// after a fixed time limit; see SetTimeout and SetWriteTimeout.\u000a\u0009Write(b []byte) (n int, err os.Error)\u000a\u000a\u0009// Close closes the connection.\u000a\u0009// The error returned is an os.Error to satisfy io.Closer;\u000a\u0009Close() os.Error\u000a\u000a\u0009// LocalAddr returns the local network address.\u000a\u0009LocalAddr() Addr\u000a\u000a\u0009// RemoteAddr returns the remote network address.\u000a\u0009RemoteAddr() Addr\u000a\u000a\u0009// SetTimeout sets the read and write deadlines associated\u000a\u0009// with the connection.\u000a\u0009SetTimeout(nsec int64) os.Error\u000a\u000a\u0009// SetReadTimeout sets the time (in nanoseconds) that\u000a\u0009// Read will wait for data before returning an error with Timeout() == true.\u000a\u0009// Setting nsec == 0 (the default) disables the deadline.\u000a\u0009SetReadTimeout(nsec int64) os.Error\u000a\u000a\u0009// SetWriteTimeout sets the time (in nanoseconds) that\u000a\u0009// Write will wait to send its data before returning an error with Timeout() == true.\u000a\u0009// Setting nsec == 0 (the default) disables the deadline.\u000a\u0009// Even if write times out, it may return n &gt; 0, indicating that\u000a\u0009// some of the data was successfully written.\u000a\u0009SetWriteTimeout(nsec int64) os.Error\u000a}</pre>\u000a<p>\u000aConn is a generic stream-oriented network connection.\u000a</p>\u000a\u000a","name":"Conn","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DNSConfigError!\">DNSConfigError</a></h2>\u000a<pre>type DNSConfigError struct {\u000a\u0009Error os.Error\u000a}</pre>\u000a\u000a","name":"DNSConfigError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.String!\">String</a></h2>\u000a<code>func (e *DNSConfigError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.Temporary!\">Temporary</a></h2>\u000a<code>func (e *DNSConfigError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.Timeout!\">Timeout</a></h2>\u000a<code>func (e *DNSConfigError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DNSError!\">DNSError</a></h2>\u000a<pre>type DNSError struct {\u000a\u0009Error     string // description of the error\u000a\u0009Name      string // name looked for\u000a\u0009Server    string // server used\u000a\u0009IsTimeout bool\u000a}</pre>\u000a<p>\u000aDNSError represents a DNS lookup error.\u000a</p>\u000a\u000a","name":"DNSError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.String!\">String</a></h2>\u000a<code>func (e *DNSError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.Temporary!\">Temporary</a></h2>\u000a<code>func (e *DNSError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.Timeout!\">Timeout</a></h2>\u000a<code>func (e *DNSError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error interface {\u000a\u0009os.Error\u000a\u0009Timeout() bool   // Is the error a timeout?\u000a\u0009Temporary() bool // Is the error temporary?\u000a}</pre>\u000a<p>\u000aAn Error represents a network error.\u000a</p>\u000a\u000a","name":"Error","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IP!\">IP</a></h2>\u000a<pre>type IP []byte</pre>\u000a<p>\u000aAn IP is a single IP address, an array of bytes.\u000aFunctions in this package accept either 4-byte (IP v4)\u000aor 16-byte (IP v6) arrays as input.  Unless otherwise\u000aspecified, functions in this package always return\u000aIP addresses in 16-byte form using the canonical\u000aembedding.\u000a</p>\u000a<p>\u000aNote that in this documentation, referring to an\u000aIP address as an IPv4 address or an IPv6 address\u000ais a semantic property of the address, not just the\u000alength of the byte array: a 16-byte array can still\u000abe an IPv4 address.\u000a</p>\u000a\u000a","name":"IP","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.DefaultMask!\">DefaultMask</a></h2>\u000a<code>func (ip IP) DefaultMask() IPMask</code>\u000a<p>\u000aDefaultMask returns the default IP mask for the IP address ip.\u000aOnly IPv4 addresses have default masks; DefaultMask returns\u000anil if ip is not a valid IPv4 address.\u000a</p>\u000a\u000a","name":"DefaultMask"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.Mask!\">Mask</a></h2>\u000a<code>func (ip IP) Mask(mask IPMask) IP</code>\u000a<p>\u000aMask returns the result of masking the IP address ip with mask.\u000a</p>\u000a\u000a","name":"Mask"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.String!\">String</a></h2>\u000a<code>func (ip IP) String() string</code>\u000a<p>\u000aString returns the string form of the IP address ip.\u000aIf the address is an IPv4 address, the string representation\u000ais dotted decimal (&#34;74.125.19.99&#34;).  Otherwise the representation\u000ais IPv6 (&#34;2001:4860:0:2001::68&#34;).\u000a</p>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.To16!\">To16</a></h2>\u000a<code>func (ip IP) To16() IP</code>\u000a<p>\u000aTo16 converts the IP address ip to a 16-byte representation.\u000aIf ip is not an IP address (it is the wrong length), To16 returns nil.\u000a</p>\u000a\u000a","name":"To16"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.To4!\">To4</a></h2>\u000a<code>func (ip IP) To4() IP</code>\u000a<p>\u000aTo4 converts the IPv4 address ip to a 4-byte representation.\u000aIf ip is not an IPv4 address, To4 returns nil.\u000a</p>\u000a\u000a","name":"To4"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPAddr!\">IPAddr</a></h2>\u000a<pre>type IPAddr struct {\u000a\u0009IP IP\u000a}</pre>\u000a<p>\u000aIPAddr represents the address of a IP end point.\u000a</p>\u000a\u000a","name":"IPAddr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPAddr\">func (*IPAddr)</a> <a href=\"?m:IPAddr.Network!\">Network</a></h2>\u000a<code>func (a *IPAddr) Network() string</code>\u000a<p>\u000aNetwork returns the address&#39;s network name, &#34;ip&#34;.\u000a</p>\u000a\u000a","name":"Network"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPAddr\">func (*IPAddr)</a> <a href=\"?m:IPAddr.String!\">String</a></h2>\u000a<code>func (a *IPAddr) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPConn!\">IPConn</a></h2>\u000a<pre>type IPConn struct {\u000a\u0009fd *netFD\u000a}</pre>\u000a<p>\u000aIPConn is the implementation of the Conn and PacketConn\u000ainterfaces for IP network connections.\u000a</p>\u000a\u000a","name":"IPConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.BindToDevice!\">BindToDevice</a></h2>\u000a<code>func (c *IPConn) BindToDevice(device string) os.Error</code>\u000a<p>\u000aBindToDevice binds an IPConn to a network interface.\u000a</p>\u000a\u000a","name":"BindToDevice"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Close!\">Close</a></h2>\u000a<code>func (c *IPConn) Close() os.Error</code>\u000a<p>\u000aClose closes the IP connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.LocalAddr!\">LocalAddr</a></h2>\u000a<code>func (c *IPConn) LocalAddr() Addr</code>\u000a<p>\u000aLocalAddr returns the local network address.\u000a</p>\u000a\u000a","name":"LocalAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Read!\">Read</a></h2>\u000a<code>func (c *IPConn) Read(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead implements the net.Conn Read method.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.ReadFrom!\">ReadFrom</a></h2>\u000a<code>func (c *IPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\u000a<p>\u000aReadFrom implements the net.PacketConn ReadFrom method.\u000a</p>\u000a\u000a","name":"ReadFrom"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.ReadFromIP!\">ReadFromIP</a></h2>\u000a<code>func (c *IPConn) ReadFromIP(b []byte) (n int, addr *IPAddr, err os.Error)</code>\u000a<p>\u000aReadFromIP reads a IP packet from c, copying the payload into b.\u000aIt returns the number of bytes copied into b and the return address\u000athat was on the packet.\u000a</p>\u000a<p>\u000aReadFromIP can be made to time out and return an error with\u000aTimeout() == true after a fixed time limit; see SetTimeout and\u000aSetReadTimeout.\u000a</p>\u000a\u000a","name":"ReadFromIP"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.RemoteAddr!\">RemoteAddr</a></h2>\u000a<code>func (c *IPConn) RemoteAddr() Addr</code>\u000a<p>\u000aRemoteAddr returns the remote network address, a *IPAddr.\u000a</p>\u000a\u000a","name":"RemoteAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\u000a<code>func (c *IPConn) SetReadBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetReadBuffer sets the size of the operating system&#39;s\u000areceive buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetReadBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\u000a<code>func (c *IPConn) SetReadTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetReadTimeout implements the net.Conn SetReadTimeout method.\u000a</p>\u000a\u000a","name":"SetReadTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetTimeout!\">SetTimeout</a></h2>\u000a<code>func (c *IPConn) SetTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetTimeout implements the net.Conn SetTimeout method.\u000a</p>\u000a\u000a","name":"SetTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\u000a<code>func (c *IPConn) SetWriteBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetWriteBuffer sets the size of the operating system&#39;s\u000atransmit buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetWriteBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\u000a<code>func (c *IPConn) SetWriteTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetWriteTimeout implements the net.Conn SetWriteTimeout method.\u000a</p>\u000a\u000a","name":"SetWriteTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Write!\">Write</a></h2>\u000a<code>func (c *IPConn) Write(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite implements the net.Conn Write method.\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.WriteTo!\">WriteTo</a></h2>\u000a<code>func (c *IPConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\u000a<p>\u000aWriteTo implements the net.PacketConn WriteTo method.\u000a</p>\u000a\u000a","name":"WriteTo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.WriteToIP!\">WriteToIP</a></h2>\u000a<code>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (n int, err os.Error)</code>\u000a<p>\u000aWriteToIP writes a IP packet to addr via c, copying the payload from b.\u000a</p>\u000a<p>\u000aWriteToIP can be made to time out and return\u000aan error with Timeout() == true after a fixed time limit;\u000asee SetTimeout and SetWriteTimeout.\u000aOn packet-oriented connections, write timeouts are rare.\u000a</p>\u000a\u000a","name":"WriteToIP"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPMask!\">IPMask</a></h2>\u000a<pre>type IPMask []byte</pre>\u000a<p>\u000aAn IP mask is an IP address.\u000a</p>\u000a\u000a","name":"IPMask","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:IPMask\">func (IPMask)</a> <a href=\"?m:IPMask.String!\">String</a></h2>\u000a<code>func (mask IPMask) String() string</code>\u000a<p>\u000aString returns the string representation of mask.\u000aIf the mask is in the canonical form--ones followed by zeros--the\u000astring representation is just the decimal number of ones.\u000aIf the mask is in a non-canonical form, it is formatted\u000aas an IP address.\u000a</p>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidAddrError!\">InvalidAddrError</a></h2>\u000a<pre>type InvalidAddrError string</pre>\u000a\u000a","name":"InvalidAddrError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.String!\">String</a></h2>\u000a<code>func (e InvalidAddrError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.Temporary!\">Temporary</a></h2>\u000a<code>func (e InvalidAddrError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.Timeout!\">Timeout</a></h2>\u000a<code>func (e InvalidAddrError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidConnError!\">InvalidConnError</a></h2>\u000a<pre>type InvalidConnError struct{}</pre>\u000a\u000a","name":"InvalidConnError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.String!\">String</a></h2>\u000a<code>func (e *InvalidConnError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.Temporary!\">Temporary</a></h2>\u000a<code>func (e *InvalidConnError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.Timeout!\">Timeout</a></h2>\u000a<code>func (e *InvalidConnError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Listener!\">Listener</a></h2>\u000a<pre>type Listener interface {\u000a\u0009// Accept waits for and returns the next connection to the listener.\u000a\u0009Accept() (c Conn, err os.Error)\u000a\u000a\u0009// Close closes the listener.\u000a\u0009// The error returned is an os.Error to satisfy io.Closer;\u000a\u0009Close() os.Error\u000a\u000a\u0009// Addr returns the listener&#39;s network address.\u000a\u0009Addr() Addr\u000a}</pre>\u000a<p>\u000aA Listener is a generic network listener for stream-oriented protocols.\u000a</p>\u000a\u000a","name":"Listener","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MX!\">MX</a></h2>\u000a<pre>type MX struct {\u000a\u0009Host string\u000a\u0009Pref uint16\u000a}</pre>\u000a\u000a","name":"MX","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:OpError!\">OpError</a></h2>\u000a<pre>type OpError struct {\u000a\u0009Op    string\u000a\u0009Net   string\u000a\u0009Addr  Addr\u000a\u0009Error os.Error\u000a}</pre>\u000a\u000a","name":"OpError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.String!\">String</a></h2>\u000a<code>func (e *OpError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.Temporary!\">Temporary</a></h2>\u000a<code>func (e *OpError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.Timeout!\">Timeout</a></h2>\u000a<code>func (e *OpError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PacketConn!\">PacketConn</a></h2>\u000a<pre>type PacketConn interface {\u000a\u0009// ReadFrom reads a packet from the connection,\u000a\u0009// copying the payload into b.  It returns the number of\u000a\u0009// bytes copied into b and the return address that\u000a\u0009// was on the packet.\u000a\u0009// ReadFrom can be made to time out and return\u000a\u0009// an error with Timeout() == true after a fixed time limit;\u000a\u0009// see SetTimeout and SetReadTimeout.\u000a\u0009ReadFrom(b []byte) (n int, addr Addr, err os.Error)\u000a\u000a\u0009// WriteTo writes a packet with payload b to addr.\u000a\u0009// WriteTo can be made to time out and return\u000a\u0009// an error with Timeout() == true after a fixed time limit;\u000a\u0009// see SetTimeout and SetWriteTimeout.\u000a\u0009// On packet-oriented connections, write timeouts are rare.\u000a\u0009WriteTo(b []byte, addr Addr) (n int, err os.Error)\u000a\u000a\u0009// Close closes the connection.\u000a\u0009// The error returned is an os.Error to satisfy io.Closer;\u000a\u0009Close() os.Error\u000a\u000a\u0009// LocalAddr returns the local network address.\u000a\u0009LocalAddr() Addr\u000a\u000a\u0009// SetTimeout sets the read and write deadlines associated\u000a\u0009// with the connection.\u000a\u0009SetTimeout(nsec int64) os.Error\u000a\u000a\u0009// SetReadTimeout sets the time (in nanoseconds) that\u000a\u0009// Read will wait for data before returning an error with Timeout() == true.\u000a\u0009// Setting nsec == 0 (the default) disables the deadline.\u000a\u0009SetReadTimeout(nsec int64) os.Error\u000a\u000a\u0009// SetWriteTimeout sets the time (in nanoseconds) that\u000a\u0009// Write will wait to send its data before returning an error with Timeout() == true.\u000a\u0009// Setting nsec == 0 (the default) disables the deadline.\u000a\u0009// Even if write times out, it may return n &gt; 0, indicating that\u000a\u0009// some of the data was successfully written.\u000a\u0009SetWriteTimeout(nsec int64) os.Error\u000a}</pre>\u000a<p>\u000aPacketConn is a generic packet-oriented network connection.\u000a</p>\u000a\u000a","name":"PacketConn","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SRV!\">SRV</a></h2>\u000a<pre>type SRV struct {\u000a\u0009Target   string\u000a\u0009Port     uint16\u000a\u0009Priority uint16\u000a\u0009Weight   uint16\u000a}</pre>\u000a\u000a","name":"SRV","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPAddr!\">TCPAddr</a></h2>\u000a<pre>type TCPAddr struct {\u000a\u0009IP   IP\u000a\u0009Port int\u000a}</pre>\u000a<p>\u000aTCPAddr represents the address of a TCP end point.\u000a</p>\u000a\u000a","name":"TCPAddr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPAddr\">func (*TCPAddr)</a> <a href=\"?m:TCPAddr.Network!\">Network</a></h2>\u000a<code>func (a *TCPAddr) Network() string</code>\u000a<p>\u000aNetwork returns the address&#39;s network name, &#34;tcp&#34;.\u000a</p>\u000a\u000a","name":"Network"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPAddr\">func (*TCPAddr)</a> <a href=\"?m:TCPAddr.String!\">String</a></h2>\u000a<code>func (a *TCPAddr) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPConn!\">TCPConn</a></h2>\u000a<pre>type TCPConn struct {\u000a\u0009fd *netFD\u000a}</pre>\u000a<p>\u000aTCPConn is an implementation of the Conn interface\u000afor TCP network connections.\u000a</p>\u000a\u000a","name":"TCPConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Close!\">Close</a></h2>\u000a<code>func (c *TCPConn) Close() os.Error</code>\u000a<p>\u000aClose closes the TCP connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.LocalAddr!\">LocalAddr</a></h2>\u000a<code>func (c *TCPConn) LocalAddr() Addr</code>\u000a<p>\u000aLocalAddr returns the local network address, a *TCPAddr.\u000a</p>\u000a\u000a","name":"LocalAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Read!\">Read</a></h2>\u000a<code>func (c *TCPConn) Read(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead implements the net.Conn Read method.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.RemoteAddr!\">RemoteAddr</a></h2>\u000a<code>func (c *TCPConn) RemoteAddr() Addr</code>\u000a<p>\u000aRemoteAddr returns the remote network address, a *TCPAddr.\u000a</p>\u000a\u000a","name":"RemoteAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetKeepAlive!\">SetKeepAlive</a></h2>\u000a<code>func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error</code>\u000a<p>\u000aSetKeepAlive sets whether the operating system should send\u000akeepalive messages on the connection.\u000a</p>\u000a\u000a","name":"SetKeepAlive"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetLinger!\">SetLinger</a></h2>\u000a<code>func (c *TCPConn) SetLinger(sec int) os.Error</code>\u000a<p>\u000aSetLinger sets the behavior of Close() on a connection\u000awhich still has data waiting to be sent or to be acknowledged.\u000a</p>\u000a<p>\u000aIf sec &lt; 0 (the default), Close returns immediately and\u000athe operating system finishes sending the data in the background.\u000a</p>\u000a<p>\u000aIf sec == 0, Close returns immediately and the operating system\u000adiscards any unsent or unacknowledged data.\u000a</p>\u000a<p>\u000aIf sec &gt; 0, Close blocks for at most sec seconds waiting for\u000adata to be sent and acknowledged.\u000a</p>\u000a\u000a","name":"SetLinger"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetNoDelay!\">SetNoDelay</a></h2>\u000a<code>func (c *TCPConn) SetNoDelay(noDelay bool) os.Error</code>\u000a<p>\u000aSetNoDelay controls whether the operating system should delay\u000apacket transmission in hopes of sending fewer packets\u000a(Nagle&#39;s algorithm).  The default is true (no delay), meaning\u000athat data is sent as soon as possible after a Write.\u000a</p>\u000a\u000a","name":"SetNoDelay"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\u000a<code>func (c *TCPConn) SetReadBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetReadBuffer sets the size of the operating system&#39;s\u000areceive buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetReadBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\u000a<code>func (c *TCPConn) SetReadTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetReadTimeout implements the net.Conn SetReadTimeout method.\u000a</p>\u000a\u000a","name":"SetReadTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetTimeout!\">SetTimeout</a></h2>\u000a<code>func (c *TCPConn) SetTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetTimeout implements the net.Conn SetTimeout method.\u000a</p>\u000a\u000a","name":"SetTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\u000a<code>func (c *TCPConn) SetWriteBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetWriteBuffer sets the size of the operating system&#39;s\u000atransmit buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetWriteBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\u000a<code>func (c *TCPConn) SetWriteTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetWriteTimeout implements the net.Conn SetWriteTimeout method.\u000a</p>\u000a\u000a","name":"SetWriteTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Write!\">Write</a></h2>\u000a<code>func (c *TCPConn) Write(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite implements the net.Conn Write method.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPListener!\">TCPListener</a></h2>\u000a<pre>type TCPListener struct {\u000a\u0009fd *netFD\u000a}</pre>\u000a<p>\u000aTCPListener is a TCP network listener.\u000aClients should typically use variables of type Listener\u000ainstead of assuming TCP.\u000a</p>\u000a\u000a","name":"TCPListener","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Accept!\">Accept</a></h2>\u000a<code>func (l *TCPListener) Accept() (c Conn, err os.Error)</code>\u000a<p>\u000aAccept implements the Accept method in the Listener interface;\u000ait waits for the next call and returns a generic Conn.\u000a</p>\u000a\u000a","name":"Accept"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.AcceptTCP!\">AcceptTCP</a></h2>\u000a<code>func (l *TCPListener) AcceptTCP() (c *TCPConn, err os.Error)</code>\u000a<p>\u000aAcceptTCP accepts the next incoming call and returns the new connection\u000aand the remote address.\u000a</p>\u000a\u000a","name":"AcceptTCP"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Addr!\">Addr</a></h2>\u000a<code>func (l *TCPListener) Addr() Addr</code>\u000a<p>\u000aAddr returns the listener&#39;s network address, a *TCPAddr.\u000a</p>\u000a\u000a","name":"Addr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Close!\">Close</a></h2>\u000a<code>func (l *TCPListener) Close() os.Error</code>\u000a<p>\u000aClose stops listening on the TCP address.\u000aAlready Accepted connections are not closed.\u000a</p>\u000a\u000a","name":"Close"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UDPAddr!\">UDPAddr</a></h2>\u000a<pre>type UDPAddr struct {\u000a\u0009IP   IP\u000a\u0009Port int\u000a}</pre>\u000a<p>\u000aUDPAddr represents the address of a UDP end point.\u000a</p>\u000a\u000a","name":"UDPAddr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPAddr\">func (*UDPAddr)</a> <a href=\"?m:UDPAddr.Network!\">Network</a></h2>\u000a<code>func (a *UDPAddr) Network() string</code>\u000a<p>\u000aNetwork returns the address&#39;s network name, &#34;udp&#34;.\u000a</p>\u000a\u000a","name":"Network"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPAddr\">func (*UDPAddr)</a> <a href=\"?m:UDPAddr.String!\">String</a></h2>\u000a<code>func (a *UDPAddr) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UDPConn!\">UDPConn</a></h2>\u000a<pre>type UDPConn struct {\u000a\u0009fd *netFD\u000a}</pre>\u000a<p>\u000aUDPConn is the implementation of the Conn and PacketConn\u000ainterfaces for UDP network connections.\u000a</p>\u000a\u000a","name":"UDPConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.BindToDevice!\">BindToDevice</a></h2>\u000a<code>func (c *UDPConn) BindToDevice(device string) os.Error</code>\u000a<p>\u000aBindToDevice binds a UDPConn to a network interface.\u000a</p>\u000a\u000a","name":"BindToDevice"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Close!\">Close</a></h2>\u000a<code>func (c *UDPConn) Close() os.Error</code>\u000a<p>\u000aClose closes the UDP connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.LocalAddr!\">LocalAddr</a></h2>\u000a<code>func (c *UDPConn) LocalAddr() Addr</code>\u000a<p>\u000aLocalAddr returns the local network address.\u000a</p>\u000a\u000a","name":"LocalAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Read!\">Read</a></h2>\u000a<code>func (c *UDPConn) Read(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead implements the net.Conn Read method.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.ReadFrom!\">ReadFrom</a></h2>\u000a<code>func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\u000a<p>\u000aReadFrom implements the net.PacketConn ReadFrom method.\u000a</p>\u000a\u000a","name":"ReadFrom"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.ReadFromUDP!\">ReadFromUDP</a></h2>\u000a<code>func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error)</code>\u000a<p>\u000aReadFromUDP reads a UDP packet from c, copying the payload into b.\u000aIt returns the number of bytes copied into b and the return address\u000athat was on the packet.\u000a</p>\u000a<p>\u000aReadFromUDP can be made to time out and return an error with Timeout() == true\u000aafter a fixed time limit; see SetTimeout and SetReadTimeout.\u000a</p>\u000a\u000a","name":"ReadFromUDP"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.RemoteAddr!\">RemoteAddr</a></h2>\u000a<code>func (c *UDPConn) RemoteAddr() Addr</code>\u000a<p>\u000aRemoteAddr returns the remote network address, a *UDPAddr.\u000a</p>\u000a\u000a","name":"RemoteAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\u000a<code>func (c *UDPConn) SetReadBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetReadBuffer sets the size of the operating system&#39;s\u000areceive buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetReadBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\u000a<code>func (c *UDPConn) SetReadTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetReadTimeout implements the net.Conn SetReadTimeout method.\u000a</p>\u000a\u000a","name":"SetReadTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetTimeout!\">SetTimeout</a></h2>\u000a<code>func (c *UDPConn) SetTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetTimeout implements the net.Conn SetTimeout method.\u000a</p>\u000a\u000a","name":"SetTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\u000a<code>func (c *UDPConn) SetWriteBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetWriteBuffer sets the size of the operating system&#39;s\u000atransmit buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetWriteBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\u000a<code>func (c *UDPConn) SetWriteTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetWriteTimeout implements the net.Conn SetWriteTimeout method.\u000a</p>\u000a\u000a","name":"SetWriteTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Write!\">Write</a></h2>\u000a<code>func (c *UDPConn) Write(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite implements the net.Conn Write method.\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.WriteTo!\">WriteTo</a></h2>\u000a<code>func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\u000a<p>\u000aWriteTo implements the net.PacketConn WriteTo method.\u000a</p>\u000a\u000a","name":"WriteTo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.WriteToUDP!\">WriteToUDP</a></h2>\u000a<code>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error)</code>\u000a<p>\u000aWriteToUDP writes a UDP packet to addr via c, copying the payload from b.\u000a</p>\u000a<p>\u000aWriteToUDP can be made to time out and return\u000aan error with Timeout() == true after a fixed time limit;\u000asee SetTimeout and SetWriteTimeout.\u000aOn packet-oriented connections, write timeouts are rare.\u000a</p>\u000a\u000a","name":"WriteToUDP"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixAddr!\">UnixAddr</a></h2>\u000a<pre>type UnixAddr struct {\u000a\u0009Name     string\u000a\u0009Datagram bool\u000a}</pre>\u000a<p>\u000aUnixAddr represents the address of a Unix domain socket end point.\u000a</p>\u000a\u000a","name":"UnixAddr","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixAddr\">func (*UnixAddr)</a> <a href=\"?m:UnixAddr.Network!\">Network</a></h2>\u000a<code>func (a *UnixAddr) Network() string</code>\u000a<p>\u000aNetwork returns the address&#39;s network name, &#34;unix&#34; or &#34;unixgram&#34;.\u000a</p>\u000a\u000a","name":"Network"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixAddr\">func (*UnixAddr)</a> <a href=\"?m:UnixAddr.String!\">String</a></h2>\u000a<code>func (a *UnixAddr) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixConn!\">UnixConn</a></h2>\u000a<pre>type UnixConn struct {\u000a\u0009fd *netFD\u000a}</pre>\u000a<p>\u000aUnixConn is an implementation of the Conn interface\u000afor connections to Unix domain sockets.\u000a</p>\u000a\u000a","name":"UnixConn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Close!\">Close</a></h2>\u000a<code>func (c *UnixConn) Close() os.Error</code>\u000a<p>\u000aClose closes the Unix domain connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.LocalAddr!\">LocalAddr</a></h2>\u000a<code>func (c *UnixConn) LocalAddr() Addr</code>\u000a<p>\u000aLocalAddr returns the local network address, a *UnixAddr.\u000aUnlike in other protocols, LocalAddr is usually nil for dialed connections.\u000a</p>\u000a\u000a","name":"LocalAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Read!\">Read</a></h2>\u000a<code>func (c *UnixConn) Read(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead implements the net.Conn Read method.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.ReadFrom!\">ReadFrom</a></h2>\u000a<code>func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\u000a<p>\u000aReadFrom implements the net.PacketConn ReadFrom method.\u000a</p>\u000a\u000a","name":"ReadFrom"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.ReadFromUnix!\">ReadFromUnix</a></h2>\u000a<code>func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err os.Error)</code>\u000a<p>\u000aReadFromUnix reads a packet from c, copying the payload into b.\u000aIt returns the number of bytes copied into b and the return address\u000athat was on the packet.\u000a</p>\u000a<p>\u000aReadFromUnix can be made to time out and return\u000aan error with Timeout() == true after a fixed time limit;\u000asee SetTimeout and SetReadTimeout.\u000a</p>\u000a\u000a","name":"ReadFromUnix"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.RemoteAddr!\">RemoteAddr</a></h2>\u000a<code>func (c *UnixConn) RemoteAddr() Addr</code>\u000a<p>\u000aRemoteAddr returns the remote network address, a *UnixAddr.\u000aUnlike in other protocols, RemoteAddr is usually nil for connections\u000aaccepted by a listener.\u000a</p>\u000a\u000a","name":"RemoteAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetReadBuffer!\">SetReadBuffer</a></h2>\u000a<code>func (c *UnixConn) SetReadBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetReadBuffer sets the size of the operating system&#39;s\u000areceive buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetReadBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetReadTimeout!\">SetReadTimeout</a></h2>\u000a<code>func (c *UnixConn) SetReadTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetReadTimeout implements the net.Conn SetReadTimeout method.\u000a</p>\u000a\u000a","name":"SetReadTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetTimeout!\">SetTimeout</a></h2>\u000a<code>func (c *UnixConn) SetTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetTimeout implements the net.Conn SetTimeout method.\u000a</p>\u000a\u000a","name":"SetTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\u000a<code>func (c *UnixConn) SetWriteBuffer(bytes int) os.Error</code>\u000a<p>\u000aSetWriteBuffer sets the size of the operating system&#39;s\u000atransmit buffer associated with the connection.\u000a</p>\u000a\u000a","name":"SetWriteBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\u000a<code>func (c *UnixConn) SetWriteTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetWriteTimeout implements the net.Conn SetWriteTimeout method.\u000a</p>\u000a\u000a","name":"SetWriteTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Write!\">Write</a></h2>\u000a<code>func (c *UnixConn) Write(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite implements the net.Conn Write method.\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.WriteTo!\">WriteTo</a></h2>\u000a<code>func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\u000a<p>\u000aWriteTo implements the net.PacketConn WriteTo method.\u000a</p>\u000a\u000a","name":"WriteTo"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.WriteToUnix!\">WriteToUnix</a></h2>\u000a<code>func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err os.Error)</code>\u000a<p>\u000aWriteToUnix writes a packet to addr via c, copying the payload from b.\u000a</p>\u000a<p>\u000aWriteToUnix can be made to time out and return\u000aan error with Timeout() == true after a fixed time limit;\u000asee SetTimeout and SetWriteTimeout.\u000aOn packet-oriented connections, write timeouts are rare.\u000a</p>\u000a\u000a","name":"WriteToUnix"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixListener!\">UnixListener</a></h2>\u000a<pre>type UnixListener struct {\u000a\u0009fd   *netFD\u000a\u0009path string\u000a}</pre>\u000a<p>\u000aUnixListener is a Unix domain socket listener.\u000aClients should typically use variables of type Listener\u000ainstead of assuming Unix domain sockets.\u000a</p>\u000a\u000a","name":"UnixListener","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Accept!\">Accept</a></h2>\u000a<code>func (l *UnixListener) Accept() (c Conn, err os.Error)</code>\u000a<p>\u000aAccept implements the Accept method in the Listener interface;\u000ait waits for the next call and returns a generic Conn.\u000a</p>\u000a\u000a","name":"Accept"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.AcceptUnix!\">AcceptUnix</a></h2>\u000a<code>func (l *UnixListener) AcceptUnix() (c *UnixConn, err os.Error)</code>\u000a<p>\u000aAcceptUnix accepts the next incoming call and returns the new connection\u000aand the remote address.\u000a</p>\u000a\u000a","name":"AcceptUnix"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Addr!\">Addr</a></h2>\u000a<code>func (l *UnixListener) Addr() Addr</code>\u000a<p>\u000aAddr returns the listener&#39;s network address.\u000a</p>\u000a\u000a","name":"Addr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Close!\">Close</a></h2>\u000a<code>func (l *UnixListener) Close() os.Error</code>\u000a<p>\u000aClose stops listening on the Unix address.\u000aAlready accepted connections are not closed.\u000a</p>\u000a\u000a","name":"Close"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownNetworkError!\">UnknownNetworkError</a></h2>\u000a<pre>type UnknownNetworkError string</pre>\u000a\u000a","name":"UnknownNetworkError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.String!\">String</a></h2>\u000a<code>func (e UnknownNetworkError) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.Temporary!\">Temporary</a></h2>\u000a<code>func (e UnknownNetworkError) Temporary() bool</code>\u000a\u000a","name":"Temporary"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.Timeout!\">Timeout</a></h2>\u000a<code>func (e UnknownNetworkError) Timeout() bool</code>\u000a\u000a","name":"Timeout"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownSocketError!\">UnknownSocketError</a></h2>\u000a<pre>type UnknownSocketError struct {\u000a\u0009sa syscall.Sockaddr\u000a}</pre>\u000a\u000a","name":"UnknownSocketError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownSocketError\">func (*UnknownSocketError)</a> <a href=\"?m:UnknownSocketError.String!\">String</a></h2>\u000a<code>func (e *UnknownSocketError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\u000a<code>func Dial(net, laddr, raddr string) (c Conn, err os.Error)</code>\u000a<p>\u000aDial connects to the remote address raddr on the network net.\u000aIf the string laddr is not empty, it is used as the local address\u000afor the connection.\u000a</p>\u000a<p>\u000aKnown networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),\u000a&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;\u000a(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34; and &#34;unixgram&#34;.\u000a</p>\u000a<p>\u000aFor IP networks, addresses have the form host:port.  If host is\u000aa literal IPv6 address, it must be enclosed in square brackets.\u000a</p>\u000a<p>\u000aExamples:\u000a</p>\u000a<pre>Dial(&#34;tcp&#34;, &#34;&#34;, &#34;12.34.56.78:80&#34;)\u000aDial(&#34;tcp&#34;, &#34;&#34;, &#34;google.com:80&#34;)\u000aDial(&#34;tcp&#34;, &#34;&#34;, &#34;[de:ad:be:ef::ca:fe]:80&#34;)\u000aDial(&#34;tcp&#34;, &#34;127.0.0.1:123&#34;, &#34;127.0.0.1:88&#34;)\u000a</pre>\u000a\u000a","name":"Dial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialIP!\">DialIP</a></h2>\u000a<code>func DialIP(netProto string, laddr, raddr *IPAddr) (c *IPConn, err os.Error)</code>\u000a<p>\u000aDialIP connects to the remote address raddr on the network net,\u000awhich must be &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34;.\u000a</p>\u000a\u000a","name":"DialIP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialTCP!\">DialTCP</a></h2>\u000a<code>func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error)</code>\u000a<p>\u000aDialTCP is like Dial but can only connect to TCP networks\u000aand returns a TCPConn structure.\u000a</p>\u000a\u000a","name":"DialTCP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialUDP!\">DialUDP</a></h2>\u000a<code>func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)</code>\u000a<p>\u000aDialUDP connects to the remote address raddr on the network net,\u000awhich must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr is not nil, it is used\u000aas the local address for the connection.\u000a</p>\u000a\u000a","name":"DialUDP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialUnix!\">DialUnix</a></h2>\u000a<code>func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err os.Error)</code>\u000a<p>\u000aDialUnix connects to the remote address raddr on the network net,\u000awhich must be &#34;unix&#34; or &#34;unixgram&#34;.  If laddr is not nil, it is used\u000aas the local address for the connection.\u000a</p>\u000a\u000a","name":"DialUnix"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IPv4!\">IPv4</a></h2>\u000a<code>func IPv4(a, b, c, d byte) IP</code>\u000a<p>\u000aIPv4 returns the IP address (in 16-byte form) of the\u000aIPv4 address a.b.c.d.\u000a</p>\u000a\u000a","name":"IPv4"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IPv4Mask!\">IPv4Mask</a></h2>\u000a<code>func IPv4Mask(a, b, c, d byte) IPMask</code>\u000a<p>\u000aIPv4Mask returns the IP mask (in 16-byte form) of the\u000aIPv4 mask a.b.c.d.\u000a</p>\u000a\u000a","name":"IPv4Mask"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Listen!\">Listen</a></h2>\u000a<code>func Listen(net, laddr string) (l Listener, err os.Error)</code>\u000a<p>\u000aListen announces on the local network address laddr.\u000aThe network string net must be a stream-oriented\u000anetwork: &#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, or &#34;unix&#34;.\u000a</p>\u000a\u000a","name":"Listen"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenIP!\">ListenIP</a></h2>\u000a<code>func ListenIP(netProto string, laddr *IPAddr) (c *IPConn, err os.Error)</code>\u000a<p>\u000aListenIP listens for incoming IP packets addressed to the\u000alocal address laddr.  The returned connection c&#39;s ReadFrom\u000aand WriteTo methods can be used to receive and send IP\u000apackets with per-packet addressing.\u000a</p>\u000a\u000a","name":"ListenIP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenPacket!\">ListenPacket</a></h2>\u000a<code>func ListenPacket(net, laddr string) (c PacketConn, err os.Error)</code>\u000a<p>\u000aListenPacket announces on the local network address laddr.\u000aThe network string net must be a packet-oriented network:\u000a&#34;udp&#34;, &#34;udp4&#34;, &#34;udp6&#34;, or &#34;unixgram&#34;.\u000a</p>\u000a\u000a","name":"ListenPacket"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenTCP!\">ListenTCP</a></h2>\u000a<code>func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error)</code>\u000a<p>\u000aListenTCP announces on the TCP address laddr and returns a TCP listener.\u000aNet must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.\u000aIf laddr has a port of 0, it means to listen on some available port.\u000aThe caller can use l.Addr() to retrieve the chosen address.\u000a</p>\u000a\u000a","name":"ListenTCP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUDP!\">ListenUDP</a></h2>\u000a<code>func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)</code>\u000a<p>\u000aListenUDP listens for incoming UDP packets addressed to the\u000alocal address laddr.  The returned connection c&#39;s ReadFrom\u000aand WriteTo methods can be used to receive and send UDP\u000apackets with per-packet addressing.\u000a</p>\u000a\u000a","name":"ListenUDP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUnix!\">ListenUnix</a></h2>\u000a<code>func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err os.Error)</code>\u000a<p>\u000aListenUnix announces on the Unix domain socket laddr and returns a Unix listener.\u000aNet must be &#34;unix&#34; (stream sockets).\u000a</p>\u000a\u000a","name":"ListenUnix"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUnixgram!\">ListenUnixgram</a></h2>\u000a<code>func ListenUnixgram(net string, laddr *UnixAddr) (c *UDPConn, err os.Error)</code>\u000a<p>\u000aListenUnixgram listens for incoming Unix datagram packets addressed to the\u000alocal address laddr.  The returned connection c&#39;s ReadFrom\u000aand WriteTo methods can be used to receive and send UDP\u000apackets with per-packet addressing.  The network net must be &#34;unixgram&#34;.\u000a</p>\u000a\u000a","name":"ListenUnixgram"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupHost!\">LookupHost</a></h2>\u000a<code>func LookupHost(name string) (cname string, addrs []string, err os.Error)</code>\u000a<p>\u000aLookupHost looks for name using the local hosts file and DNS resolver.\u000aIt returns the canonical name for the host and an array of that\u000ahost&#39;s addresses.\u000a</p>\u000a\u000a","name":"LookupHost"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupMX!\">LookupMX</a></h2>\u000a<code>func LookupMX(name string) (entries []*MX, err os.Error)</code>\u000a\u000a","name":"LookupMX"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupPort!\">LookupPort</a></h2>\u000a<code>func LookupPort(network, service string) (port int, err os.Error)</code>\u000a<p>\u000aLookupPort looks up the port for the given network and service.\u000a</p>\u000a\u000a","name":"LookupPort"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupSRV!\">LookupSRV</a></h2>\u000a<code>func LookupSRV(name string) (cname string, addrs []*SRV, err os.Error)</code>\u000a\u000a","name":"LookupSRV"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseIP!\">ParseIP</a></h2>\u000a<code>func ParseIP(s string) IP</code>\u000a<p>\u000aParseIP parses s as an IP address, returning the result.\u000aThe string s can be in dotted decimal (&#34;74.125.19.99&#34;)\u000aor IPv6 (&#34;2001:4860:0:2001::68&#34;) form.\u000aIf s is not a valid textual representation of an IP address,\u000aParseIP returns nil.\u000a</p>\u000a\u000a","name":"ParseIP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pipe!\">Pipe</a></h2>\u000a<code>func Pipe() (Conn, Conn)</code>\u000a<p>\u000aPipe creates a synchronous, in-memory, full duplex\u000anetwork connection; both ends implement the Conn interface.\u000aReads on one end are matched with writes on the other,\u000acopying data directly between the two; there is no internal\u000abuffering.\u000a</p>\u000a\u000a","name":"Pipe"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveIPAddr!\">ResolveIPAddr</a></h2>\u000a<code>func ResolveIPAddr(addr string) (*IPAddr, os.Error)</code>\u000a<p>\u000aResolveIPAddr parses addr as a IP address and resolves domain\u000anames to numeric addresses.  A literal IPv6 host address must be\u000aenclosed in square brackets, as in &#34;[::]&#34;.\u000a</p>\u000a\u000a","name":"ResolveIPAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveTCPAddr!\">ResolveTCPAddr</a></h2>\u000a<code>func ResolveTCPAddr(addr string) (*TCPAddr, os.Error)</code>\u000a<p>\u000aResolveTCPAddr parses addr as a TCP address of the form\u000ahost:port and resolves domain names or port names to\u000anumeric addresses.  A literal IPv6 host address must be\u000aenclosed in square brackets, as in &#34;[::]:80&#34;.\u000a</p>\u000a\u000a","name":"ResolveTCPAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveUDPAddr!\">ResolveUDPAddr</a></h2>\u000a<code>func ResolveUDPAddr(addr string) (*UDPAddr, os.Error)</code>\u000a<p>\u000aResolveUDPAddr parses addr as a UDP address of the form\u000ahost:port and resolves domain names or port names to\u000anumeric addresses.  A literal IPv6 host address must be\u000aenclosed in square brackets, as in &#34;[::]:80&#34;.\u000a</p>\u000a\u000a","name":"ResolveUDPAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveUnixAddr!\">ResolveUnixAddr</a></h2>\u000a<code>func ResolveUnixAddr(net, addr string) (*UnixAddr, os.Error)</code>\u000a<p>\u000aResolveUnixAddr parses addr as a Unix domain socket address.\u000aThe string net gives the network name, &#34;unix&#34; or &#34;unixgram&#34;.\u000a</p>\u000a\u000a","name":"ResolveUnixAddr"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:IPv4len!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009IPv4len = 4\u000a\u0009IPv6len = 16\u000a)</pre>\u000a<p>\u000aIP address lengths (bytes).\u000a</p>\u000a\u000a","names":["IPv4len","IPv6len"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:IPv4bcast!\"><em>group</em></a></h2>\u000a<pre>var (\u000a\u0009IPv4bcast     = IPv4(255, 255, 255, 255) // broadcast\u000a\u0009IPv4allsys    = IPv4(224, 0, 0, 1)       // all systems\u000a\u0009IPv4allrouter = IPv4(224, 0, 0, 2)       // all routers\u000a\u0009IPv4zero      = IPv4(0, 0, 0, 0)         // all zeros\u000a)</pre>\u000a<p>\u000aWell-known IPv4 addresses\u000a</p>\u000a\u000a","names":["IPv4bcast","IPv4allsys","IPv4allrouter","IPv4zero"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:IPzero!\">IPzero</a></h2>\u000a<pre>var (\u000a\u0009IPzero = make(IP, IPv6len) // all zeros\u000a)</pre>\u000a<p>\u000aWell-known IPv6 addresses\u000a</p>\u000a\u000a","names":["IPzero"],"type":""}]}