var gowtfData = {"html":"<p>\u000aThe strconv package implements conversions to and from\u000astring representations of basic data types.\u000a</p>\u000a","name":"strconv","filenames":["/home/nsf/go/src/pkg/strconv/atof.go","/home/nsf/go/src/pkg/strconv/quote.go","/home/nsf/go/src/pkg/strconv/ftoa.go","/home/nsf/go/src/pkg/strconv/atob.go","/home/nsf/go/src/pkg/strconv/decimal.go","/home/nsf/go/src/pkg/strconv/itoa.go","/home/nsf/go/src/pkg/strconv/atoi.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NumError!\">NumError</a></h2>\u000a<pre>type NumError struct {\u000a\u0009Num   string\u000a\u0009Error os.Error\u000a}</pre>\u000a\u000a","name":"NumError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NumError\">func (*NumError)</a> <a href=\"?m:NumError.String!\">String</a></h2>\u000a<code>func (e *NumError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atob!\">Atob</a></h2>\u000a<code>func Atob(str string) (value bool, err os.Error)</code>\u000a<p>\u000aAtob returns the boolean value represented by the string.\u000aIt accepts 1, t, T, TRUE, true, 0, f, F, FALSE, false.  Any other value returns\u000aan error.\u000a</p>\u000a\u000a","name":"Atob"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atof!\">Atof</a></h2>\u000a<code>func Atof(s string) (f float, err os.Error)</code>\u000a<p>\u000aAtof is like Atof32 or Atof64, depending on the size of float.\u000a</p>\u000a\u000a","name":"Atof"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atof32!\">Atof32</a></h2>\u000a<code>func Atof32(s string) (f float32, err os.Error)</code>\u000a<p>\u000aAtof32 converts the string s to a 32-bit floating-point number.\u000a</p>\u000a<p>\u000aIf s is well-formed and near a valid floating point number,\u000aAtof32 returns the nearest floating point number rounded\u000ausing IEEE754 unbiased rounding.\u000a</p>\u000a<p>\u000aThe errors that Atof32 returns have concrete type *NumError\u000aand include err.Num = s.\u000a</p>\u000a<p>\u000aIf s is not syntactically well-formed, Atof32 returns err.Error = os.EINVAL.\u000a</p>\u000a<p>\u000aIf s is syntactically well-formed but is more than 1/2 ULP\u000aaway from the largest floating point number of the given size,\u000aAtof32 returns f = ±Inf, err.Error = os.ERANGE.\u000a</p>\u000a\u000a","name":"Atof32"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atof64!\">Atof64</a></h2>\u000a<code>func Atof64(s string) (f float64, err os.Error)</code>\u000a<p>\u000aAtof64 converts the string s to a 64-bit floating-point number.\u000aExcept for the type of its result, its definition is the same as that\u000aof Atof32.\u000a</p>\u000a\u000a","name":"Atof64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:AtofN!\">AtofN</a></h2>\u000a<code>func AtofN(s string, n int) (f float64, err os.Error)</code>\u000a<p>\u000aAtofN converts the string s to a 64-bit floating-point number,\u000abut it rounds the result assuming that it will be stored in a value\u000aof n bits (32 or 64).\u000a</p>\u000a\u000a","name":"AtofN"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atoi!\">Atoi</a></h2>\u000a<code>func Atoi(s string) (i int, err os.Error)</code>\u000a<p>\u000aAtoi is like Atoi64 but returns its result as an int.\u000a</p>\u000a\u000a","name":"Atoi"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atoi64!\">Atoi64</a></h2>\u000a<code>func Atoi64(s string) (i int64, err os.Error)</code>\u000a<p>\u000aAtoi64 is like Atoui64 but allows signed numbers and\u000areturns its result in an int64.\u000a</p>\u000a\u000a","name":"Atoi64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atoui!\">Atoui</a></h2>\u000a<code>func Atoui(s string) (i uint, err os.Error)</code>\u000a<p>\u000aAtoui is like Atoui64 but returns its result as a uint.\u000a</p>\u000a\u000a","name":"Atoui"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Atoui64!\">Atoui64</a></h2>\u000a<code>func Atoui64(s string) (n uint64, err os.Error)</code>\u000a<p>\u000aAtoui64 interprets a string s as a decimal number and\u000areturns the corresponding value n.\u000a</p>\u000a<p>\u000aAtoui64 returns err == os.EINVAL if s is empty or contains invalid digits.\u000aIt returns err == os.ERANGE if s cannot be represented by a uint64.\u000a</p>\u000a\u000a","name":"Atoui64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Btoa!\">Btoa</a></h2>\u000a<code>func Btoa(b bool) string</code>\u000a<p>\u000aBtoa returns &#34;true&#34; or &#34;false&#34; according to the value of the boolean argument\u000a</p>\u000a\u000a","name":"Btoa"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Btoi64!\">Btoi64</a></h2>\u000a<code>func Btoi64(s string, base int) (i int64, err os.Error)</code>\u000a<p>\u000aBtoi64 is like Btoui64 but allows signed numbers and\u000areturns its result in an int64.\u000a</p>\u000a\u000a","name":"Btoi64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Btoui64!\">Btoui64</a></h2>\u000a<code>func Btoui64(s string, b int) (n uint64, err os.Error)</code>\u000a<p>\u000aBtoui64 interprets a string s in an arbitrary base b (2 to 36)\u000aand returns the corresponding value n.  If b == 0, the base\u000ais taken from the string prefix: base 16 for &#34;0x&#34;, base 8 for &#34;0&#34;,\u000aand base 10 otherwise.\u000a</p>\u000a<p>\u000aThe errors that Btoui64 returns have concrete type *NumError\u000aand include err.Num = s.  If s is empty or contains invalid\u000adigits, err.Error = os.EINVAL; if the value corresponding\u000ato s cannot be represented by a uint64, err.Error = os.ERANGE.\u000a</p>\u000a\u000a","name":"Btoui64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanBackquote!\">CanBackquote</a></h2>\u000a<code>func CanBackquote(s string) bool</code>\u000a<p>\u000aCanBackquote returns whether the string s would be\u000aa valid Go string literal if enclosed in backquotes.\u000a</p>\u000a\u000a","name":"CanBackquote"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ftoa!\">Ftoa</a></h2>\u000a<code>func Ftoa(f float, fmt byte, prec int) string</code>\u000a<p>\u000aFtoa behaves as Ftoa32 or Ftoa64, depending on the size of the float type.\u000a</p>\u000a\u000a","name":"Ftoa"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ftoa32!\">Ftoa32</a></h2>\u000a<code>func Ftoa32(f float32, fmt byte, prec int) string</code>\u000a<p>\u000aFtoa32 converts the 32-bit floating-point number f to a string,\u000aaccording to the format fmt and precision prec.\u000a</p>\u000a<p>\u000aThe format fmt is one of\u000a&#39;b&#39; (-ddddp±ddd, a binary exponent),\u000a&#39;e&#39; (-d.dddde±dd, a decimal exponent),\u000a&#39;f&#39; (-ddd.dddd, no exponent), or\u000a&#39;g&#39; (&#39;e&#39; for large exponents, &#39;f&#39; otherwise).\u000a</p>\u000a<p>\u000aThe precision prec controls the number of digits\u000a(excluding the exponent) printed by the &#39;e&#39;, &#39;f&#39;, and &#39;g&#39; formats.\u000aFor &#39;e&#39; and &#39;f&#39; it is the number of digits after the decimal point.\u000aFor &#39;g&#39; it is the total number of digits.\u000aThe special precision -1 uses the smallest number of digits\u000anecessary such that Atof32 will return f exactly.\u000a</p>\u000a<p>\u000aFtoa32(f) is not the same as Ftoa64(float32(f)),\u000abecause correct rounding and the number of digits\u000aneeded to identify f depend on the precision of the representation.\u000a</p>\u000a\u000a","name":"Ftoa32"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ftoa64!\">Ftoa64</a></h2>\u000a<code>func Ftoa64(f float64, fmt byte, prec int) string</code>\u000a<p>\u000aFtoa64 is like Ftoa32 but converts a 64-bit floating-point number.\u000a</p>\u000a\u000a","name":"Ftoa64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FtoaN!\">FtoaN</a></h2>\u000a<code>func FtoaN(f float64, fmt byte, prec int, n int) string</code>\u000a<p>\u000aFtoaN converts the 64-bit floating-point number f to a string,\u000aaccording to the format fmt and precision prec, but it rounds the\u000aresult assuming that it was obtained from a floating-point value\u000aof n bits (32 or 64).\u000a</p>\u000a\u000a","name":"FtoaN"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Itoa!\">Itoa</a></h2>\u000a<code>func Itoa(i int) string</code>\u000a<p>\u000aItoa returns the decimal string representation of i.\u000a</p>\u000a\u000a","name":"Itoa"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Itoa64!\">Itoa64</a></h2>\u000a<code>func Itoa64(i int64) string</code>\u000a<p>\u000aItoa64 returns the decimal string representation of i.\u000a</p>\u000a\u000a","name":"Itoa64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Itob!\">Itob</a></h2>\u000a<code>func Itob(i int, base uint) string</code>\u000a<p>\u000aItob returns the string representation of i in the given base.\u000a</p>\u000a\u000a","name":"Itob"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Itob64!\">Itob64</a></h2>\u000a<code>func Itob64(i int64, base uint) string</code>\u000a<p>\u000aItob64 returns the string representation of i in the given base.\u000a</p>\u000a\u000a","name":"Itob64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Quote!\">Quote</a></h2>\u000a<code>func Quote(s string) string</code>\u000a<p>\u000aQuote returns a double-quoted Go string literal\u000arepresenting s.  The returned string s uses Go escape\u000asequences (\\t, \\n, \\xFF, \\u0100) for control characters\u000aand non-ASCII characters.\u000a</p>\u000a\u000a","name":"Quote"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Uitoa!\">Uitoa</a></h2>\u000a<code>func Uitoa(i uint) string</code>\u000a<p>\u000aUitoa returns the decimal string representation of i.\u000a</p>\u000a\u000a","name":"Uitoa"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Uitoa64!\">Uitoa64</a></h2>\u000a<code>func Uitoa64(i uint64) string</code>\u000a<p>\u000aUitoa64 returns the decimal string representation of i.\u000a</p>\u000a\u000a","name":"Uitoa64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Uitob!\">Uitob</a></h2>\u000a<code>func Uitob(i uint, base uint) string</code>\u000a<p>\u000aUitob returns the string representation of i in the given base.\u000a</p>\u000a\u000a","name":"Uitob"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Uitob64!\">Uitob64</a></h2>\u000a<code>func Uitob64(u uint64, base uint) string</code>\u000a<p>\u000aUitob64 returns the string representation of i in the given base.\u000a</p>\u000a\u000a","name":"Uitob64"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Unquote!\">Unquote</a></h2>\u000a<code>func Unquote(s string) (t string, err os.Error)</code>\u000a<p>\u000aUnquote interprets s as a single-quoted, double-quoted,\u000aor backquoted Go string literal, returning the string value\u000athat s quotes.  (If s is single-quoted, it would be a Go\u000acharacter literal; Unquote returns the corresponding\u000aone-character string.)\u000a</p>\u000a\u000a","name":"Unquote"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnquoteChar!\">UnquoteChar</a></h2>\u000a<code>func UnquoteChar(s string, quote byte) (value int, multibyte bool, tail string, err os.Error)</code>\u000a<p>\u000aUnquoteChar decodes the first character or byte in the escaped string\u000aor character literal represented by the string s.\u000aIt returns four values:\u000a</p>\u000a<pre>1) value, the decoded Unicode code point or byte value;\u000a2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\u000a3) tail, the remainder of the string after the character; and\u000a4) an error that will be nil if the character is syntactically valid.\u000a</pre>\u000a<p>\u000aThe second argument, quote, specifies the type of literal being parsed\u000aand therefore which escaped quote character is permitted.\u000aIf set to a single quote, it permits the sequence \\&#39; and disallows unescaped &#39;.\u000aIf set to a double quote, it permits \\&#34; and disallows unescaped &#34;.\u000aIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\u000a</p>\u000a\u000a","name":"UnquoteChar"}],"consts":[],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:FloatSize!\">FloatSize</a></h2>\u000a<pre>var FloatSize = floatsize()</pre>\u000a<p>\u000aFloatsize gives the size of the float type, either 32 or 64.\u000a</p>\u000a\u000a","names":["FloatSize"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:IntSize!\">IntSize</a></h2>\u000a<pre>var IntSize = computeIntsize()</pre>\u000a\u000a","names":["IntSize"],"type":""}]}