var gowtfData = {"html":"<p>\u000aThe rpc package provides access to the exported methods of an object across a\u000anetwork or other I/O connection.  A server registers an object, making it visible\u000aas a service with the name of the type of the object.  After registration, exported\u000amethods of the object will be accessible remotely.  A server may register multiple\u000aobjects (services) of different types but it is an error to register multiple\u000aobjects of the same type.\u000a</p>\u000a<p>\u000aOnly methods that satisfy these criteria will be made available for remote access;\u000aother methods will be ignored:\u000a</p>\u000a<pre>- the method receiver and name are exported, that is, begin with an upper case letter.\u000a- the method has two arguments, both pointers to exported types.\u000a- the method has return type os.Error.\u000a</pre>\u000a<p>\u000aThe method&#39;s first argument represents the arguments provided by the caller; the\u000asecond argument represents the result parameters to be returned to the caller.\u000aThe method&#39;s return value, if non-nil, is passed back as a string that the client\u000asees as an os.ErrorString.\u000a</p>\u000a<p>\u000aThe server may handle requests on a single connection by calling ServeConn.  More\u000atypically it will create a network listener and call Accept or, for an HTTP\u000alistener, HandleHTTP and http.Serve.\u000a</p>\u000a<p>\u000aA client wishing to use the service establishes a connection and then invokes\u000aNewClient on the connection.  The convenience function Dial (DialHTTP) performs\u000aboth steps for a raw network connection (an HTTP connection).  The resulting\u000aClient object has two methods, Call and Go, that specify the service and method to\u000acall, a pointer containing the arguments, and a pointer to receive the result\u000aparameters.\u000a</p>\u000a<p>\u000aCall waits for the remote call to complete; Go launches the call asynchronously\u000aand returns a channel that will signal completion.\u000a</p>\u000a<p>\u000aPackage &#34;gob&#34; is used to transport the data.\u000a</p>\u000a<p>\u000aHere is a simple example.  A server wishes to export an object of type Arith:\u000a</p>\u000a<pre>package server\u000a\u000atype Args struct {\u000a\u0009A, B int\u000a}\u000a\u000atype Quotient struct {\u000a\u0009Quo, Rem int\u000a}\u000a\u000atype Arith int\u000a\u000afunc (t *Arith) Multiply(args *Args, reply *int) os.Error {\u000a\u0009*reply = args.A * args.B\u000a\u0009return nil\u000a}\u000a\u000afunc (t *Arith) Divide(args *Args, quo *Quotient) os.Error {\u000a\u0009if args.B == 0 {\u000a\u0009\u0009return os.ErrorString(&#34;divide by zero&#34;)\u000a\u0009}\u000a\u0009quo.Quo = args.A / args.B\u000a\u0009quo.Rem = args.A % args.B\u000a\u0009return nil\u000a}\u000a</pre>\u000a<p>\u000aThe server calls (for HTTP service):\u000a</p>\u000a<pre>arith := new(Arith)\u000arpc.Register(arith)\u000arpc.HandleHTTP()\u000al, e := net.Listen(&#34;tcp&#34;, &#34;:1234&#34;)\u000aif e != nil {\u000a\u0009log.Exit(&#34;listen error:&#34;, e)\u000a}\u000ago http.Serve(l, nil)\u000a</pre>\u000a<p>\u000aAt this point, clients can see a service &#34;Arith&#34; with methods &#34;Arith.Multiply&#34; and\u000a&#34;Arith.Divide&#34;.  To invoke one, a client first dials the server:\u000a</p>\u000a<pre>client, err := rpc.DialHTTP(&#34;tcp&#34;, serverAddress + &#34;:1234&#34;)\u000aif err != nil {\u000a\u0009log.Exit(&#34;dialing:&#34;, err)\u000a}\u000a</pre>\u000a<p>\u000aThen it can make a remote call:\u000a</p>\u000a<pre>// Synchronous call\u000aargs := &amp;server.Args{7,8}\u000avar reply int\u000aerr = client.Call(&#34;Arith.Multiply&#34;, args, &amp;reply)\u000aif err != nil {\u000a\u0009log.Exit(&#34;arith error:&#34;, err)\u000a}\u000afmt.Printf(&#34;Arith: %d*%d=%d&#34;, args.A, args.B, *reply)\u000a</pre>\u000a<p>\u000aor\u000a</p>\u000a<pre>// Asynchronous call\u000aquotient := new(Quotient)\u000adivCall := client.Go(&#34;Arith.Divide&#34;, args, &amp;quotient, nil)\u000areplyCall := &lt;-divCall.Done\u0009// will be equal to divCall\u000a// check errors, print, etc.\u000a</pre>\u000a<p>\u000aA server implementation will often provide a simple, type-safe wrapper for the\u000aclient.\u000a</p>\u000a","name":"rpc","filenames":["/home/nsf/go/src/pkg/rpc/client.go","/home/nsf/go/src/pkg/rpc/server.go","/home/nsf/go/src/pkg/rpc/debug.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Call!\">Call</a></h2>\u000a<pre>type Call struct {\u000a\u0009ServiceMethod string      // The name of the service and method to call.\u000a\u0009Args          interface{} // The argument to the function (*struct).\u000a\u0009Reply         interface{} // The reply from the function (*struct).\u000a\u0009Error         os.Error    // After completion, the error status.\u000a\u0009Done          chan *Call  // Strobes when call is complete; value is the error status.\u000a\u0009seq           uint64\u000a}</pre>\u000a<p>\u000aCall represents an active RPC.\u000a</p>\u000a\u000a","name":"Call","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Client!\">Client</a></h2>\u000a<pre>type Client struct {\u000a\u0009mutex    sync.Mutex // protects pending, seq\u000a\u0009shutdown os.Error   // non-nil if the client is shut down\u000a\u0009sending  sync.Mutex\u000a\u0009seq      uint64\u000a\u0009codec    ClientCodec\u000a\u0009pending  map[uint64]*Call\u000a\u0009closing  bool\u000a}</pre>\u000a<p>\u000aClient represents an RPC Client.\u000aThere may be multiple outstanding Calls associated\u000awith a single Client.\u000a</p>\u000a\u000a","name":"Client","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Call!\">Call</a></h2>\u000a<code>func (client *Client) Call(serviceMethod string, args interface{}, reply interface{}) os.Error</code>\u000a<p>\u000aCall invokes the named function, waits for it to complete, and returns its error status.\u000a</p>\u000a\u000a","name":"Call"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Close!\">Close</a></h2>\u000a<code>func (client *Client) Close() os.Error</code>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Go!\">Go</a></h2>\u000a<code>func (client *Client) Go(serviceMethod string, args interface{}, reply interface{}, done chan *Call) *Call</code>\u000a<p>\u000aGo invokes the function asynchronously.  It returns the Call structure representing\u000athe invocation.  The done channel will signal when the call is complete by returning\u000athe same Call object.  If done is nil, Go will allocate a new channel.\u000aIf non-nil, done must be buffered or Go will deliberately crash.\u000a</p>\u000a\u000a","name":"Go"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ClientCodec!\">ClientCodec</a></h2>\u000a<pre>type ClientCodec interface {\u000a\u0009WriteRequest(*Request, interface{}) os.Error\u000a\u0009ReadResponseHeader(*Response) os.Error\u000a\u0009ReadResponseBody(interface{}) os.Error\u000a\u000a\u0009Close() os.Error\u000a}</pre>\u000a<p>\u000aA ClientCodec implements writing of RPC requests and\u000areading of RPC responses for the client side of an RPC session.\u000aThe client calls WriteRequest to write a request to the connection\u000aand calls ReadResponseHeader and ReadResponseBody in pairs\u000ato read responses.  The client calls Close when finished with the\u000aconnection.\u000a</p>\u000a\u000a","name":"ClientCodec","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ClientInfo!\">ClientInfo</a></h2>\u000a<pre>type ClientInfo struct {\u000a\u0009LocalAddr  string\u000a\u0009RemoteAddr string\u000a}</pre>\u000a<p>\u000aClientInfo records information about an RPC client connection.\u000a</p>\u000a\u000a","name":"ClientInfo","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidRequest!\">InvalidRequest</a></h2>\u000a<pre>type InvalidRequest struct {\u000a\u0009marker int\u000a}</pre>\u000a<p>\u000aA value sent as a placeholder for the response when the server receives an invalid request.\u000a</p>\u000a\u000a","name":"InvalidRequest","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Request!\">Request</a></h2>\u000a<pre>type Request struct {\u000a\u0009ServiceMethod string // format: &#34;Service.Method&#34;\u000a\u0009Seq           uint64 // sequence number chosen by client\u000a}</pre>\u000a<p>\u000aRequest is a header written before every RPC call.  It is used internally\u000abut documented here as an aid to debugging, such as when analyzing\u000anetwork traffic.\u000a</p>\u000a\u000a","name":"Request","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Response!\">Response</a></h2>\u000a<pre>type Response struct {\u000a\u0009ServiceMethod string // echoes that of the Request\u000a\u0009Seq           uint64 // echoes that of the request\u000a\u0009Error         string // error, if any.\u000a}</pre>\u000a<p>\u000aResponse is a header written before every RPC return.  It is used internally\u000abut documented here as an aid to debugging, such as when analyzing\u000anetwork traffic.\u000a</p>\u000a\u000a","name":"Response","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Server!\">Server</a></h2>\u000a<pre>type Server struct {\u000a\u0009sync.Mutex // protects the serviceMap\u000a\u0009serviceMap map[string]*service\u000a}</pre>\u000a<p>\u000aServer represents an RPC Server.\u000a</p>\u000a\u000a","name":"Server","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.Accept!\">Accept</a></h2>\u000a<code>func (server *Server) Accept(lis net.Listener)</code>\u000a<p>\u000aAccept accepts connections on the listener and serves requests\u000afor each incoming connection.  Accept blocks; the caller typically\u000ainvokes it in a go statement.\u000a</p>\u000a\u000a","name":"Accept"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.HandleHTTP!\">HandleHTTP</a></h2>\u000a<code>func (server *Server) HandleHTTP(rpcPath, debugPath string)</code>\u000a<p>\u000aHandleHTTP registers an HTTP handler for RPC messages on rpcPath,\u000aand a debugging handler on debugPath.\u000aIt is still necessary to invoke http.Serve(), typically in a go statement.\u000a</p>\u000a\u000a","name":"HandleHTTP"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.Register!\">Register</a></h2>\u000a<code>func (server *Server) Register(rcvr interface{}) os.Error</code>\u000a<p>\u000aRegister publishes in the server the set of methods of the\u000areceiver value that satisfy the following conditions:\u000a</p>\u000a<pre>- exported method\u000a- two arguments, both pointers to exported structs\u000a- one return value, of type os.Error\u000a</pre>\u000a<p>\u000aIt returns an error if the receiver is not an exported type or has no\u000asuitable methods.\u000a</p>\u000a\u000a","name":"Register"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.ServeCodec!\">ServeCodec</a></h2>\u000a<code>func (server *Server) ServeCodec(codec ServerCodec)</code>\u000a<p>\u000aServeCodec is like ServeConn but uses the specified codec to\u000adecode requests and encode responses.\u000a</p>\u000a\u000a","name":"ServeCodec"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.ServeConn!\">ServeConn</a></h2>\u000a<code>func (server *Server) ServeConn(conn io.ReadWriteCloser)</code>\u000a<p>\u000aServeConn runs the server on a single connection.\u000aServeConn blocks, serving the connection until the client hangs up.\u000aThe caller typically invokes ServeConn in a go statement.\u000aServeConn uses the gob wire format (see package gob) on the\u000aconnection.  To use an alternate codec, use ServeCodec.\u000a</p>\u000a\u000a","name":"ServeConn"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.ServeHTTP!\">ServeHTTP</a></h2>\u000a<code>func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request)</code>\u000a<p>\u000aServeHTTP implements an http.Handler that answers RPC requests.\u000a</p>\u000a\u000a","name":"ServeHTTP"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerCodec!\">ServerCodec</a></h2>\u000a<pre>type ServerCodec interface {\u000a\u0009ReadRequestHeader(*Request) os.Error\u000a\u0009ReadRequestBody(interface{}) os.Error\u000a\u0009WriteResponse(*Response, interface{}) os.Error\u000a\u000a\u0009Close() os.Error\u000a}</pre>\u000a<p>\u000aA ServerCodec implements reading of RPC requests and writing of\u000aRPC responses for the server side of an RPC session.\u000aThe server calls ReadRequestHeader and ReadRequestBody in pairs\u000ato read requests from the connection, and it calls WriteResponse to\u000awrite a response back.  The server calls Close when finished with the\u000aconnection.\u000a</p>\u000a\u000a","name":"ServerCodec","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Accept!\">Accept</a></h2>\u000a<code>func Accept(lis net.Listener)</code>\u000a<p>\u000aAccept accepts connections on the listener and serves requests\u000ato DefaultServer for each incoming connection.\u000aAccept blocks; the caller typically invokes it in a go statement.\u000a</p>\u000a\u000a","name":"Accept"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\u000a<code>func Dial(network, address string) (*Client, os.Error)</code>\u000a<p>\u000aDial connects to an RPC server at the specified network address.\u000a</p>\u000a\u000a","name":"Dial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialHTTP!\">DialHTTP</a></h2>\u000a<code>func DialHTTP(network, address string) (*Client, os.Error)</code>\u000a<p>\u000aDialHTTP connects to an HTTP RPC server at the specified network address\u000alistening on the default HTTP RPC path.\u000a</p>\u000a\u000a","name":"DialHTTP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialHTTPPath!\">DialHTTPPath</a></h2>\u000a<code>func DialHTTPPath(network, address, path string) (*Client, os.Error)</code>\u000a<p>\u000aDialHTTPPath connects to an HTTP RPC server\u000aat the specified network address and path.\u000a</p>\u000a\u000a","name":"DialHTTPPath"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HandleHTTP!\">HandleHTTP</a></h2>\u000a<code>func HandleHTTP()</code>\u000a<p>\u000aHandleHTTP registers an HTTP handler for RPC messages to DefaultServer\u000aon DefaultRPCPath and a debugging handler on DefaultDebugPath.\u000aIt is still necessary to invoke http.Serve(), typically in a go statement.\u000a</p>\u000a\u000a","name":"HandleHTTP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClient!\">NewClient</a></h2>\u000a<code>func NewClient(conn io.ReadWriteCloser) *Client</code>\u000a<p>\u000aNewClient returns a new Client to handle requests to the\u000aset of services at the other end of the connection.\u000a</p>\u000a\u000a","name":"NewClient"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClientWithCodec!\">NewClientWithCodec</a></h2>\u000a<code>func NewClientWithCodec(codec ClientCodec) *Client</code>\u000a<p>\u000aNewClientWithCodec is like NewClient but uses the specified\u000acodec to encode requests and decode responses.\u000a</p>\u000a\u000a","name":"NewClientWithCodec"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServer!\">NewServer</a></h2>\u000a<code>func NewServer() *Server</code>\u000a<p>\u000aNewServer returns a new Server.\u000a</p>\u000a\u000a","name":"NewServer"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Register!\">Register</a></h2>\u000a<code>func Register(rcvr interface{}) os.Error</code>\u000a<p>\u000aRegister publishes in the DefaultServer the set of methods\u000aof the receiver value that satisfy the following conditions:\u000a</p>\u000a<pre>- exported method\u000a- two arguments, both pointers to exported structs\u000a- one return value, of type os.Error\u000a</pre>\u000a<p>\u000aIt returns an error if the receiver is not an exported type or has no\u000asuitable methods.\u000a</p>\u000a\u000a","name":"Register"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeCodec!\">ServeCodec</a></h2>\u000a<code>func ServeCodec(codec ServerCodec)</code>\u000a<p>\u000aServeCodec is like ServeConn but uses the specified codec to\u000adecode requests and encode responses.\u000a</p>\u000a\u000a","name":"ServeCodec"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeConn!\">ServeConn</a></h2>\u000a<code>func ServeConn(conn io.ReadWriteCloser)</code>\u000a<p>\u000aServeConn runs the DefaultServer on a single connection.\u000aServeConn blocks, serving the connection until the client hangs up.\u000aThe caller typically invokes ServeConn in a go statement.\u000aServeConn uses the gob wire format (see package gob) on the\u000aconnection.  To use an alternate codec, use ServeCodec.\u000a</p>\u000a\u000a","name":"ServeConn"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DefaultRPCPath!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009// Defaults used by HandleHTTP\u000a\u0009DefaultRPCPath   = &#34;/_goRPC_&#34;\u000a\u0009DefaultDebugPath = &#34;/debug/rpc&#34;\u000a)</pre>\u000a\u000a","names":["DefaultRPCPath","DefaultDebugPath"],"type":""}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultServer!\">DefaultServer</a></h2>\u000a<pre>var DefaultServer = NewServer()</pre>\u000a<p>\u000aDefaultServer is the default instance of *Server.\u000a</p>\u000a\u000a","names":["DefaultServer"],"type":""}]}