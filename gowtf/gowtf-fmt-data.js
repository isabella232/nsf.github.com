var gowtfData = {"html":"<p>\u000aPackage fmt implements formatted I/O with functions analogous\u000ato C&#39;s printf and scanf.  The format &#39;verbs&#39; are derived from C&#39;s but\u000aare simpler.\u000a</p>\u000a<p>\u000aPrinting:\u000a</p>\u000a<p>\u000aThe verbs:\u000a</p>\u000a<p>\u000aGeneral:\u000a</p>\u000a<pre>%v\u0009the value in a default format.\u000a\u0009when printing structs, the plus flag (%+v) adds field names\u000a%#v\u0009a Go-syntax representation of the value\u000a%T\u0009a Go-syntax representation of the type of the value\u000a</pre>\u000a<p>\u000aBoolean:\u000a</p>\u000a<pre>%t\u0009the word true or false\u000a</pre>\u000a<p>\u000aInteger:\u000a</p>\u000a<pre>%b\u0009base 2\u000a%c\u0009the character represented by the corresponding Unicode code point\u000a%d\u0009base 10\u000a%o\u0009base 8\u000a%x\u0009base 16, with lower-case letters for a-f\u000a%X\u0009base 16, with upper-case letters for A-F\u000a</pre>\u000a<p>\u000aFloating-point and complex constituents:\u000a</p>\u000a<pre>%e\u0009scientific notation, e.g. -1234.456e+78\u000a%E\u0009scientific notation, e.g. -1234.456E+78\u000a%f\u0009decimal point but no exponent, e.g. 123.456\u000a%g\u0009whichever of %e or %f produces more compact output\u000a%G\u0009whichever of %E or %f produces more compact output\u000a</pre>\u000a<p>\u000aString and slice of bytes:\u000a</p>\u000a<pre>%s\u0009the uninterpreted bytes of the string or slice\u000a%q\u0009a double-quoted string safely escaped with Go syntax\u000a%x\u0009base 16 notation with two characters per byte\u000a</pre>\u000a<p>\u000aPointer:\u000a</p>\u000a<pre>%p\u0009base 16 notation, with leading 0x\u000a</pre>\u000a<p>\u000aThere is no &#39;u&#39; flag.  Integers are printed unsigned if they have unsigned type.\u000aSimilarly, there is no need to specify the size of the operand (int8, int64).\u000a</p>\u000a<p>\u000aFor numeric values, the width and precision flags control\u000aformatting; width sets the width of the field, precision the\u000anumber of places after the decimal, if appropriate.  The\u000aformat %6.2f prints 123.45. The width of a field is the number\u000aof Unicode code points in the string. This differs from C&#39;s printf where\u000athe field width is the number of bytes.  Either or both of the\u000aflags may be replaced with the character &#39;*&#39;, causing their values\u000ato be obtained from the next operand, which must be of type int.\u000a</p>\u000a<p>\u000aOther flags:\u000a</p>\u000a<pre>+\u0009always print a sign for numeric values\u000a-\u0009pad with spaces on the right rather than the left (left-justify the field)\u000a#\u0009alternate format: add leading 0 for octal (%#o), 0x for hex (%#x);\u000a\u00090X for hex (%#X); suppress 0x for %p (%#p);\u000a\u0009print a raw (backquoted) string if possible for %q (%#q)\u000a&#39; &#39;\u0009(space) leave a space for elided sign in numbers (% d);\u000a\u0009put spaces between bytes printing strings or slices in hex (% x)\u000a0\u0009pad with leading zeros rather than spaces\u000a</pre>\u000a<p>\u000aFor each Printf-like function, there is also a Print function\u000athat takes no format and is equivalent to saying %v for every\u000aoperand.  Another variant Println inserts blanks between\u000aoperands and appends a newline.\u000a</p>\u000a<p>\u000aRegardless of the verb, if an operand is an interface value,\u000athe internal concrete value is used, not the interface itself.\u000aThus:\u000a</p>\u000a<pre>var i interface{} = 23\u000afmt.Printf(&#34;%v\\n&#34;, i)\u000a</pre>\u000a<p>\u000awill print 23.\u000a</p>\u000a<p>\u000aIf an operand implements interface Formatter, that interface\u000acan be used for fine control of formatting.\u000a</p>\u000a<p>\u000aIf an operand implements method String() string that method\u000awill be used to convert the object to a string, which will then\u000abe formatted as required by the verb (if any). To avoid\u000arecursion in cases such as\u000a</p>\u000a<pre>type X int\u000afunc (x X) String() string { return Sprintf(&#34;%d&#34;, x) }\u000a</pre>\u000a<p>\u000acast the value before recurring:\u000a</p>\u000a<pre>func (x X) String() string { return Sprintf(&#34;%d&#34;, int(x)) }\u000a</pre>\u000a<p>\u000aFormat errors:\u000a</p>\u000a<p>\u000aIf an invalid argument is given for a verb, such as providing\u000aa string to %d, the generated string will contain a\u000adescription of the problem, as in these examples:\u000a</p>\u000a<pre>Wrong type or unknown verb: %!verb(type=value)\u000a\u0009Printf(&#34;%d&#34;, hi):          %!d(string=hi)\u000aToo many arguments: %!(EXTRA type=value)\u000a\u0009Printf(&#34;hi&#34;, &#34;guys&#34;):      hi%!(EXTRA string=guys)\u000aToo few arguments: %!verb(MISSING)\u000a\u0009Printf(&#34;hi%d&#34;):            hi %!d(MISSING)\u000aNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\u000a\u0009Printf(&#34;%*s&#34;, 4.5, &#34;hi&#34;):  %!(BADWIDTH)hi\u000a\u0009Printf(&#34;%.*s&#34;, 4.5, &#34;hi&#34;): %!(BADPREC)hi\u000a</pre>\u000a<p>\u000aAll errors begin with the string &#34;%!&#34; followed sometimes\u000aby a single character (the verb) and end with a parenthesized\u000adescription.\u000a</p>\u000a<p>\u000aScanning:\u000a</p>\u000a<p>\u000aAn analogous set of functions scans formatted text to yield\u000avalues.  Scan, Scanf and Scanln read from os.Stdin; Fscan,\u000aFscanf and Fscanln read from a specified os.Reader; Sscan,\u000aSscanf and Sscanln read from an argument string.  Sscanln,\u000aFscanln and Sscanln stop scanning at a newline and require that\u000athe items be followed by one; Sscanf, Fscanf and Sscanf require\u000anewlines in the input to match newlines in the format; the other\u000aroutines treat newlines as spaces.\u000a</p>\u000a<p>\u000aScanf, Fscanf, and Sscanf parse the arguments according to a\u000aformat string, analogous to that of Printf.  For example, %x\u000awill scan an integer as a hexadecimal number, and %v will scan\u000athe default representation format for the value.\u000a</p>\u000a<p>\u000aThe formats behave analogously to those of Printf with the\u000afollowing exceptions:\u000a</p>\u000a<p>\u000a%p is not implemented\u000a%T is not implemented\u000a%e %E %f %F %g %g are all equivalent and scan any floating\u000a</p>\u000a<pre>point or complex value\u000a</pre>\u000a<p>\u000a%s and %v on strings scan a space-delimited token\u000a</p>\u000a<p>\u000aWidth is interpreted in the input text (%5s means at most\u000afive runes of input will be read to scan a string) but there\u000ais no syntax for scanning with a precision (no %5.2f, just\u000a%5f).\u000a</p>\u000a<p>\u000aWhen scanning with a format, all non-empty runs of space\u000acharacters (except newline) are equivalent to a single\u000aspace in both the format and the input.  With that proviso,\u000atext in the format string must match the input text; scanning\u000astops if it does not, with the return value of the function\u000aindicating the number of arguments scanned.\u000a</p>\u000a<p>\u000aIn all the scanning functions, if an operand implements method\u000aScan (that is, it implements the Scanner interface) that\u000amethod will be used to scan the text for that operand.  Also,\u000aif the number of arguments scanned is less than the number of\u000aarguments provided, an error is returned.\u000a</p>\u000a<p>\u000aAll arguments to be scanned must be either pointers to basic\u000atypes or implementations of the Scanner interface.\u000a</p>\u000a<p>\u000aNote: Fscan etc. can read one character (rune) past the\u000ainput they return, which means that a loop calling a scan\u000aroutine may skip some of the input.  This is usually a\u000aproblem only when there is no space between input values.\u000aHowever, if the reader provided to Fscan implements UnreadRune,\u000athat method will be used to save the character and successive\u000acalls will not lose data.  To attach an UnreadRune method\u000ato a reader without that capability, use bufio.NewReader.\u000a</p>\u000a","name":"fmt","filenames":["/home/nsf/go/src/pkg/fmt/format.go","/home/nsf/go/src/pkg/fmt/scan.go","/home/nsf/go/src/pkg/fmt/print.go","/home/nsf/go/src/pkg/fmt/doc.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Formatter!\">Formatter</a></h2>\u000a<pre>type Formatter interface {\u000a\u0009Format(f State, c int)\u000a}</pre>\u000a<p>\u000aFormatter is the interface implemented by values with a custom formatter.\u000aThe implementation of Format may call Sprintf or Fprintf(f) etc.\u000ato generate its output.\u000a</p>\u000a\u000a","name":"Formatter","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoStringer!\">GoStringer</a></h2>\u000a<pre>type GoStringer interface {\u000a\u0009GoString() string\u000a}</pre>\u000a<p>\u000aGoStringer is implemented by any value that has a GoString() method,\u000awhich defines the Go syntax for that value.\u000aThe GoString method is used to print values passed as an operand\u000ato a %#v format.\u000a</p>\u000a\u000a","name":"GoStringer","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ScanState!\">ScanState</a></h2>\u000a<pre>type ScanState interface {\u000a\u0009// GetRune reads the next rune (Unicode code point) from the input.\u000a\u0009GetRune() (rune int, err os.Error)\u000a\u0009// UngetRune causes the next call to GetRune to return the rune.\u000a\u0009UngetRune()\u000a\u0009// Width returns the value of the width option and whether it has been set.\u000a\u0009// The unit is Unicode code points.\u000a\u0009Width() (wid int, ok bool)\u000a\u0009// Token returns the next space-delimited token from the input. If\u000a\u0009// a width has been specified, the returned token will be no longer\u000a\u0009// than the width.\u000a\u0009Token() (token string, err os.Error)\u000a}</pre>\u000a<p>\u000aScanState represents the scanner state passed to custom scanners.\u000aScanners may do rune-at-a-time scanning or ask the ScanState\u000ato discover the next space-delimited token.\u000a</p>\u000a\u000a","name":"ScanState","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scanner!\">Scanner</a></h2>\u000a<pre>type Scanner interface {\u000a\u0009Scan(state ScanState, verb int) os.Error\u000a}</pre>\u000a<p>\u000aScanner is implemented by any value that has a Scan method, which scans\u000athe input for the representation of a value and stores the result in the\u000areceiver, which must be a pointer to be useful.  The Scan method is called\u000afor any argument to Scan or Scanln that implements it.\u000a</p>\u000a\u000a","name":"Scanner","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:State!\">State</a></h2>\u000a<pre>type State interface {\u000a\u0009// Write is the function to call to emit formatted output to be printed.\u000a\u0009Write(b []byte) (ret int, err os.Error)\u000a\u0009// Width returns the value of the width option and whether it has been set.\u000a\u0009Width() (wid int, ok bool)\u000a\u0009// Precision returns the value of the precision option and whether it has been set.\u000a\u0009Precision() (prec int, ok bool)\u000a\u000a\u0009// Flag returns whether the flag c, a character, has been set.\u000a\u0009Flag(int) bool\u000a}</pre>\u000a<p>\u000aState represents the printer state passed to custom formatters.\u000aIt provides access to the io.Writer interface plus information about\u000athe flags and options for the operand&#39;s format specifier.\u000a</p>\u000a\u000a","name":"State","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Stringer!\">Stringer</a></h2>\u000a<pre>type Stringer interface {\u000a\u0009String() string\u000a}</pre>\u000a<p>\u000aStringer is implemented by any value that has a String method(),\u000awhich defines the &ldquo;native&rdquo; format for that value.\u000aThe String method is used to print values passed as an operand\u000ato a %s or %v format or to an unformatted printer such as Print.\u000a</p>\u000a\u000a","name":"Stringer","methods":[]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Errorf!\">Errorf</a></h2>\u000a<code>func Errorf(format string, a ...interface{}) os.Error</code>\u000a<p>\u000aErrorf formats according to a format specifier and returns the string\u000aconverted to an os.ErrorString, which satisfies the os.Error interface.\u000a</p>\u000a\u000a","name":"Errorf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fprint!\">Fprint</a></h2>\u000a<code>func Fprint(w io.Writer, a ...interface{}) (n int, error os.Error)</code>\u000a<p>\u000aFprint formats using the default formats for its operands and writes to w.\u000aSpaces are added between operands when neither is a string.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Fprint"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fprintf!\">Fprintf</a></h2>\u000a<code>func Fprintf(w io.Writer, format string, a ...interface{}) (n int, error os.Error)</code>\u000a<p>\u000aFprintf formats according to a format specifier and writes to w.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Fprintf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fprintln!\">Fprintln</a></h2>\u000a<code>func Fprintln(w io.Writer, a ...interface{}) (n int, error os.Error)</code>\u000a<p>\u000aFprintln formats using the default formats for its operands and writes to w.\u000aSpaces are always added between operands and a newline is appended.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Fprintln"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fscan!\">Fscan</a></h2>\u000a<code>func Fscan(r io.Reader, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aFscan scans text read from r, storing successive space-separated\u000avalues into successive arguments.  Newlines count as space.  It\u000areturns the number of items successfully scanned.  If that is less\u000athan the number of arguments, err will report why.\u000a</p>\u000a\u000a","name":"Fscan"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fscanf!\">Fscanf</a></h2>\u000a<code>func Fscanf(r io.Reader, format string, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aFscanf scans text read from r, storing successive space-separated\u000avalues into successive arguments as determined by the format.  It\u000areturns the number of items successfully parsed.\u000a</p>\u000a\u000a","name":"Fscanf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fscanln!\">Fscanln</a></h2>\u000a<code>func Fscanln(r io.Reader, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aFscanln is similar to Fscan, but stops scanning at a newline and\u000aafter the final item there must be a newline or EOF.\u000a</p>\u000a\u000a","name":"Fscanln"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Print!\">Print</a></h2>\u000a<code>func Print(a ...interface{}) (n int, errno os.Error)</code>\u000a<p>\u000aPrint formats using the default formats for its operands and writes to standard output.\u000aSpaces are added between operands when neither is a string.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Print"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Printf!\">Printf</a></h2>\u000a<code>func Printf(format string, a ...interface{}) (n int, errno os.Error)</code>\u000a<p>\u000aPrintf formats according to a format specifier and writes to standard output.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Printf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Println!\">Println</a></h2>\u000a<code>func Println(a ...interface{}) (n int, errno os.Error)</code>\u000a<p>\u000aPrintln formats using the default formats for its operands and writes to standard output.\u000aSpaces are always added between operands and a newline is appended.\u000aIt returns the number of bytes written and any write error encountered.\u000a</p>\u000a\u000a","name":"Println"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Scan!\">Scan</a></h2>\u000a<code>func Scan(a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aScan scans text read from standard input, storing successive\u000aspace-separated values into successive arguments.  Newlines count\u000aas space.  It returns the number of items successfully scanned.\u000aIf that is less than the number of arguments, err will report why.\u000a</p>\u000a\u000a","name":"Scan"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Scanf!\">Scanf</a></h2>\u000a<code>func Scanf(format string, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aScanf scans text read from standard input, storing successive\u000aspace-separated values into successive arguments as determined by\u000athe format.  It returns the number of items successfully scanned.\u000a</p>\u000a\u000a","name":"Scanf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Scanln!\">Scanln</a></h2>\u000a<code>func Scanln(a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aScanln is similar to Scan, but stops scanning at a newline and\u000aafter the final item there must be a newline or EOF.\u000a</p>\u000a\u000a","name":"Scanln"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sprint!\">Sprint</a></h2>\u000a<code>func Sprint(a ...interface{}) string</code>\u000a<p>\u000aSprint formats using the default formats for its operands and returns the resulting string.\u000aSpaces are added between operands when neither is a string.\u000a</p>\u000a\u000a","name":"Sprint"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sprintf!\">Sprintf</a></h2>\u000a<code>func Sprintf(format string, a ...interface{}) string</code>\u000a<p>\u000aSprintf formats according to a format specifier and returns the resulting string.\u000a</p>\u000a\u000a","name":"Sprintf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sprintln!\">Sprintln</a></h2>\u000a<code>func Sprintln(a ...interface{}) string</code>\u000a<p>\u000aSprintln formats using the default formats for its operands and returns the resulting string.\u000aSpaces are always added between operands and a newline is appended.\u000a</p>\u000a\u000a","name":"Sprintln"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sscan!\">Sscan</a></h2>\u000a<code>func Sscan(str string, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aSscan scans the argument string, storing successive space-separated\u000avalues into successive arguments.  Newlines count as space.  It\u000areturns the number of items successfully scanned.  If that is less\u000athan the number of arguments, err will report why.\u000a</p>\u000a\u000a","name":"Sscan"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sscanf!\">Sscanf</a></h2>\u000a<code>func Sscanf(str string, format string, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aSscanf scans the argument string, storing successive space-separated\u000avalues into successive arguments as determined by the format.  It\u000areturns the number of items successfully parsed.\u000a</p>\u000a\u000a","name":"Sscanf"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sscanln!\">Sscanln</a></h2>\u000a<code>func Sscanln(str string, a ...interface{}) (n int, err os.Error)</code>\u000a<p>\u000aSscanln is similar to Sscan, but stops scanning at a newline and\u000aafter the final item there must be a newline or EOF.\u000a</p>\u000a\u000a","name":"Sscanln"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EOF!\">EOF</a></h2>\u000a<pre>const EOF = -1</pre>\u000a\u000a","names":["EOF"],"type":""}],"vars":[]}