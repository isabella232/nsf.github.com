var gowtfData = {"index":"index.html","html":"<p>\u000aOgle is the beginning of a debugger for Go.\u000a</p>\u000a","name":"ogle","filenames":["/home/nsf/go/src/pkg/exp/ogle/abort.go","/home/nsf/go/src/pkg/exp/ogle/event.go","/home/nsf/go/src/pkg/exp/ogle/rtype.go","/home/nsf/go/src/pkg/exp/ogle/rruntime.go","/home/nsf/go/src/pkg/exp/ogle/goroutine.go","/home/nsf/go/src/pkg/exp/ogle/arch.go","/home/nsf/go/src/pkg/exp/ogle/vars.go","/home/nsf/go/src/pkg/exp/ogle/rvalue.go","/home/nsf/go/src/pkg/exp/ogle/frame.go","/home/nsf/go/src/pkg/exp/ogle/cmd.go","/home/nsf/go/src/pkg/exp/ogle/process.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Arch!\">Arch</a></h2>\u000a<pre>type Arch interface {\u000a\u0009// ToWord converts an array of up to 8 bytes in memory order\u000a\u0009// to a word.\u000a\u0009ToWord(data []byte) proc.Word\u000a\u0009// FromWord converts a word to an array of up to 8 bytes in\u000a\u0009// memory order.\u000a\u0009FromWord(v proc.Word, out []byte)\u000a\u0009// ToFloat32 converts a word to a float.  The order of this\u000a\u0009// word will be the order returned by ToWord on the memory\u000a\u0009// representation of a float, and thus may require reversing.\u000a\u0009ToFloat32(bits uint32) float32\u000a\u0009// FromFloat32 converts a float to a word.  This should return\u000a\u0009// a word that can be passed to FromWord to get the memory\u000a\u0009// representation of a float on this architecture.\u000a\u0009FromFloat32(f float32) uint32\u000a\u0009// ToFloat64 is to float64 as ToFloat32 is to float32.\u000a\u0009ToFloat64(bits uint64) float64\u000a\u0009// FromFloat64 is to float64 as FromFloat32 is to float32.\u000a\u0009FromFloat64(f float64) uint64\u000a\u000a\u0009// IntSize returns the number of bytes in an &#39;int&#39;.\u000a\u0009IntSize() int\u000a\u0009// PtrSize returns the number of bytes in a &#39;uintptr&#39;.\u000a\u0009PtrSize() int\u000a\u0009// FloatSize returns the number of bytes in a &#39;float&#39;.\u000a\u0009FloatSize() int\u000a\u0009// Align rounds offset up to the appropriate offset for a\u000a\u0009// basic type with the given width.\u000a\u0009Align(offset, width int) int\u000a\u000a\u0009// G returns the current G pointer.\u000a\u0009G(regs proc.Regs) proc.Word\u000a\u000a\u0009// ClosureSize returns the number of bytes expected by\u000a\u0009// ParseClosure.\u000a\u0009ClosureSize() int\u000a\u0009// ParseClosure takes ClosureSize bytes read from a return PC\u000a\u0009// in a remote process, determines if the code is a closure,\u000a\u0009// and returns the frame size of the closure if it is.\u000a\u0009ParseClosure(data []byte) (frame int, ok bool)\u000a}</pre>\u000a\u000a","name":"Arch","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArchAlignedMultiple!\">ArchAlignedMultiple</a></h2>\u000a<pre>type ArchAlignedMultiple struct{}</pre>\u000a\u000a","name":"ArchAlignedMultiple","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchAlignedMultiple\">func (ArchAlignedMultiple)</a> <a href=\"?m:ArchAlignedMultiple.Align!\">Align</a></h2>\u000a<code>func (ArchAlignedMultiple) Align(offset, width int) int</code>\u000a\u000a","name":"Align"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArchLSB!\">ArchLSB</a></h2>\u000a<pre>type ArchLSB struct{}</pre>\u000a\u000a","name":"ArchLSB","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromFloat32!\">FromFloat32</a></h2>\u000a<code>func (ArchLSB) FromFloat32(f float32) uint32</code>\u000a\u000a","name":"FromFloat32"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromFloat64!\">FromFloat64</a></h2>\u000a<code>func (ArchLSB) FromFloat64(f float64) uint64</code>\u000a\u000a","name":"FromFloat64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromWord!\">FromWord</a></h2>\u000a<code>func (ArchLSB) FromWord(v proc.Word, out []byte)</code>\u000a\u000a","name":"FromWord"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToFloat32!\">ToFloat32</a></h2>\u000a<code>func (ArchLSB) ToFloat32(bits uint32) float32</code>\u000a\u000a","name":"ToFloat32"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToFloat64!\">ToFloat64</a></h2>\u000a<code>func (ArchLSB) ToFloat64(bits uint64) float64</code>\u000a\u000a","name":"ToFloat64"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToWord!\">ToWord</a></h2>\u000a<code>func (ArchLSB) ToWord(data []byte) proc.Word</code>\u000a\u000a","name":"ToWord"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Breakpoint!\">Breakpoint</a></h2>\u000a<pre>type Breakpoint struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Breakpoint event occurs when a process reaches a particular\u000aprogram counter.  When this event is handled, the current goroutine\u000awill be the goroutine that reached the program counter.\u000a</p>\u000a\u000a","name":"Breakpoint","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Breakpoint\">func (*Breakpoint)</a> <a href=\"?m:Breakpoint.PC!\">PC</a></h2>\u000a<code>func (b *Breakpoint) PC() proc.Word</code>\u000a\u000a","name":"PC"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Breakpoint\">func (*Breakpoint)</a> <a href=\"?m:Breakpoint.String!\">String</a></h2>\u000a<code>func (b *Breakpoint) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Event!\">Event</a></h2>\u000a<pre>type Event interface {\u000a\u0009Process() *Process\u000a\u0009Goroutine() *Goroutine\u000a\u0009String() string\u000a}</pre>\u000a\u000a","name":"Event","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventAction!\">EventAction</a></h2>\u000a<pre>type EventAction int</pre>\u000a<p>\u000aAn EventAction is an event handler&#39;s response to an event.  If all\u000aof an event&#39;s handlers execute without returning errors, their\u000aresults are combined as follows: If any handler returned\u000aEAContinue, then the process resumes (without returning from\u000aWaitStop); otherwise, if any handler returned EAStop, the process\u000aremains stopped; otherwise, if all handlers returned EADefault, the\u000aprocess resumes.  A handler may return EARemoveSelf bit-wise or&#39;d\u000awith any other action to indicate that the handler should be\u000aremoved from the hook.\u000a</p>\u000a\u000a","name":"EventAction","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventHandler!\">EventHandler</a></h2>\u000a<pre>type EventHandler func(e Event) (EventAction, os.Error)</pre>\u000a<p>\u000aAn EventHandler is a function that takes an event and returns a\u000aresponse to that event and possibly an error.  If an event handler\u000areturns an error, the process stops and no other handlers for that\u000aevent are executed.\u000a</p>\u000a\u000a","name":"EventHandler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventHook!\">EventHook</a></h2>\u000a<pre>type EventHook interface {\u000a\u0009AddHandler(EventHandler)\u000a\u0009RemoveHandler(EventHandler)\u000a\u0009NumHandler() int\u000a\u000a\u0009String() string\u000a\u0009// contains unexported methods\u000a}</pre>\u000a<p>\u000aA EventHook allows event handlers to be added and removed.\u000a</p>\u000a\u000a","name":"EventHook","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatError!\">FormatError</a></h2>\u000a<pre>type FormatError string</pre>\u000a<p>\u000aA FormatError indicates a failure to process information in or\u000aabout a remote process, such as unexpected or missing information\u000ain the object file or runtime structures.\u000a</p>\u000a\u000a","name":"FormatError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:FormatError\">func (FormatError)</a> <a href=\"?m:FormatError.String!\">String</a></h2>\u000a<code>func (e FormatError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Frame!\">Frame</a></h2>\u000a<pre>type Frame struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Frame represents a single frame on a remote call stack.\u000a</p>\u000a\u000a","name":"Frame","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.Inner!\">Inner</a></h2>\u000a<code>func (f *Frame) Inner() *Frame</code>\u000a<p>\u000aInner returns the Frame called by this Frame, or nil if this is the\u000ainnermost frame.\u000a</p>\u000a\u000a","name":"Inner"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.Outer!\">Outer</a></h2>\u000a<code>func (f *Frame) Outer() (*Frame, os.Error)</code>\u000a<p>\u000aOuter returns the Frame that called this Frame, or nil if this is\u000athe outermost frame.\u000a</p>\u000a\u000a","name":"Outer"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.String!\">String</a></h2>\u000a<code>func (f *Frame) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Goroutine!\">Goroutine</a></h2>\u000a<pre>type Goroutine struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Goroutine represents a goroutine in a remote process.\u000a</p>\u000a\u000a","name":"Goroutine","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.In!\">In</a></h2>\u000a<code>func (t *Goroutine) In() os.Error</code>\u000a<p>\u000aIn selects the frame called by the current frame.\u000a</p>\u000a\u000a","name":"In"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.Out!\">Out</a></h2>\u000a<code>func (t *Goroutine) Out() os.Error</code>\u000a<p>\u000aOut selects the caller frame of the current frame.\u000a</p>\u000a\u000a","name":"Out"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.String!\">String</a></h2>\u000a<code>func (t *Goroutine) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoroutineCreate!\">GoroutineCreate</a></h2>\u000a<pre>type GoroutineCreate struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA GoroutineCreate event occurs when a process creates a new\u000agoroutine.  When this event is handled, the current goroutine will\u000abe the newly created goroutine.\u000a</p>\u000a\u000a","name":"GoroutineCreate","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:GoroutineCreate\">func (*GoroutineCreate)</a> <a href=\"?m:GoroutineCreate.Parent!\">Parent</a></h2>\u000a<code>func (e *GoroutineCreate) Parent() *Goroutine</code>\u000a<p>\u000aParent returns the goroutine that created this goroutine.  May be\u000anil if this event is the creation of the first goroutine.\u000a</p>\u000a\u000a","name":"Parent"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:GoroutineCreate\">func (*GoroutineCreate)</a> <a href=\"?m:GoroutineCreate.String!\">String</a></h2>\u000a<code>func (e *GoroutineCreate) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoroutineExit!\">GoroutineExit</a></h2>\u000a<pre>type GoroutineExit struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA GoroutineExit event occurs when a Go goroutine exits.\u000a</p>\u000a\u000a","name":"GoroutineExit","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:GoroutineExit\">func (*GoroutineExit)</a> <a href=\"?m:GoroutineExit.String!\">String</a></h2>\u000a<code>func (e *GoroutineExit) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NoCurrentGoroutine!\">NoCurrentGoroutine</a></h2>\u000a<pre>type NoCurrentGoroutine struct{}</pre>\u000a<p>\u000aA NoCurrentGoroutine error occurs when no goroutine is currently\u000aselected in a process (or when there are no goroutines in a\u000aprocess).\u000a</p>\u000a\u000a","name":"NoCurrentGoroutine","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NoCurrentGoroutine\">func (NoCurrentGoroutine)</a> <a href=\"?m:NoCurrentGoroutine.String!\">String</a></h2>\u000a<code>func (e NoCurrentGoroutine) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NotOnStack!\">NotOnStack</a></h2>\u000a<pre>type NotOnStack struct {\u000a\u0009Fn        *gosym.Func\u000a\u0009Goroutine *Goroutine\u000a}</pre>\u000a<p>\u000aA NotOnStack error occurs when attempting to access a variable in a\u000aremote frame where that remote frame is not on the current stack.\u000a</p>\u000a\u000a","name":"NotOnStack","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:NotOnStack\">func (NotOnStack)</a> <a href=\"?m:NotOnStack.String!\">String</a></h2>\u000a<code>func (e NotOnStack) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Process!\">Process</a></h2>\u000a<pre>type Process struct {\u000a\u0009Arch\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Process represents a remote attached process.\u000a</p>\u000a\u000a","name":"Process","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.ContWait!\">ContWait</a></h2>\u000a<code>func (p *Process) ContWait() os.Error</code>\u000a<p>\u000aContWait resumes process execution and waits for an event to occur\u000athat stops the process.\u000a</p>\u000a\u000a","name":"ContWait"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Event!\">Event</a></h2>\u000a<code>func (p *Process) Event() Event</code>\u000a<p>\u000aEvent returns the last event that caused the process to stop.  This\u000amay return nil if the process has never been stopped by an event.\u000a</p>\u000a<p>\u000aTODO(austin) Return nil if the user calls p.Stop()?\u000a</p>\u000a\u000a","name":"Event"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.In!\">In</a></h2>\u000a<code>func (p *Process) In() os.Error</code>\u000a<p>\u000aIn selects the frame called by the current frame.\u000a</p>\u000a\u000a","name":"In"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnBreakpoint!\">OnBreakpoint</a></h2>\u000a<code>func (p *Process) OnBreakpoint(pc proc.Word) EventHook</code>\u000a<p>\u000aOnBreakpoint returns the hook that is run when the program reaches\u000athe given program counter.\u000a</p>\u000a\u000a","name":"OnBreakpoint"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnGoroutineCreate!\">OnGoroutineCreate</a></h2>\u000a<code>func (p *Process) OnGoroutineCreate() EventHook</code>\u000a<p>\u000aOnGoroutineCreate returns the hook that is run when a goroutine is created.\u000a</p>\u000a\u000a","name":"OnGoroutineCreate"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnGoroutineExit!\">OnGoroutineExit</a></h2>\u000a<code>func (p *Process) OnGoroutineExit() EventHook</code>\u000a<p>\u000aOnGoroutineExit returns the hook that is run when a goroutine exits.\u000a</p>\u000a\u000a","name":"OnGoroutineExit"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Out!\">Out</a></h2>\u000a<code>func (p *Process) Out() os.Error</code>\u000a<p>\u000aOut selects the caller frame of the current frame.\u000a</p>\u000a\u000a","name":"Out"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Peek!\">Peek</a></h2>\u000a<code>func (p *Process) Peek(addr proc.Word, out []byte) (int, os.Error)</code>\u000a\u000a","name":"Peek"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Poke!\">Poke</a></h2>\u000a<code>func (p *Process) Poke(addr proc.Word, b []byte) (int, os.Error)</code>\u000a\u000a","name":"Poke"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProcessNotStopped!\">ProcessNotStopped</a></h2>\u000a<pre>type ProcessNotStopped struct{}</pre>\u000a<p>\u000aA ProcessNotStopped error occurs when attempting to read or write\u000amemory or registers of a process that is not stopped.\u000a</p>\u000a\u000a","name":"ProcessNotStopped","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ProcessNotStopped\">func (ProcessNotStopped)</a> <a href=\"?m:ProcessNotStopped.String!\">String</a></h2>\u000a<code>func (e ProcessNotStopped) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadOnlyError!\">ReadOnlyError</a></h2>\u000a<pre>type ReadOnlyError string</pre>\u000a<p>\u000aA ReadOnlyError occurs when attempting to set or assign to a\u000aread-only value.\u000a</p>\u000a\u000a","name":"ReadOnlyError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ReadOnlyError\">func (ReadOnlyError)</a> <a href=\"?m:ReadOnlyError.String!\">String</a></h2>\u000a<code>func (e ReadOnlyError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RemoteMismatchError!\">RemoteMismatchError</a></h2>\u000a<pre>type RemoteMismatchError string</pre>\u000a<p>\u000aA RemoteMismatchError occurs when an operation that requires two\u000aidentical remote processes is given different process.  For\u000aexample, this occurs when trying to set a pointer in one process to\u000apoint to something in another process.\u000a</p>\u000a\u000a","name":"RemoteMismatchError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:RemoteMismatchError\">func (RemoteMismatchError)</a> <a href=\"?m:RemoteMismatchError.String!\">String</a></h2>\u000a<code>func (e RemoteMismatchError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownArchitecture!\">UnknownArchitecture</a></h2>\u000a<pre>type UnknownArchitecture elf.Machine</pre>\u000a<p>\u000aAn UnknownArchitecture occurs when trying to load an object file\u000athat indicates an architecture not supported by the debugger.\u000a</p>\u000a\u000a","name":"UnknownArchitecture","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownArchitecture\">func (UnknownArchitecture)</a> <a href=\"?m:UnknownArchitecture.String!\">String</a></h2>\u000a<code>func (e UnknownArchitecture) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownGoroutine!\">UnknownGoroutine</a></h2>\u000a<pre>type UnknownGoroutine struct {\u000a\u0009OSThread  proc.Thread\u000a\u0009Goroutine proc.Word\u000a}</pre>\u000a<p>\u000aAn UnknownGoroutine error is an internal error representing an\u000aunrecognized G structure pointer.\u000a</p>\u000a\u000a","name":"UnknownGoroutine","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UnknownGoroutine\">func (UnknownGoroutine)</a> <a href=\"?m:UnknownGoroutine.String!\">String</a></h2>\u000a<code>func (e UnknownGoroutine) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UsageError!\">UsageError</a></h2>\u000a<pre>type UsageError string</pre>\u000a<p>\u000aA UsageError occurs when a command is called with illegal arguments.\u000a</p>\u000a\u000a","name":"UsageError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:UsageError\">func (UsageError)</a> <a href=\"?m:UsageError.String!\">String</a></h2>\u000a<code>func (e UsageError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EventPrint!\">EventPrint</a></h2>\u000a<code>func EventPrint(ev Event) (EventAction, os.Error)</code>\u000a<p>\u000aEventPrint is a standard event handler that prints events as they\u000aoccur.  It will not cause the process to stop.\u000a</p>\u000a\u000a","name":"EventPrint"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EventStop!\">EventStop</a></h2>\u000a<code>func EventStop(ev Event) (EventAction, os.Error)</code>\u000a<p>\u000aEventStop is a standard event handler that causes the process to stop.\u000a</p>\u000a\u000a","name":"EventStop"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Main!\">Main</a></h2>\u000a<code>func Main()</code>\u000a\u000a","name":"Main"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewProcess!\">NewProcess</a></h2>\u000a<code>func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.Error)</code>\u000a<p>\u000aNewProcess constructs a new remote process around a traced\u000aprocess, an architecture, and a symbol table.\u000a</p>\u000a\u000a","name":"NewProcess"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewProcessElf!\">NewProcessElf</a></h2>\u000a<code>func NewProcessElf(tproc proc.Process, f *elf.File) (*Process, os.Error)</code>\u000a<p>\u000aNewProcessElf constructs a new remote process around a traced\u000aprocess and the process&#39; ELF object.\u000a</p>\u000a\u000a","name":"NewProcessElf"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EventAction!\">EventAction</a></h2>\u000a<pre>const (\u000a\u0009EARemoveSelf EventAction = 0x100\u000a\u0009EADefault    EventAction = iota\u000a\u0009EAStop\u000a\u0009EAContinue\u000a)</pre>\u000a\u000a","names":["EARemoveSelf","EADefault","EAStop","EAContinue"],"type":"EventAction"}],"vars":[{"html":"\u000a<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Amd64!\">Amd64</a></h2>\u000a<pre>var Amd64 = &amp;amd64{gReg: -1}</pre>\u000a\u000a","names":["Amd64"],"type":""}]}