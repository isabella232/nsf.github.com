var gowtfData = {"html":"<p>\u000aThe bytes package implements functions for the manipulation of byte slices.\u000aAnalogous to the facilities of the strings package.\u000a</p>\u000a","name":"bytes","filenames":["/home/nsf/go/src/pkg/bytes/bytes_decl.go","/home/nsf/go/src/pkg/bytes/bytes.go","/home/nsf/go/src/pkg/bytes/buffer.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Buffer!\">Buffer</a></h2>\u000a<pre>type Buffer struct {\u000a\u0009buf       []byte            // contents are the bytes buf[off : len(buf)]\u000a\u0009off       int               // read at &amp;buf[off], write at &amp;buf[len(buf)]\u000a\u0009runeBytes [utf8.UTFMax]byte // avoid allocation of slice on each WriteByte or Rune\u000a\u0009bootstrap [64]byte          // memory to hold first slice; helps small buffers (Printf) avoid allocation.\u000a}</pre>\u000a<p>\u000aA Buffer is a variable-sized buffer of bytes with Read and Write methods.\u000aThe zero value for Buffer is an empty buffer ready to use.\u000a</p>\u000a\u000a","name":"Buffer","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Bytes!\">Bytes</a></h2>\u000a<code>func (b *Buffer) Bytes() []byte</code>\u000a<p>\u000aBytes returns a slice of the contents of the unread portion of the buffer;\u000alen(b.Bytes()) == b.Len().  If the caller changes the contents of the\u000areturned slice, the contents of the buffer will change provided there\u000aare no intervening method calls on the Buffer.\u000a</p>\u000a\u000a","name":"Bytes"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Len!\">Len</a></h2>\u000a<code>func (b *Buffer) Len() int</code>\u000a<p>\u000aLen returns the number of bytes of the unread portion of the buffer;\u000ab.Len() == len(b.Bytes()).\u000a</p>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Next!\">Next</a></h2>\u000a<code>func (b *Buffer) Next(n int) []byte</code>\u000a<p>\u000aNext returns a slice containing the next n bytes from the buffer,\u000aadvancing the buffer as if the bytes had been returned by Read.\u000aIf there are fewer than n bytes in the buffer, Next returns the entire buffer.\u000aThe slice is only valid until the next call to a read or write method.\u000a</p>\u000a\u000a","name":"Next"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Read!\">Read</a></h2>\u000a<code>func (b *Buffer) Read(p []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead reads the next len(p) bytes from the buffer or until the buffer\u000ais drained.  The return value n is the number of bytes read.  If the\u000abuffer has no data to return, err is os.EOF even if len(p) is zero;\u000aotherwise it is nil.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.ReadByte!\">ReadByte</a></h2>\u000a<code>func (b *Buffer) ReadByte() (c byte, err os.Error)</code>\u000a<p>\u000aReadByte reads and returns the next byte from the buffer.\u000aIf no byte is available, it returns error os.EOF.\u000a</p>\u000a\u000a","name":"ReadByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.ReadFrom!\">ReadFrom</a></h2>\u000a<code>func (b *Buffer) ReadFrom(r io.Reader) (n int64, err os.Error)</code>\u000a<p>\u000aReadFrom reads data from r until EOF and appends it to the buffer.\u000aThe return value n is the number of bytes read.\u000aAny error except os.EOF encountered during the read\u000ais also returned.\u000a</p>\u000a\u000a","name":"ReadFrom"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.ReadRune!\">ReadRune</a></h2>\u000a<code>func (b *Buffer) ReadRune() (r int, size int, err os.Error)</code>\u000a<p>\u000aReadRune reads and returns the next UTF-8-encoded\u000aUnicode code point from the buffer.\u000aIf no bytes are available, the error returned is os.EOF.\u000aIf the bytes are an erroneous UTF-8 encoding, it\u000aconsumes one byte and returns U+FFFD, 1.\u000a</p>\u000a\u000a","name":"ReadRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Reset!\">Reset</a></h2>\u000a<code>func (b *Buffer) Reset()</code>\u000a<p>\u000aReset resets the buffer so it has no content.\u000ab.Reset() is the same as b.Truncate(0).\u000a</p>\u000a\u000a","name":"Reset"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.String!\">String</a></h2>\u000a<code>func (b *Buffer) String() string</code>\u000a<p>\u000aString returns the contents of the unread portion of the buffer\u000aas a string.  If the Buffer is a nil pointer, it returns &#34;&lt;nil&gt;&#34;.\u000a</p>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Truncate!\">Truncate</a></h2>\u000a<code>func (b *Buffer) Truncate(n int)</code>\u000a<p>\u000aTruncate discards all but the first n unread bytes from the buffer.\u000aIt is an error to call b.Truncate(n) with n &gt; b.Len().\u000a</p>\u000a\u000a","name":"Truncate"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.Write!\">Write</a></h2>\u000a<code>func (b *Buffer) Write(p []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite appends the contents of p to the buffer.  The return\u000avalue n is the length of p; err is always nil.\u000a</p>\u000a\u000a","name":"Write"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.WriteByte!\">WriteByte</a></h2>\u000a<code>func (b *Buffer) WriteByte(c byte) os.Error</code>\u000a<p>\u000aWriteByte appends the byte c to the buffer.\u000aThe returned error is always nil, but is included\u000ato match bufio.Writer&#39;s WriteByte.\u000a</p>\u000a\u000a","name":"WriteByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.WriteRune!\">WriteRune</a></h2>\u000a<code>func (b *Buffer) WriteRune(r int) (n int, err os.Error)</code>\u000a<p>\u000aWriteRune appends the UTF-8 encoding of Unicode\u000acode point r to the buffer, returning its length and\u000aan error, which is always nil but is included\u000ato match bufio.Writer&#39;s WriteRune.\u000a</p>\u000a\u000a","name":"WriteRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.WriteString!\">WriteString</a></h2>\u000a<code>func (b *Buffer) WriteString(s string) (n int, err os.Error)</code>\u000a<p>\u000aWriteString appends the contents of s to the buffer.  The return\u000avalue n is the length of s; err is always nil.\u000a</p>\u000a\u000a","name":"WriteString"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Buffer\">func (*Buffer)</a> <a href=\"?m:Buffer.WriteTo!\">WriteTo</a></h2>\u000a<code>func (b *Buffer) WriteTo(w io.Writer) (n int64, err os.Error)</code>\u000a<p>\u000aWriteTo writes data to w until the buffer is drained or an error\u000aoccurs. The return value n is the number of bytes written.\u000aAny error encountered during the write is also returned.\u000a</p>\u000a\u000a","name":"WriteTo"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Add!\">Add</a></h2>\u000a<code>func Add(s, t []byte) []byte</code>\u000a<p>\u000aAdd appends the contents of t to the end of s and returns the result.\u000aIf s has enough capacity, it is extended in place; otherwise a\u000anew array is allocated and returned.\u000a</p>\u000a\u000a","name":"Add"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:AddByte!\">AddByte</a></h2>\u000a<code>func AddByte(s []byte, t byte) []byte</code>\u000a<p>\u000aAddByte appends byte t to the end of s and returns the result.\u000aIf s has enough capacity, it is extended in place; otherwise a\u000anew array is allocated and returned.\u000a</p>\u000a\u000a","name":"AddByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Compare!\">Compare</a></h2>\u000a<code>func Compare(a, b []byte) int</code>\u000a<p>\u000aCompare returns an integer comparing the two byte arrays lexicographically.\u000aThe result will be 0 if a==b, -1 if a &lt; b, and +1 if a &gt; b\u000a</p>\u000a\u000a","name":"Compare"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Count!\">Count</a></h2>\u000a<code>func Count(s, sep []byte) int</code>\u000a<p>\u000aCount counts the number of non-overlapping instances of sep in s.\u000a</p>\u000a\u000a","name":"Count"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Equal!\">Equal</a></h2>\u000a<code>func Equal(a, b []byte) bool</code>\u000a<p>\u000aEqual returns a boolean reporting whether a == b.\u000a</p>\u000a\u000a","name":"Equal"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fields!\">Fields</a></h2>\u000a<code>func Fields(s []byte) [][]byte</code>\u000a<p>\u000aFields splits the array s around each instance of one or more consecutive white space\u000acharacters, returning a slice of subarrays of s or an empty list if s contains only white space.\u000a</p>\u000a\u000a","name":"Fields"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FieldsFunc!\">FieldsFunc</a></h2>\u000a<code>func FieldsFunc(s []byte, f func(int) bool) [][]byte</code>\u000a<p>\u000aFieldsFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\u000aIt splits the array s at each run of code points c satisfying f(c) and\u000areturns a slice of subarrays of s.  If no code points in s satisfy f(c), an\u000aempty slice is returned.\u000a</p>\u000a\u000a","name":"FieldsFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HasPrefix!\">HasPrefix</a></h2>\u000a<code>func HasPrefix(s, prefix []byte) bool</code>\u000a<p>\u000aHasPrefix tests whether the byte array s begins with prefix.\u000a</p>\u000a\u000a","name":"HasPrefix"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HasSuffix!\">HasSuffix</a></h2>\u000a<code>func HasSuffix(s, suffix []byte) bool</code>\u000a<p>\u000aHasSuffix tests whether the byte array s ends with suffix.\u000a</p>\u000a\u000a","name":"HasSuffix"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Index!\">Index</a></h2>\u000a<code>func Index(s, sep []byte) int</code>\u000a<p>\u000aIndex returns the index of the first instance of sep in s, or -1 if sep is not present in s.\u000a</p>\u000a\u000a","name":"Index"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexAny!\">IndexAny</a></h2>\u000a<code>func IndexAny(s []byte, chars string) int</code>\u000a<p>\u000aIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\u000aIt returns the byte index of the first occurrence in s of any of the Unicode\u000acode points in chars.  It returns -1 if chars is empty or if there is no code\u000apoint in common.\u000a</p>\u000a\u000a","name":"IndexAny"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexByte!\">IndexByte</a></h2>\u000a<code>func IndexByte(s []byte, c byte) int</code>\u000a<p>\u000aIndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\u000a</p>\u000a\u000a","name":"IndexByte"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexFunc!\">IndexFunc</a></h2>\u000a<code>func IndexFunc(s []byte, f func(r int) bool) int</code>\u000a<p>\u000aIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\u000aIt returns the byte index in s of the first Unicode\u000acode point satisfying f(c), or -1 if none do.\u000a</p>\u000a\u000a","name":"IndexFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexRune!\">IndexRune</a></h2>\u000a<code>func IndexRune(s []byte, rune int) int</code>\u000a<p>\u000aIndexRune interprets s as a sequence of UTF-8-encoded Unicode code points.\u000aIt returns the byte index of the first occurrence in s of the given rune.\u000aIt returns -1 if rune is not present in s.\u000a</p>\u000a\u000a","name":"IndexRune"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Join!\">Join</a></h2>\u000a<code>func Join(a [][]byte, sep []byte) []byte</code>\u000a<p>\u000aJoin concatenates the elements of a to create a single byte array.   The separator\u000asep is placed between elements in the resulting array.\u000a</p>\u000a\u000a","name":"Join"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LastIndex!\">LastIndex</a></h2>\u000a<code>func LastIndex(s, sep []byte) int</code>\u000a<p>\u000aLastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\u000a</p>\u000a\u000a","name":"LastIndex"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LastIndexFunc!\">LastIndexFunc</a></h2>\u000a<code>func LastIndexFunc(s []byte, f func(r int) bool) int</code>\u000a<p>\u000aLastIndexFunc interprets s as a sequence of UTF-8-encoded Unicode code points.\u000aIt returns the byte index in s of the last Unicode\u000acode point satisfying f(c), or -1 if none do.\u000a</p>\u000a\u000a","name":"LastIndexFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Map!\">Map</a></h2>\u000a<code>func Map(mapping func(rune int) int, s []byte) []byte</code>\u000a<p>\u000aMap returns a copy of the byte array s with all its characters modified\u000aaccording to the mapping function. If mapping returns a negative value, the character is\u000adropped from the string with no replacement.  The characters in s and the\u000aoutput are interpreted as UTF-8-encoded Unicode code points.\u000a</p>\u000a\u000a","name":"Map"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewBuffer!\">NewBuffer</a></h2>\u000a<code>func NewBuffer(buf []byte) *Buffer</code>\u000a<p>\u000aNewBuffer creates and initializes a new Buffer using buf as its initial\u000acontents.  It is intended to prepare a Buffer to read existing data.  It\u000acan also be used to to size the internal buffer for writing.  To do that,\u000abuf should have the desired capacity but a length of zero.\u000a</p>\u000a\u000a","name":"NewBuffer"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewBufferString!\">NewBufferString</a></h2>\u000a<code>func NewBufferString(s string) *Buffer</code>\u000a<p>\u000aNewBufferString creates and initializes a new Buffer using string s as its\u000ainitial contents.  It is intended to prepare a buffer to read an existing\u000astring.\u000a</p>\u000a\u000a","name":"NewBufferString"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Repeat!\">Repeat</a></h2>\u000a<code>func Repeat(b []byte, count int) []byte</code>\u000a<p>\u000aRepeat returns a new byte slice consisting of count copies of b.\u000a</p>\u000a\u000a","name":"Repeat"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Replace!\">Replace</a></h2>\u000a<code>func Replace(s, old, new []byte, n int) []byte</code>\u000a<p>\u000aReplace returns a copy of the slice s with the first n\u000anon-overlapping instances of old replaced by new.\u000aIf n &lt; 0, there is no limit on the number of replacements.\u000a</p>\u000a\u000a","name":"Replace"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Runes!\">Runes</a></h2>\u000a<code>func Runes(s []byte) []int</code>\u000a<p>\u000aRunes returns a slice of runes (Unicode code points) equivalent to s.\u000a</p>\u000a\u000a","name":"Runes"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Split!\">Split</a></h2>\u000a<code>func Split(s, sep []byte, n int) [][]byte</code>\u000a<p>\u000aSplit slices s into subslices separated by sep and returns a slice of\u000athe subslices between those separators.\u000aIf sep is empty, Split splits after each UTF-8 sequence.\u000aThe count determines the number of subslices to return:\u000a</p>\u000a<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.\u000an == 0: the result is nil (zero subslices)\u000an &lt; 0: all subslices\u000a</pre>\u000a\u000a","name":"Split"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SplitAfter!\">SplitAfter</a></h2>\u000a<code>func SplitAfter(s, sep []byte, n int) [][]byte</code>\u000a<p>\u000aSplitAfter slices s into subslices after each instance of sep and\u000areturns a slice of those subslices.\u000aIf sep is empty, Split splits after each UTF-8 sequence.\u000aThe count determines the number of subslices to return:\u000a</p>\u000a<pre>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder.\u000an == 0: the result is nil (zero subslices)\u000an &lt; 0: all subslices\u000a</pre>\u000a\u000a","name":"SplitAfter"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Title!\">Title</a></h2>\u000a<code>func Title(s []byte) []byte</code>\u000a<p>\u000aTitle returns a copy of s with all Unicode letters that begin words\u000amapped to their title case.\u000a</p>\u000a\u000a","name":"Title"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToLower!\">ToLower</a></h2>\u000a<code>func ToLower(s []byte) []byte</code>\u000a<p>\u000aToUpper returns a copy of the byte array s with all Unicode letters mapped to their lower case.\u000a</p>\u000a\u000a","name":"ToLower"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToLowerSpecial!\">ToLowerSpecial</a></h2>\u000a<code>func ToLowerSpecial(_case unicode.SpecialCase, s []byte) []byte</code>\u000a<p>\u000aToLowerSpecial returns a copy of the byte array s with all Unicode letters mapped to their\u000alower case, giving priority to the special casing rules.\u000a</p>\u000a\u000a","name":"ToLowerSpecial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToTitle!\">ToTitle</a></h2>\u000a<code>func ToTitle(s []byte) []byte</code>\u000a<p>\u000aToTitle returns a copy of the byte array s with all Unicode letters mapped to their title case.\u000a</p>\u000a\u000a","name":"ToTitle"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToTitleSpecial!\">ToTitleSpecial</a></h2>\u000a<code>func ToTitleSpecial(_case unicode.SpecialCase, s []byte) []byte</code>\u000a<p>\u000aToTitleSpecial returns a copy of the byte array s with all Unicode letters mapped to their\u000atitle case, giving priority to the special casing rules.\u000a</p>\u000a\u000a","name":"ToTitleSpecial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToUpper!\">ToUpper</a></h2>\u000a<code>func ToUpper(s []byte) []byte</code>\u000a<p>\u000aToUpper returns a copy of the byte array s with all Unicode letters mapped to their upper case.\u000a</p>\u000a\u000a","name":"ToUpper"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToUpperSpecial!\">ToUpperSpecial</a></h2>\u000a<code>func ToUpperSpecial(_case unicode.SpecialCase, s []byte) []byte</code>\u000a<p>\u000aToUpperSpecial returns a copy of the byte array s with all Unicode letters mapped to their\u000aupper case, giving priority to the special casing rules.\u000a</p>\u000a\u000a","name":"ToUpperSpecial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Trim!\">Trim</a></h2>\u000a<code>func Trim(s []byte, cutset string) []byte</code>\u000a<p>\u000aTrim returns a subslice of s by slicing off all leading and\u000atrailing UTF-8-encoded Unicode code points contained in cutset.\u000a</p>\u000a\u000a","name":"Trim"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimFunc!\">TrimFunc</a></h2>\u000a<code>func TrimFunc(s []byte, f func(r int) bool) []byte</code>\u000a<p>\u000aTrimFunc returns a subslice of s by slicing off all leading and trailing\u000aUTF-8-encoded Unicode code points c that satisfy f(c).\u000a</p>\u000a\u000a","name":"TrimFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimLeft!\">TrimLeft</a></h2>\u000a<code>func TrimLeft(s []byte, cutset string) []byte</code>\u000a<p>\u000aTrimLeft returns a subslice of s by slicing off all leading\u000aUTF-8-encoded Unicode code points contained in cutset.\u000a</p>\u000a\u000a","name":"TrimLeft"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimLeftFunc!\">TrimLeftFunc</a></h2>\u000a<code>func TrimLeftFunc(s []byte, f func(r int) bool) []byte</code>\u000a<p>\u000aTrimLeftFunc returns a subslice of s by slicing off all leading UTF-8-encoded\u000aUnicode code points c that satisfy f(c).\u000a</p>\u000a\u000a","name":"TrimLeftFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimRight!\">TrimRight</a></h2>\u000a<code>func TrimRight(s []byte, cutset string) []byte</code>\u000a<p>\u000aTrimRight returns a subslice of s by slicing off all trailing\u000aUTF-8-encoded Unicode code points that are contained in cutset.\u000a</p>\u000a\u000a","name":"TrimRight"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimRightFunc!\">TrimRightFunc</a></h2>\u000a<code>func TrimRightFunc(s []byte, f func(r int) bool) []byte</code>\u000a<p>\u000aTrimRightFunc returns a subslice of s by slicing off all trailing UTF-8\u000aencoded Unicode code points c that satisfy f(c).\u000a</p>\u000a\u000a","name":"TrimRightFunc"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimSpace!\">TrimSpace</a></h2>\u000a<code>func TrimSpace(s []byte) []byte</code>\u000a<p>\u000aTrimSpace returns a subslice of s by slicing off all leading and\u000atrailing white space, as as defined by Unicode.\u000a</p>\u000a\u000a","name":"TrimSpace"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:MinRead!\">MinRead</a></h2>\u000a<pre>const MinRead = 512</pre>\u000a<p>\u000aMinRead is the minimum slice size passed to a Read call by\u000aBuffer.ReadFrom.  As long as the Buffer has at least MinRead bytes beyond\u000awhat is required to hold the contents of r, ReadFrom will not grow the\u000aunderlying buffer.\u000a</p>\u000a\u000a","names":["MinRead"],"type":""}],"vars":[]}