var gowtfData = {"index":"index.html","html":"<p>\u000aThis package partially implements the TLS 1.1 protocol, as specified in RFC 4346.\u000a</p>\u000a","name":"tls","filenames":["/home/nsf/go/src/pkg/crypto/tls/handshake_messages.go","/home/nsf/go/src/pkg/crypto/tls/handshake_server.go","/home/nsf/go/src/pkg/crypto/tls/common.go","/home/nsf/go/src/pkg/crypto/tls/conn.go","/home/nsf/go/src/pkg/crypto/tls/prf.go","/home/nsf/go/src/pkg/crypto/tls/handshake_client.go","/home/nsf/go/src/pkg/crypto/tls/alert.go","/home/nsf/go/src/pkg/crypto/tls/tls.go","/home/nsf/go/src/pkg/crypto/tls/ca_set.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CASet!\">CASet</a></h2>\u000a<pre>type CASet struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA CASet is a set of certificates.\u000a</p>\u000a\u000a","name":"CASet","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:CASet\">func (*CASet)</a> <a href=\"?m:CASet.FindParent!\">FindParent</a></h2>\u000a<code>func (s *CASet) FindParent(cert *x509.Certificate) (parent *x509.Certificate)</code>\u000a<p>\u000aFindParent attempts to find the certificate in s which signs the given\u000acertificate. If no such certificate can be found, it returns nil.\u000a</p>\u000a\u000a","name":"FindParent"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:CASet\">func (*CASet)</a> <a href=\"?m:CASet.SetFromPEM!\">SetFromPEM</a></h2>\u000a<code>func (s *CASet) SetFromPEM(pemCerts []byte) (ok bool)</code>\u000a<p>\u000aSetFromPEM attempts to parse a series of PEM encoded root certificates. It\u000aappends any certificates found to s and returns true if any certificates\u000awere successfully parsed. On many Linux systems, /etc/ssl/cert.pem will\u000acontains the system wide set of root CAs in a format suitable for this\u000afunction.\u000a</p>\u000a\u000a","name":"SetFromPEM"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Certificate!\">Certificate</a></h2>\u000a<pre>type Certificate struct {\u000a\u0009// Certificate contains a chain of one or more certificates. Leaf\u000a\u0009// certificate first.\u000a\u0009Certificate [][]byte\u000a\u0009PrivateKey  *rsa.PrivateKey\u000a}</pre>\u000a\u000a","name":"Certificate","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\u000a<pre>type Config struct {\u000a\u0009// Rand provides the source of entropy for nonces and RSA blinding.\u000a\u0009Rand io.Reader\u000a\u0009// Time returns the current time as the number of seconds since the epoch.\u000a\u0009Time func() int64\u000a\u0009// Certificates contains one or more certificate chains.\u000a\u0009Certificates []Certificate\u000a\u0009RootCAs      *CASet\u000a\u0009// NextProtos is a list of supported, application level protocols.\u000a\u0009// Currently only server-side handling is supported.\u000a\u0009NextProtos []string\u000a\u0009// ServerName is included in the client&#39;s handshake to support virtual\u000a\u0009// hosting.\u000a\u0009ServerName string\u000a\u0009// AuthenticateClient determines if a server will request a certificate\u000a\u0009// from the client. It does not require that the client send a\u000a\u0009// certificate nor, if it does, that the certificate is anything more\u000a\u0009// than self-signed.\u000a\u0009AuthenticateClient bool\u000a}</pre>\u000a<p>\u000aA Config structure is used to configure a TLS client or server. After one\u000ahas been passed to a TLS function it must not be modified.\u000a</p>\u000a\u000a","name":"Config","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\u000a<pre>type Conn struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a<p>\u000aA Conn represents a secured connection.\u000aIt implements the net.Conn interface.\u000a</p>\u000a\u000a","name":"Conn","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Close!\">Close</a></h2>\u000a<code>func (c *Conn) Close() os.Error</code>\u000a<p>\u000aClose closes the connection.\u000a</p>\u000a\u000a","name":"Close"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.ConnectionState!\">ConnectionState</a></h2>\u000a<code>func (c *Conn) ConnectionState() ConnectionState</code>\u000a<p>\u000aConnectionState returns basic TLS details about the connection.\u000a</p>\u000a\u000a","name":"ConnectionState"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Handshake!\">Handshake</a></h2>\u000a<code>func (c *Conn) Handshake() os.Error</code>\u000a<p>\u000aHandshake runs the client or server handshake\u000aprotocol if it has not yet been run.\u000aMost uses of this package need not call Handshake\u000aexplicitly: the first Read or Write will call it automatically.\u000a</p>\u000a\u000a","name":"Handshake"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.LocalAddr!\">LocalAddr</a></h2>\u000a<code>func (c *Conn) LocalAddr() net.Addr</code>\u000a<p>\u000aLocalAddr returns the local network address.\u000a</p>\u000a\u000a","name":"LocalAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.OCSPResponse!\">OCSPResponse</a></h2>\u000a<code>func (c *Conn) OCSPResponse() []byte</code>\u000a<p>\u000aOCSPResponse returns the stapled OCSP response from the TLS server, if\u000aany. (Only valid for client connections.)\u000a</p>\u000a\u000a","name":"OCSPResponse"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.PeerCertificates!\">PeerCertificates</a></h2>\u000a<code>func (c *Conn) PeerCertificates() []*x509.Certificate</code>\u000a<p>\u000aPeerCertificates returns the certificate chain that was presented by the\u000aother side.\u000a</p>\u000a\u000a","name":"PeerCertificates"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Read!\">Read</a></h2>\u000a<code>func (c *Conn) Read(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aRead can be made to time out and return err == os.EAGAIN\u000aafter a fixed time limit; see SetTimeout and SetReadTimeout.\u000a</p>\u000a\u000a","name":"Read"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.RemoteAddr!\">RemoteAddr</a></h2>\u000a<code>func (c *Conn) RemoteAddr() net.Addr</code>\u000a<p>\u000aRemoteAddr returns the remote network address.\u000a</p>\u000a\u000a","name":"RemoteAddr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetReadTimeout!\">SetReadTimeout</a></h2>\u000a<code>func (c *Conn) SetReadTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetReadTimeout sets the time (in nanoseconds) that\u000aRead will wait for data before returning os.EAGAIN.\u000aSetting nsec == 0 (the default) disables the deadline.\u000a</p>\u000a\u000a","name":"SetReadTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetTimeout!\">SetTimeout</a></h2>\u000a<code>func (c *Conn) SetTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetTimeout sets the read deadline associated with the connection.\u000aThere is no write deadline.\u000a</p>\u000a\u000a","name":"SetTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\u000a<code>func (c *Conn) SetWriteTimeout(nsec int64) os.Error</code>\u000a<p>\u000aSetWriteTimeout exists to satisfy the net.Conn interface\u000abut is not implemented by TLS.  It always returns an error.\u000a</p>\u000a\u000a","name":"SetWriteTimeout"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.VerifyHostname!\">VerifyHostname</a></h2>\u000a<code>func (c *Conn) VerifyHostname(host string) os.Error</code>\u000a<p>\u000aVerifyHostname checks that the peer certificate chain is valid for\u000aconnecting to host.  If so, it returns nil; if not, it returns an os.Error\u000adescribing the problem.\u000a</p>\u000a\u000a","name":"VerifyHostname"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Write!\">Write</a></h2>\u000a<code>func (c *Conn) Write(b []byte) (n int, err os.Error)</code>\u000a<p>\u000aWrite writes data to the connection.\u000a</p>\u000a\u000a","name":"Write"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ConnectionState!\">ConnectionState</a></h2>\u000a<pre>type ConnectionState struct {\u000a\u0009HandshakeComplete  bool\u000a\u0009CipherSuite        uint16\u000a\u0009NegotiatedProtocol string\u000a}</pre>\u000a\u000a","name":"ConnectionState","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Listener!\">Listener</a></h2>\u000a<pre>type Listener struct {\u000a\u0009// contains unexported fields\u000a}</pre>\u000a\u000a","name":"Listener","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Accept!\">Accept</a></h2>\u000a<code>func (l *Listener) Accept() (c net.Conn, err os.Error)</code>\u000a\u000a","name":"Accept"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Addr!\">Addr</a></h2>\u000a<code>func (l *Listener) Addr() net.Addr</code>\u000a\u000a","name":"Addr"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Close!\">Close</a></h2>\u000a<code>func (l *Listener) Close() os.Error</code>\u000a\u000a","name":"Close"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Client!\">Client</a></h2>\u000a<code>func Client(conn net.Conn, config *Config) *Conn</code>\u000a\u000a","name":"Client"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\u000a<code>func Dial(network, laddr, raddr string) (net.Conn, os.Error)</code>\u000a\u000a","name":"Dial"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Listen!\">Listen</a></h2>\u000a<code>func Listen(network, laddr string, config *Config) (net.Listener, os.Error)</code>\u000a\u000a","name":"Listen"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LoadX509KeyPair!\">LoadX509KeyPair</a></h2>\u000a<code>func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.Error)</code>\u000a<p>\u000aLoadX509KeyPair reads and parses a public/private key pair from a pair of\u000afiles. The files must contain PEM encoded data.\u000a</p>\u000a\u000a","name":"LoadX509KeyPair"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCASet!\">NewCASet</a></h2>\u000a<code>func NewCASet() *CASet</code>\u000a\u000a","name":"NewCASet"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewListener!\">NewListener</a></h2>\u000a<code>func NewListener(listener net.Listener, config *Config) (l *Listener)</code>\u000a<p>\u000aNewListener creates a Listener which accepts connections from an inner\u000aListener and wraps each connection with Server.\u000aThe configuration config must be non-nil and must have\u000aat least one certificate.\u000a</p>\u000a\u000a","name":"NewListener"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Server!\">Server</a></h2>\u000a<code>func Server(conn net.Conn, config *Config) *Conn</code>\u000a\u000a","name":"Server"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TLS_RSA_WITH_RC4_128_SHA!\">TLS_RSA_WITH_RC4_128_SHA</a></h2>\u000a<pre>const (\u000a\u0009TLS_RSA_WITH_RC4_128_SHA uint16 = 5\u000a)</pre>\u000a<p>\u000aTLS cipher suites.\u000a</p>\u000a\u000a","names":["TLS_RSA_WITH_RC4_128_SHA"],"type":""}],"vars":[]}