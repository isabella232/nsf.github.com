var gowtfData = {"html":"<p>\u000aThis package implements RSA encryption as specified in PKCS#1.\u000a</p>\u000a","name":"rsa","filenames":["/home/nsf/go/src/pkg/crypto/rsa/rsa.go","/home/nsf/go/src/pkg/crypto/rsa/pkcs1v15.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DecryptionError!\">DecryptionError</a></h2>\u000a<pre>type DecryptionError struct{}</pre>\u000a<p>\u000aA DecryptionError represents a failure to decrypt a message.\u000aIt is deliberately vague to avoid adaptive attacks.\u000a</p>\u000a\u000a","name":"DecryptionError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:DecryptionError\">func (DecryptionError)</a> <a href=\"?m:DecryptionError.String!\">String</a></h2>\u000a<code>func (DecryptionError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MessageTooLongError!\">MessageTooLongError</a></h2>\u000a<pre>type MessageTooLongError struct{}</pre>\u000a<p>\u000aMessageTooLongError is returned when attempting to encrypt a message which\u000ais too large for the size of the public key.\u000a</p>\u000a\u000a","name":"MessageTooLongError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:MessageTooLongError\">func (MessageTooLongError)</a> <a href=\"?m:MessageTooLongError.String!\">String</a></h2>\u000a<code>func (MessageTooLongError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PKCS1v15Hash!\">PKCS1v15Hash</a></h2>\u000a<pre>type PKCS1v15Hash int</pre>\u000a<p>\u000aDue to the design of PKCS#1 v1.5, we need to know the exact hash function in\u000ause. A generic hash.Hash will not do.\u000a</p>\u000a\u000a","name":"PKCS1v15Hash","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PrivateKey!\">PrivateKey</a></h2>\u000a<pre>type PrivateKey struct {\u000a\u0009PublicKey          // public part.\u000a\u0009D         *big.Int // private exponent\u000a\u0009P, Q      *big.Int // prime factors of N\u000a}</pre>\u000a<p>\u000aA PrivateKey represents an RSA key\u000a</p>\u000a\u000a","name":"PrivateKey","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:PrivateKey\">func (PrivateKey)</a> <a href=\"?m:PrivateKey.Validate!\">Validate</a></h2>\u000a<code>func (priv PrivateKey) Validate() os.Error</code>\u000a\u000a","name":"Validate"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PublicKey!\">PublicKey</a></h2>\u000a<pre>type PublicKey struct {\u000a\u0009N *big.Int // modulus\u000a\u0009E int      // public exponent\u000a}</pre>\u000a<p>\u000aA PublicKey represents the public part of an RSA key.\u000a</p>\u000a\u000a","name":"PublicKey","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:VerificationError!\">VerificationError</a></h2>\u000a<pre>type VerificationError struct{}</pre>\u000a<p>\u000aA VerificationError represents a failure to verify a signature.\u000aIt is deliberately vague to avoid adaptive attacks.\u000a</p>\u000a\u000a","name":"VerificationError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:VerificationError\">func (VerificationError)</a> <a href=\"?m:VerificationError.String!\">String</a></h2>\u000a<code>func (VerificationError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecryptOAEP!\">DecryptOAEP</a></h2>\u000a<code>func DecryptOAEP(hash hash.Hash, rand io.Reader, priv *PrivateKey, ciphertext []byte, label []byte) (msg []byte, err os.Error)</code>\u000a<p>\u000aDecryptOAEP decrypts ciphertext using RSA-OAEP.\u000aIf rand != nil, DecryptOAEP uses RSA blinding to avoid timing side-channel attacks.\u000a</p>\u000a\u000a","name":"DecryptOAEP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecryptPKCS1v15!\">DecryptPKCS1v15</a></h2>\u000a<code>func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err os.Error)</code>\u000a<p>\u000aDecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\u000aIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\u000a</p>\u000a\u000a","name":"DecryptPKCS1v15"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecryptPKCS1v15SessionKey!\">DecryptPKCS1v15SessionKey</a></h2>\u000a<code>func DecryptPKCS1v15SessionKey(rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte) (err os.Error)</code>\u000a<p>\u000aDecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\u000aIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\u000aIt returns an error if the ciphertext is the wrong length or if the\u000aciphertext is greater than the public modulus. Otherwise, no error is\u000areturned. If the padding is valid, the resulting plaintext message is copied\u000ainto key. Otherwise, key is unchanged. These alternatives occur in constant\u000atime. It is intended that the user of this function generate a random\u000asession key beforehand and continue the protocol with the resulting value.\u000aThis will remove any possibility that an attacker can learn any information\u000aabout the plaintext.\u000aSee &ldquo;Chosen Ciphertext Attacks Against Protocols Based on the RSA\u000aEncryption Standard PKCS #1&rdquo;, Daniel Bleichenbacher, Advances in Cryptology\u000a(Crypto &#39;98),\u000a</p>\u000a\u000a","name":"DecryptPKCS1v15SessionKey"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncryptOAEP!\">EncryptOAEP</a></h2>\u000a<code>func EncryptOAEP(hash hash.Hash, rand io.Reader, pub *PublicKey, msg []byte, label []byte) (out []byte, err os.Error)</code>\u000a<p>\u000aEncryptOAEP encrypts the given message with RSA-OAEP.\u000aThe message must be no longer than the length of the public modulus less\u000atwice the hash length plus 2.\u000a</p>\u000a\u000a","name":"EncryptOAEP"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncryptPKCS1v15!\">EncryptPKCS1v15</a></h2>\u000a<code>func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err os.Error)</code>\u000a<p>\u000aEncryptPKCS1v15 encrypts the given message with RSA and the padding scheme from PKCS#1 v1.5.\u000aThe message must be no longer than the length of the public modulus minus 11 bytes.\u000aWARNING: use of this function to encrypt plaintexts other than session keys\u000ais dangerous. Use RSA OAEP in new protocols.\u000a</p>\u000a\u000a","name":"EncryptPKCS1v15"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GenerateKey!\">GenerateKey</a></h2>\u000a<code>func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error)</code>\u000a<p>\u000aGenerateKeyPair generates an RSA keypair of the given bit size.\u000a</p>\u000a\u000a","name":"GenerateKey"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SignPKCS1v15!\">SignPKCS1v15</a></h2>\u000a<code>func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash PKCS1v15Hash, hashed []byte) (s []byte, err os.Error)</code>\u000a<p>\u000aSignPKCS1v15 calcuates the signature of hashed using RSASSA-PSS-SIGN from RSA PKCS#1 v1.5.\u000aNote that hashed must be the result of hashing the input message using the\u000agiven hash function.\u000a</p>\u000a\u000a","name":"SignPKCS1v15"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:VerifyPKCS1v15!\">VerifyPKCS1v15</a></h2>\u000a<code>func VerifyPKCS1v15(pub *PublicKey, hash PKCS1v15Hash, hashed []byte, sig []byte) (err os.Error)</code>\u000a<p>\u000aVerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\u000ahashed is the result of hashing the input message using the given hash\u000afunction and sig is the signature. A valid signature is indicated by\u000areturning a nil error.\u000a</p>\u000a\u000a","name":"VerifyPKCS1v15"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:PKCS1v15Hash!\">PKCS1v15Hash</a></h2>\u000a<pre>const (\u000a\u0009HashMD5 PKCS1v15Hash = iota\u000a\u0009HashSHA1\u000a\u0009HashSHA256\u000a\u0009HashSHA384\u000a\u0009HashSHA512\u000a\u0009HashMD5SHA1 // combined MD5 and SHA1 hash used for RSA signing in TLS.\u000a)</pre>\u000a\u000a","names":["HashMD5","HashSHA1","HashSHA256","HashSHA384","HashSHA512","HashMD5SHA1"],"type":"PKCS1v15Hash"}],"vars":[]}