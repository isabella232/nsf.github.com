var gowtfData = {"html":"<p>\u000aThe asn1 package implements parsing of DER-encoded ASN.1 data structures,\u000aas defined in ITU-T Rec X.690.\u000a</p>\u000a<p>\u000aSee also &ldquo;A Layman&#39;s Guide to a Subset of ASN.1, BER, and DER,&rdquo;\u000a<a href=\"http://luca.ntop.org/Teaching/Appunti/asn1.html\">http://luca.ntop.org/Teaching/Appunti/asn1.html</a>.\u000a</p>\u000a","name":"asn1","filenames":["/home/nsf/go/src/pkg/asn1/asn1.go","/home/nsf/go/src/pkg/asn1/marshal.go","/home/nsf/go/src/pkg/asn1/common.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BitString!\">BitString</a></h2>\u000a<pre>type BitString struct {\u000a\u0009Bytes     []byte // bits packed into bytes.\u000a\u0009BitLength int    // length in bits.\u000a}</pre>\u000a<p>\u000aBitString is the structure to use when you want an ASN.1 BIT STRING type. A\u000abit string is padded up to the nearest byte in memory and the number of\u000avalid bits is recorded. Padding bits will be zero.\u000a</p>\u000a\u000a","name":"BitString","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:BitString\">func (BitString)</a> <a href=\"?m:BitString.At!\">At</a></h2>\u000a<code>func (b BitString) At(i int) int</code>\u000a<p>\u000aAt returns the bit at the given index. If the index is out of range it\u000areturns false.\u000a</p>\u000a\u000a","name":"At"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:BitString\">func (BitString)</a> <a href=\"?m:BitString.RightAlign!\">RightAlign</a></h2>\u000a<code>func (b BitString) RightAlign() []byte</code>\u000a<p>\u000aRightAlign returns a slice where the padding bits are at the beginning. The\u000aslice may share memory with the BitString.\u000a</p>\u000a\u000a","name":"RightAlign"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Enumerated!\">Enumerated</a></h2>\u000a<pre>type Enumerated int</pre>\u000a<p>\u000aAn Enumerated is represented as a plain int.\u000a</p>\u000a\u000a","name":"Enumerated","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Flag!\">Flag</a></h2>\u000a<pre>type Flag bool</pre>\u000a<p>\u000aA Flag accepts any data and is set to true if present.\u000a</p>\u000a\u000a","name":"Flag","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ObjectIdentifier!\">ObjectIdentifier</a></h2>\u000a<pre>type ObjectIdentifier []int</pre>\u000a<p>\u000aAn ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.\u000a</p>\u000a\u000a","name":"ObjectIdentifier","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ObjectIdentifier\">func (ObjectIdentifier)</a> <a href=\"?m:ObjectIdentifier.Equal!\">Equal</a></h2>\u000a<code>func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool</code>\u000a<p>\u000aEqual returns true iff oi and other represent the same identifier.\u000a</p>\u000a\u000a","name":"Equal"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawContent!\">RawContent</a></h2>\u000a<pre>type RawContent []byte</pre>\u000a<p>\u000aRawContent is used to signal that the undecoded, DER data needs to be\u000apreserved for a struct. To use it, the first field of the struct must have\u000athis type. It&#39;s an error for any of the other fields to have this type.\u000a</p>\u000a\u000a","name":"RawContent","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawValue!\">RawValue</a></h2>\u000a<pre>type RawValue struct {\u000a\u0009Class, Tag int\u000a\u0009IsCompound bool\u000a\u0009Bytes      []byte\u000a\u0009FullBytes  []byte // includes the tag and length\u000a}</pre>\u000a<p>\u000aA RawValue represents an undecoded ASN.1 object.\u000a</p>\u000a\u000a","name":"RawValue","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructuralError!\">StructuralError</a></h2>\u000a<pre>type StructuralError struct {\u000a\u0009Msg string\u000a}</pre>\u000a<p>\u000aA StructuralError suggests that the ASN.1 data is valid, but the Go type\u000awhich is receiving it doesn&#39;t match.\u000a</p>\u000a\u000a","name":"StructuralError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:StructuralError\">func (StructuralError)</a> <a href=\"?m:StructuralError.String!\">String</a></h2>\u000a<code>func (e StructuralError) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SyntaxError!\">SyntaxError</a></h2>\u000a<pre>type SyntaxError struct {\u000a\u0009Msg string\u000a}</pre>\u000a<p>\u000aA SyntaxError suggests that the ASN.1 data is invalid.\u000a</p>\u000a\u000a","name":"SyntaxError","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:SyntaxError\">func (SyntaxError)</a> <a href=\"?m:SyntaxError.String!\">String</a></h2>\u000a<code>func (e SyntaxError) String() string</code>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Marshal!\">Marshal</a></h2>\u000a<code>func Marshal(val interface{}) ([]byte, os.Error)</code>\u000a<p>\u000aMarshal returns the ASN.1 encoding of val.\u000a</p>\u000a\u000a","name":"Marshal"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Unmarshal!\">Unmarshal</a></h2>\u000a<code>func Unmarshal(b []byte, val interface{}) (rest []byte, err os.Error)</code>\u000a<p>\u000aUnmarshal parses the DER-encoded ASN.1 data structure b\u000aand uses the reflect package to fill in an arbitrary value pointed at by val.\u000aBecause Unmarshal uses the reflect package, the structs\u000abeing written to must use upper case field names.\u000a</p>\u000a<p>\u000aAn ASN.1 INTEGER can be written to an int or int64.\u000aIf the encoded value does not fit in the Go type,\u000aUnmarshal returns a parse error.\u000a</p>\u000a<p>\u000aAn ASN.1 BIT STRING can be written to a BitString.\u000a</p>\u000a<p>\u000aAn ASN.1 OCTET STRING can be written to a []byte.\u000a</p>\u000a<p>\u000aAn ASN.1 OBJECT IDENTIFIER can be written to an\u000aObjectIdentifier.\u000a</p>\u000a<p>\u000aAn ASN.1 ENUMERATED can be written to an Enumerated.\u000a</p>\u000a<p>\u000aAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a *time.Time.\u000a</p>\u000a<p>\u000aAn ASN.1 PrintableString or IA5String can be written to a string.\u000a</p>\u000a<p>\u000aAny of the above ASN.1 values can be written to an interface{}.\u000aThe value stored in the interface has the corresponding Go type.\u000aFor integers, that type is int64.\u000a</p>\u000a<p>\u000aAn ASN.1 SEQUENCE OF x or SET OF x can be written\u000ato a slice if an x can be written to the slice&#39;s element type.\u000a</p>\u000a<p>\u000aAn ASN.1 SEQUENCE or SET can be written to a struct\u000aif each of the elements in the sequence can be\u000awritten to the corresponding element in the struct.\u000a</p>\u000a<p>\u000aThe following tags on struct fields have special meaning to Unmarshal:\u000a</p>\u000a<pre>optional\u0009\u0009marks the field as ASN.1 OPTIONAL\u000a[explicit] tag:x\u0009specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\u000adefault:x\u0009\u0009sets the default value for optional integer fields\u000a</pre>\u000a<p>\u000aIf the type of the first field of a structure is RawContent then the raw\u000aASN1 contents of the struct will be stored in it.\u000a</p>\u000a<p>\u000aOther ASN.1 types are not supported; if it encounters them,\u000aUnmarshal returns a parse error.\u000a</p>\u000a\u000a","name":"Unmarshal"}],"consts":[],"vars":[]}