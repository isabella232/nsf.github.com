var gowtfData = {"html":"<p>\u000aA scanner for Go source text. Takes a []byte as source which can\u000athen be tokenized through repeated calls to the Scan function.\u000aFor a sample use of a scanner, see the implementation of Tokenize.\u000a</p>\u000a","name":"scanner","filenames":["/home/nsf/go/src/pkg/go/scanner/scanner.go","/home/nsf/go/src/pkg/go/scanner/errors.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\u000a<pre>type Error struct {\u000a\u0009Pos token.Position\u000a\u0009Msg string\u000a}</pre>\u000a<p>\u000aWithin ErrorVector, an error is represented by an Error node. The\u000aposition Pos, if valid, points to the beginning of the offending\u000atoken, and the error condition is described by Msg.\u000a</p>\u000a\u000a","name":"Error","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Error\">func (*Error)</a> <a href=\"?m:Error.String!\">String</a></h2>\u000a<code>func (e *Error) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ErrorHandler!\">ErrorHandler</a></h2>\u000a<pre>type ErrorHandler interface {\u000a\u0009Error(pos token.Position, msg string)\u000a}</pre>\u000a<p>\u000aAn implementation of an ErrorHandler may be provided to the Scanner.\u000aIf a syntax error is encountered and a handler was installed, Error\u000ais called with a position and an error message. The position points\u000ato the beginning of the offending token.\u000a</p>\u000a\u000a","name":"ErrorHandler","methods":[]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ErrorList!\">ErrorList</a></h2>\u000a<pre>type ErrorList []*Error</pre>\u000a<p>\u000aAn ErrorList is a (possibly sorted) list of Errors.\u000a</p>\u000a\u000a","name":"ErrorList","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorList\">func (ErrorList)</a> <a href=\"?m:ErrorList.Len!\">Len</a></h2>\u000a<code>func (p ErrorList) Len() int</code>\u000a<p>\u000aErrorList implements the sort Interface.\u000a</p>\u000a\u000a","name":"Len"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorList\">func (ErrorList)</a> <a href=\"?m:ErrorList.Less!\">Less</a></h2>\u000a<code>func (p ErrorList) Less(i, j int) bool</code>\u000a\u000a","name":"Less"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorList\">func (ErrorList)</a> <a href=\"?m:ErrorList.String!\">String</a></h2>\u000a<code>func (p ErrorList) String() string</code>\u000a\u000a","name":"String"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorList\">func (ErrorList)</a> <a href=\"?m:ErrorList.Swap!\">Swap</a></h2>\u000a<code>func (p ErrorList) Swap(i, j int)</code>\u000a\u000a","name":"Swap"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ErrorVector!\">ErrorVector</a></h2>\u000a<pre>type ErrorVector struct {\u000a\u0009errors vector.Vector\u000a}</pre>\u000a<p>\u000aErrorVector implements the ErrorHandler interface. It maintains a list\u000aof errors which can be retrieved with GetErrorList and GetError. The\u000azero value for an ErrorVector is an empty ErrorVector ready to use.\u000a</p>\u000a<p>\u000aA common usage pattern is to embed an ErrorVector alongside a\u000ascanner in a data structure that uses the scanner. By passing a\u000areference to an ErrorVector to the scanner&#39;s Init call, default\u000aerror handling is obtained.\u000a</p>\u000a\u000a","name":"ErrorVector","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorVector\">func (*ErrorVector)</a> <a href=\"?m:ErrorVector.Error!\">Error</a></h2>\u000a<code>func (h *ErrorVector) Error(pos token.Position, msg string)</code>\u000a<p>\u000aErrorVector implements the ErrorHandler interface.\u000a</p>\u000a\u000a","name":"Error"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorVector\">func (*ErrorVector)</a> <a href=\"?m:ErrorVector.ErrorCount!\">ErrorCount</a></h2>\u000a<code>func (h *ErrorVector) ErrorCount() int</code>\u000a<p>\u000aErrorCount returns the number of errors collected.\u000a</p>\u000a\u000a","name":"ErrorCount"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorVector\">func (*ErrorVector)</a> <a href=\"?m:ErrorVector.GetError!\">GetError</a></h2>\u000a<code>func (h *ErrorVector) GetError(mode int) os.Error</code>\u000a<p>\u000aGetError is like GetErrorList, but it returns an os.Error instead\u000aso that a nil result can be assigned to an os.Error variable and\u000aremains nil.\u000a</p>\u000a\u000a","name":"GetError"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorVector\">func (*ErrorVector)</a> <a href=\"?m:ErrorVector.GetErrorList!\">GetErrorList</a></h2>\u000a<code>func (h *ErrorVector) GetErrorList(mode int) ErrorList</code>\u000a<p>\u000aGetErrorList returns the list of errors collected by an ErrorVector.\u000aThe construction of the ErrorList returned is controlled by the mode\u000aparameter. If there are no errors, the result is nil.\u000a</p>\u000a\u000a","name":"GetErrorList"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:ErrorVector\">func (*ErrorVector)</a> <a href=\"?m:ErrorVector.Reset!\">Reset</a></h2>\u000a<code>func (h *ErrorVector) Reset()</code>\u000a<p>\u000aReset resets an ErrorVector to no errors.\u000a</p>\u000a\u000a","name":"Reset"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scanner!\">Scanner</a></h2>\u000a<pre>type Scanner struct {\u000a\u0009// immutable state\u000a\u0009src  []byte       // source\u000a\u0009err  ErrorHandler // error reporting; or nil\u000a\u0009mode uint         // scanning mode\u000a\u000a\u000a\u0009// scanning state\u000a\u0009pos        token.Position // previous reading position (position before ch)\u000a\u0009offset     int            // current reading offset (position after ch)\u000a\u0009ch         int            // one char look-ahead\u000a\u0009insertSemi bool           // insert a semicolon before next newline\u000a\u000a\u000a\u0009// public state - ok to modify\u000a\u0009ErrorCount int // number of errors encountered\u000a}</pre>\u000a<p>\u000aA Scanner holds the scanner&#39;s internal state while processing\u000aa given text.  It can be allocated as part of another data\u000astructure but must be initialized via Init before use. For\u000aa sample use, see the implementation of Tokenize.\u000a</p>\u000a\u000a","name":"Scanner","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Init!\">Init</a></h2>\u000a<code>func (S *Scanner) Init(filename string, src []byte, err ErrorHandler, mode uint)</code>\u000a<p>\u000aInit prepares the scanner S to tokenize the text src. Calls to Scan\u000awill use the error handler err if they encounter a syntax error and\u000aerr is not nil. Also, for each error encountered, the Scanner field\u000aErrorCount is incremented by one. The filename parameter is used as\u000afilename in the token.Position returned by Scan for each token. The\u000amode parameter determines how comments and illegal characters are\u000ahandled.\u000a</p>\u000a\u000a","name":"Init"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Scan!\">Scan</a></h2>\u000a<code>func (S *Scanner) Scan() (pos token.Position, tok token.Token, lit []byte)</code>\u000a<p>\u000aScan scans the next token and returns the token position pos,\u000athe token tok, and the literal text lit corresponding to the\u000atoken. The source end is indicated by token.EOF.\u000a</p>\u000a<p>\u000aIf the returned token is token.SEMICOLON, the corresponding\u000aliteral value is &#34;;&#34; if the semicolon was present in the source,\u000aand &#34;\\n&#34; if the semicolon was inserted because of a newline or\u000aat EOF.\u000a</p>\u000a<p>\u000aFor more tolerant parsing, Scan will return a valid token if\u000apossible even if a syntax error was encountered. Thus, even\u000aif the resulting token sequence contains no illegal tokens,\u000aa client may not assume that no error occurred. Instead it\u000amust check the scanner&#39;s ErrorCount or the number of calls\u000aof the error handler, if there was one installed.\u000a</p>\u000a\u000a","name":"Scan"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PrintError!\">PrintError</a></h2>\u000a<code>func PrintError(w io.Writer, err os.Error)</code>\u000a<p>\u000aPrintError is a utility function that prints a list of errors to w,\u000aone error per line, if the err parameter is an ErrorList. Otherwise\u000ait prints the err string.\u000a</p>\u000a\u000a","name":"PrintError"},{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Tokenize!\">Tokenize</a></h2>\u000a<code>func Tokenize(filename string, src []byte, err ErrorHandler, mode uint, f func(pos token.Position, tok token.Token, lit []byte) bool) int</code>\u000a<p>\u000aTokenize calls a function f with the token position, token value, and token\u000atext for each token in the source src. The other parameters have the same\u000ameaning as for the Init function. Tokenize keeps scanning until f returns\u000afalse (usually when the token value is token.EOF). The result is the number\u000aof errors encountered.\u000a</p>\u000a\u000a","name":"Tokenize"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ScanComments!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009ScanComments      = 1 &lt;&lt; iota // return comments as COMMENT tokens\u000a\u0009AllowIllegalChars             // do not report an error for illegal chars\u000a\u0009InsertSemis                   // automatically insert semicolons\u000a)</pre>\u000a<p>\u000aThe mode parameter to the Init function is a set of flags (or 0).\u000aThey control scanner behavior.\u000a</p>\u000a\u000a","names":["ScanComments","AllowIllegalChars","InsertSemis"],"type":""},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Raw!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009Raw         = iota // leave error list unchanged\u000a\u0009Sorted             // sort error list by file, line, and column number\u000a\u0009NoMultiples        // sort error list and leave only the first error per line\u000a)</pre>\u000a<p>\u000aThese constants control the construction of the ErrorList\u000areturned by GetErrors.\u000a</p>\u000a\u000a","names":["Raw","Sorted","NoMultiples"],"type":""}],"vars":[]}