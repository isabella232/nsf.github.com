var gowtfData = {"index":"index.html","html":"<p>\u000aThis package defines constants representing the lexical\u000atokens of the Go programming language and basic operations\u000aon tokens (printing, predicates).\u000a</p>\u000a","name":"token","filenames":["/home/nsf/go/src/pkg/go/token/token.go"],"types":[{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Position!\">Position</a></h2>\u000a<pre>type Position struct {\u000a\u0009Filename string // filename, if any\u000a\u0009Offset   int    // byte offset, starting at 0\u000a\u0009Line     int    // line number, starting at 1\u000a\u0009Column   int    // column number, starting at 1 (character count)\u000a}</pre>\u000a<p>\u000aToken source positions are represented by a Position value.\u000aA Position is valid if the line number is &gt; 0.\u000a</p>\u000a\u000a","name":"Position","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.IsValid!\">IsValid</a></h2>\u000a<code>func (pos *Position) IsValid() bool</code>\u000a<p>\u000aIsValid returns true if the position is valid.\u000a</p>\u000a\u000a","name":"IsValid"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.Pos!\">Pos</a></h2>\u000a<code>func (pos *Position) Pos() Position</code>\u000a<p>\u000aPos is an accessor method for anonymous Position fields.\u000aIt returns its receiver.\u000a</p>\u000a\u000a","name":"Pos"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Position\">func (Position)</a> <a href=\"?m:Position.String!\">String</a></h2>\u000a<code>func (pos Position) String() string</code>\u000a\u000a","name":"String"}]},{"html":"\u000a<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Token!\">Token</a></h2>\u000a<pre>type Token int</pre>\u000a<p>\u000aToken is the set of lexical tokens of the Go programming language.\u000a</p>\u000a\u000a","name":"Token","methods":[{"html":"\u000a<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsKeyword!\">IsKeyword</a></h2>\u000a<code>func (tok Token) IsKeyword() bool</code>\u000a<p>\u000aIsKeyword returns true for tokens corresponding to keywords;\u000areturns false otherwise.\u000a</p>\u000a\u000a","name":"IsKeyword"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsLiteral!\">IsLiteral</a></h2>\u000a<code>func (tok Token) IsLiteral() bool</code>\u000a<p>\u000aIsLiteral returns true for tokens corresponding to identifiers\u000aand basic type literals; returns false otherwise.\u000a</p>\u000a\u000a","name":"IsLiteral"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsOperator!\">IsOperator</a></h2>\u000a<code>func (tok Token) IsOperator() bool</code>\u000a<p>\u000aIsOperator returns true for tokens corresponding to operators and\u000adelimiters; returns false otherwise.\u000a</p>\u000a\u000a","name":"IsOperator"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.Precedence!\">Precedence</a></h2>\u000a<code>func (op Token) Precedence() int</code>\u000a<p>\u000aPrecedence returns the operator precedence of the binary\u000aoperator op. If op is not a binary operator, the result\u000ais LowestPrecedence.\u000a</p>\u000a\u000a","name":"Precedence"},{"html":"\u000a<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.String!\">String</a></h2>\u000a<code>func (tok Token) String() string</code>\u000a<p>\u000aString returns the string corresponding to the token tok.\u000aFor operators, delimiters, and keywords the string is the actual\u000atoken character sequence (e.g., for the token ADD, the string is\u000a&#34;+&#34;). For all other tokens the string corresponds to the token\u000aconstant name (e.g. for the token IDENT, the string is &#34;IDENT&#34;).\u000a</p>\u000a\u000a","name":"String"}]}],"funcs":[{"html":"\u000a<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lookup!\">Lookup</a></h2>\u000a<code>func Lookup(ident []byte) Token</code>\u000a<p>\u000aLookup maps an identifier to its keyword token or IDENT (if not a keyword).\u000a</p>\u000a\u000a","name":"Lookup"}],"consts":[{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Token!\">Token</a></h2>\u000a<pre>const (\u000a\u0009// Special tokens\u000a\u0009ILLEGAL Token = iota\u000a\u0009EOF\u000a\u0009COMMENT\u000a\u000a\u0009literal_beg\u000a\u0009// Identifiers and basic type literals\u000a\u0009// (these tokens stand for classes of literals)\u000a\u0009IDENT  // main\u000a\u0009INT    // 12345\u000a\u0009FLOAT  // 123.45\u000a\u0009IMAG   // 123.45i\u000a\u0009CHAR   // &#39;a&#39;\u000a\u0009STRING // &#34;abc&#34;\u000a\u0009literal_end\u000a\u000a\u0009operator_beg\u000a\u0009// Operators and delimiters\u000a\u0009ADD // +\u000a\u0009SUB // -\u000a\u0009MUL // *\u000a\u0009QUO // /\u000a\u0009REM // %\u000a\u000a\u0009AND     // &amp;\u000a\u0009OR      // |\u000a\u0009XOR     // ^\u000a\u0009SHL     // &lt;&lt;\u000a\u0009SHR     // &gt;&gt;\u000a\u0009AND_NOT // &amp;^\u000a\u000a\u0009ADD_ASSIGN // +=\u000a\u0009SUB_ASSIGN // -=\u000a\u0009MUL_ASSIGN // *=\u000a\u0009QUO_ASSIGN // /=\u000a\u0009REM_ASSIGN // %=\u000a\u000a\u0009AND_ASSIGN     // &amp;=\u000a\u0009OR_ASSIGN      // |=\u000a\u0009XOR_ASSIGN     // ^=\u000a\u0009SHL_ASSIGN     // &lt;&lt;=\u000a\u0009SHR_ASSIGN     // &gt;&gt;=\u000a\u0009AND_NOT_ASSIGN // &amp;^=\u000a\u000a\u0009LAND  // &amp;&amp;\u000a\u0009LOR   // ||\u000a\u0009ARROW // &lt;-\u000a\u0009INC   // ++\u000a\u0009DEC   // --\u000a\u000a\u0009EQL    // ==\u000a\u0009LSS    // &lt;\u000a\u0009GTR    // &gt;\u000a\u0009ASSIGN // =\u000a\u0009NOT    // !\u000a\u000a\u0009NEQ      // !=\u000a\u0009LEQ      // &lt;=\u000a\u0009GEQ      // &gt;=\u000a\u0009DEFINE   // :=\u000a\u0009ELLIPSIS // ...\u000a\u000a\u0009LPAREN // (\u000a\u0009LBRACK // [\u000a\u0009LBRACE // {\u000a\u0009COMMA  // ,\u000a\u0009PERIOD // .\u000a\u000a\u0009RPAREN    // )\u000a\u0009RBRACK    // ]\u000a\u0009RBRACE    // }\u000a\u0009SEMICOLON // ;\u000a\u0009COLON     // :\u000a\u0009operator_end\u000a\u000a\u0009keyword_beg\u000a\u0009// Keywords\u000a\u0009BREAK\u000a\u0009CASE\u000a\u0009CHAN\u000a\u0009CONST\u000a\u0009CONTINUE\u000a\u000a\u0009DEFAULT\u000a\u0009DEFER\u000a\u0009ELSE\u000a\u0009FALLTHROUGH\u000a\u0009FOR\u000a\u000a\u0009FUNC\u000a\u0009GO\u000a\u0009GOTO\u000a\u0009IF\u000a\u0009IMPORT\u000a\u000a\u0009INTERFACE\u000a\u0009MAP\u000a\u0009PACKAGE\u000a\u0009RANGE\u000a\u0009RETURN\u000a\u000a\u0009SELECT\u000a\u0009STRUCT\u000a\u0009SWITCH\u000a\u0009TYPE\u000a\u0009VAR\u000a\u0009keyword_end\u000a)</pre>\u000a<p>\u000aThe list of tokens.\u000a</p>\u000a\u000a","names":["ILLEGAL","EOF","COMMENT","IDENT","INT","FLOAT","IMAG","CHAR","STRING","ADD","SUB","MUL","QUO","REM","AND","OR","XOR","SHL","SHR","AND_NOT","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","QUO_ASSIGN","REM_ASSIGN","AND_ASSIGN","OR_ASSIGN","XOR_ASSIGN","SHL_ASSIGN","SHR_ASSIGN","AND_NOT_ASSIGN","LAND","LOR","ARROW","INC","DEC","EQL","LSS","GTR","ASSIGN","NOT","NEQ","LEQ","GEQ","DEFINE","ELLIPSIS","LPAREN","LBRACK","LBRACE","COMMA","PERIOD","RPAREN","RBRACK","RBRACE","SEMICOLON","COLON","BREAK","CASE","CHAN","CONST","CONTINUE","DEFAULT","DEFER","ELSE","FALLTHROUGH","FOR","FUNC","GO","GOTO","IF","IMPORT","INTERFACE","MAP","PACKAGE","RANGE","RETURN","SELECT","STRUCT","SWITCH","TYPE","VAR"],"type":"Token"},{"html":"\u000a<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:LowestPrec!\"><em>group</em></a></h2>\u000a<pre>const (\u000a\u0009LowestPrec  = 0 // non-operators\u000a\u0009UnaryPrec   = 7\u000a\u0009HighestPrec = 8\u000a)</pre>\u000a<p>\u000aA set of constants for precedence-based expression parsing.\u000aNon-operators have lowest precedence, followed by operators\u000astarting with precedence 1 up to unary operators. The highest\u000aprecedence corresponds serves as &#34;catch-all&#34; precedence for\u000aselector, indexing, and other operator and delimiter tokens.\u000a</p>\u000a\u000a","names":["LowestPrec","UnaryPrec","HighestPrec"],"type":""}],"vars":[]}