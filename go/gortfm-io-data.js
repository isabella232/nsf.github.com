var gortfmData = {index:"index.html",html:"<p>\nThis package provides basic interfaces to I/O primitives.\nIts primary job is to wrap existing implementations of such primitives,\nsuch as those in package os, into shared public interfaces that\nabstract the functionality, plus some other related primitives.\n</p>\n",name:"io",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Closer!\">Closer</a></h2>\n<pre>type Closer interface {\n\tClose() os.Error\n}</pre>\n<p>\nCloser is the interface that wraps the basic Close method.\n</p>\n\n",name:"Closer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\n<pre>type Error struct {\n\tos.ErrorString\n}</pre>\n<p>\nError represents an unexpected I/O behavior.\n</p>\n\n",name:"Error","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PipeReader!\">PipeReader</a></h2>\n<pre>type PipeReader struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA PipeReader is the read half of a pipe.\n</p>\n\n",name:"PipeReader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.Close!\">Close</a></h2>\n<code>func (r *PipeReader) Close() os.Error</code>\n<p>\nClose closes the reader; subsequent writes to the\nwrite half of the pipe will return the error os.EPIPE.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.CloseWithError!\">CloseWithError</a></h2>\n<code>func (r *PipeReader) CloseWithError(err os.Error) os.Error</code>\n<p>\nCloseWithError closes the reader; subsequent writes\nto the write half of the pipe will return the error err.\n</p>\n\n",name:"CloseWithError"},{html:"\n<h2><a class=\"black\" href=\"?m:PipeReader\">func (*PipeReader)</a> <a href=\"?m:PipeReader.Read!\">Read</a></h2>\n<code>func (r *PipeReader) Read(data []byte) (n int, err os.Error)</code>\n<p>\nRead implements the standard Read interface:\nit reads data from the pipe, blocking until a writer\narrives or the write end is closed.\nIf the write end is closed with an error, that error is\nreturned as err; otherwise err is nil.\n</p>\n\n",name:"Read"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PipeWriter!\">PipeWriter</a></h2>\n<pre>type PipeWriter struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA PipeWriter is the write half of a pipe.\n</p>\n\n",name:"PipeWriter","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.Close!\">Close</a></h2>\n<code>func (w *PipeWriter) Close() os.Error</code>\n<p>\nClose closes the writer; subsequent reads from the\nread half of the pipe will return no bytes and os.EOF.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.CloseWithError!\">CloseWithError</a></h2>\n<code>func (w *PipeWriter) CloseWithError(err os.Error) os.Error</code>\n<p>\nCloseWithError closes the writer; subsequent reads from the\nread half of the pipe will return no bytes and the error err.\n</p>\n\n",name:"CloseWithError"},{html:"\n<h2><a class=\"black\" href=\"?m:PipeWriter\">func (*PipeWriter)</a> <a href=\"?m:PipeWriter.Write!\">Write</a></h2>\n<code>func (w *PipeWriter) Write(data []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the standard Write interface:\nit writes data to the pipe, blocking until readers\nhave consumed all the data or the read end is closed.\nIf the read end is closed with an error, that err is\nreturned as err; otherwise err is os.EPIPE.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadByter!\">ReadByter</a></h2>\n<pre>type ReadByter interface {\n\tReadByte() (c byte, err os.Error)\n}</pre>\n<p>\nReadByter is the interface that wraps the ReadByte method.\n</p>\n<p>\nReadByte reads and returns the next byte from the input.\nIf no byte is available, err will be set.\n</p>\n\n",name:"ReadByter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadCloser!\">ReadCloser</a></h2>\n<pre>type ReadCloser interface {\n\tReader\n\tCloser\n}</pre>\n<p>\nReadCloser is the interface that groups the basic Read and Close methods.\n</p>\n\n",name:"ReadCloser","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadSeeker!\">ReadSeeker</a></h2>\n<pre>type ReadSeeker interface {\n\tReader\n\tSeeker\n}</pre>\n<p>\nReadSeeker is the interface that groups the basic Read and Seek methods.\n</p>\n\n",name:"ReadSeeker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriteCloser!\">ReadWriteCloser</a></h2>\n<pre>type ReadWriteCloser interface {\n\tReader\n\tWriter\n\tCloser\n}</pre>\n<p>\nReadWriteCloser is the interface that groups the basic Read, Write and Close methods.\n</p>\n\n",name:"ReadWriteCloser","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriteSeeker!\">ReadWriteSeeker</a></h2>\n<pre>type ReadWriteSeeker interface {\n\tReader\n\tWriter\n\tSeeker\n}</pre>\n<p>\nReadWriteSeeker is the interface that groups the basic Read, Write and Seek methods.\n</p>\n\n",name:"ReadWriteSeeker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadWriter!\">ReadWriter</a></h2>\n<pre>type ReadWriter interface {\n\tReader\n\tWriter\n}</pre>\n<p>\nReadWriter is the interface that groups the basic Read and Write methods.\n</p>\n\n",name:"ReadWriter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader interface {\n\tRead(p []byte) (n int, err os.Error)\n}</pre>\n<p>\nReader is the interface that wraps the basic Read method.\n</p>\n<p>\nRead reads up to len(p) bytes into p.  It returns the number of bytes\nread (0 &lt;= n &lt;= len(p)) and any error encountered.\nEven if Read returns n &lt; len(p),\nit may use all of p as scratch space during the call.\nIf some data is available but not len(p) bytes, Read conventionally\nreturns what is available rather than block waiting for more.\n</p>\n<p>\nAt the end of the input stream, Read returns 0, os.EOF.\nRead may return a non-zero number of bytes with a non-nil err.\nIn particular, a Read that exhausts the input may return n &gt; 0, os.EOF.\n</p>\n\n",name:"Reader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReaderAt!\">ReaderAt</a></h2>\n<pre>type ReaderAt interface {\n\tReadAt(p []byte, off int64) (n int, err os.Error)\n}</pre>\n<p>\nReaderAt is the interface that wraps the basic ReadAt method.\n</p>\n<p>\nReadAt reads len(p) bytes into p starting at offset off in the\nunderlying data stream.  It returns the number of bytes\nread (0 &lt;= n &lt;= len(p)) and any error encountered.\n</p>\n<p>\nEven if ReadAt returns n &lt; len(p),\nit may use all of p as scratch space during the call.\nIf some data is available but not len(p) bytes, ReadAt blocks\nuntil either all the data is available or an error occurs.\n</p>\n<p>\nAt the end of the input stream, ReadAt returns 0, os.EOF.\nReadAt may return a non-zero number of bytes with a non-nil err.\nIn particular, a ReadAt that exhausts the input may return n &gt; 0, os.EOF.\n</p>\n\n",name:"ReaderAt","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReaderFrom!\">ReaderFrom</a></h2>\n<pre>type ReaderFrom interface {\n\tReadFrom(r Reader) (n int64, err os.Error)\n}</pre>\n<p>\nReaderFrom is the interface that wraps the ReadFrom method.\n</p>\n\n",name:"ReaderFrom","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SectionReader!\">SectionReader</a></h2>\n<pre>type SectionReader struct {\n\t// contains unexported fields\n}</pre>\n<p>\nSectionReader implements Read, Seek, and ReadAt on a section\nof an underlying ReaderAt.\n</p>\n\n",name:"SectionReader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Read!\">Read</a></h2>\n<code>func (s *SectionReader) Read(p []byte) (n int, err os.Error)</code>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.ReadAt!\">ReadAt</a></h2>\n<code>func (s *SectionReader) ReadAt(p []byte, off int64) (n int, err os.Error)</code>\n\n",name:"ReadAt"},{html:"\n<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Seek!\">Seek</a></h2>\n<code>func (s *SectionReader) Seek(offset int64, whence int) (ret int64, err os.Error)</code>\n\n",name:"Seek"},{html:"\n<h2><a class=\"black\" href=\"?m:SectionReader\">func (*SectionReader)</a> <a href=\"?m:SectionReader.Size!\">Size</a></h2>\n<code>func (s *SectionReader) Size() int64</code>\n<p>\nSize returns the size of the section in bytes.\n</p>\n\n",name:"Size"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Seeker!\">Seeker</a></h2>\n<pre>type Seeker interface {\n\tSeek(offset int64, whence int) (ret int64, err os.Error)\n}</pre>\n<p>\nSeeker is the interface that wraps the basic Seek method.\n</p>\n<p>\nSeek sets the offset for the next Read or Write to offset,\ninterpreted according to whence: 0 means relative to the origin of\nthe file, 1 means relative to the current offset, and 2 means\nrelative to the end.  Seek returns the new offset and an Error, if\nany.\n</p>\n\n",name:"Seeker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteCloser!\">WriteCloser</a></h2>\n<pre>type WriteCloser interface {\n\tWriter\n\tCloser\n}</pre>\n<p>\nWriteCloser is the interface that groups the basic Write and Close methods.\n</p>\n\n",name:"WriteCloser","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteSeeker!\">WriteSeeker</a></h2>\n<pre>type WriteSeeker interface {\n\tWriter\n\tSeeker\n}</pre>\n<p>\nWriteSeeker is the interface that groups the basic Write and Seek methods.\n</p>\n\n",name:"WriteSeeker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\n<pre>type Writer interface {\n\tWrite(p []byte) (n int, err os.Error)\n}</pre>\n<p>\nWriter is the interface that wraps the basic Write method.\n</p>\n<p>\nWrite writes len(p) bytes from p to the underlying data stream.\nIt returns the number of bytes written from p (0 &lt;= n &lt;= len(p))\nand any error encountered that caused the write to stop early.\nWrite must return a non-nil error if it returns n &lt; len(p).\n</p>\n\n",name:"Writer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriterAt!\">WriterAt</a></h2>\n<pre>type WriterAt interface {\n\tWriteAt(p []byte, off int64) (n int, err os.Error)\n}</pre>\n<p>\nWriterAt is the interface that wraps the basic WriteAt method.\n</p>\n<p>\nWriteAt writes len(p) bytes from p to the underlying data stream\nat offset off.  It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))\nand any error encountered that caused the write to stop early.\nWriteAt must return a non-nil error if it returns n &lt; len(p).\n</p>\n\n",name:"WriterAt","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriterTo!\">WriterTo</a></h2>\n<pre>type WriterTo interface {\n\tWriteTo(w Writer) (n int64, err os.Error)\n}</pre>\n<p>\nWriterTo is the interface that wraps the WriteTo method.\n</p>\n\n",name:"WriterTo","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Copy!\">Copy</a></h2>\n<code>func Copy(dst Writer, src Reader) (written int64, err os.Error)</code>\n<p>\nCopy copies from src to dst until either EOF is reached\non src or an error occurs.  It returns the number of bytes\ncopied and the error, if any.\n</p>\n<p>\nIf dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\nOtherwise, if src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\n</p>\n\n",name:"Copy"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Copyn!\">Copyn</a></h2>\n<code>func Copyn(dst Writer, src Reader, n int64) (written int64, err os.Error)</code>\n<p>\nCopyn copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the error, if any.\n</p>\n<p>\nIf dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n</p>\n\n",name:"Copyn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LimitReader!\">LimitReader</a></h2>\n<code>func LimitReader(r Reader, n int64) Reader</code>\n<p>\nLimitReader returns a Reader that reads from r\nbut stops with os.EOF after n bytes.\n</p>\n\n",name:"LimitReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MultiReader!\">MultiReader</a></h2>\n<code>func MultiReader(readers ...Reader) Reader</code>\n<p>\nMultiReader returns a Reader that&#39;s the logical concatenation of\nthe provided input readers.  They&#39;re read sequentially.  Once all\ninputs are drained, Read will return os.EOF.\n</p>\n\n",name:"MultiReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MultiWriter!\">MultiWriter</a></h2>\n<code>func MultiWriter(writers ...Writer) Writer</code>\n<p>\nMultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n</p>\n\n",name:"MultiWriter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewSectionReader!\">NewSectionReader</a></h2>\n<code>func NewSectionReader(r ReaderAt, off int64, n int64) *SectionReader</code>\n<p>\nNewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with os.EOF after n bytes.\n</p>\n\n",name:"NewSectionReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pipe!\">Pipe</a></h2>\n<code>func Pipe() (*PipeReader, *PipeWriter)</code>\n<p>\nPipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal buffering.\n</p>\n\n",name:"Pipe"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadAtLeast!\">ReadAtLeast</a></h2>\n<code>func ReadAtLeast(r Reader, buf []byte, min int) (n int, err os.Error)</code>\n<p>\nReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is os.EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\n</p>\n\n",name:"ReadAtLeast"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadFull!\">ReadFull</a></h2>\n<code>func ReadFull(r Reader, buf []byte) (n int, err os.Error)</code>\n<p>\nReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is os.EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\n</p>\n\n",name:"ReadFull"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:WriteString!\">WriteString</a></h2>\n<code>func WriteString(w Writer, s string) (n int, err os.Error)</code>\n<p>\nWriteString writes the contents of the string s to w, which accepts an array of bytes.\n</p>\n\n",name:"WriteString"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrShortWrite!\">ErrShortWrite</a></h2>\n<pre>var ErrShortWrite os.Error = &amp;Error{&#34;short write&#34;}</pre>\n<p>\nErrShortWrite means that a write accepted fewer bytes than requested\nbut failed to return an explicit error.\n</p>\n\n",names:["ErrShortWrite"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrShortBuffer!\">ErrShortBuffer</a></h2>\n<pre>var ErrShortBuffer os.Error = &amp;Error{&#34;short buffer&#34;}</pre>\n<p>\nErrShortBuffer means that a read required a longer buffer than was provided.\n</p>\n\n",names:["ErrShortBuffer"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrUnexpectedEOF!\">ErrUnexpectedEOF</a></h2>\n<pre>var ErrUnexpectedEOF os.Error = &amp;Error{&#34;unexpected EOF&#34;}</pre>\n<p>\nErrUnexpectedEOF means that os.EOF was encountered in the\nmiddle of reading a fixed-size block or data structure.\n</p>\n\n",names:["ErrUnexpectedEOF"],type:""}]}