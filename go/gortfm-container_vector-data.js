var gortfmData = {index:"index.html",html:"<p>\nPackage vector implements containers for managing sequences of elements.\nVectors grow and shrink dynamically as necessary.\n</p>\n",name:"vector",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntVector!\">IntVector</a></h2>\n<pre>type IntVector []int</pre>\n<p>\nIntVector is a container for numbered sequences of elements of type int.\nA vector&#39;s length and capacity adjusts automatically as necessary.\nThe zero value for IntVector is an empty vector ready to use.\n</p>\n\n",name:"IntVector","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.AppendVector!\">AppendVector</a></h2>\n<code>func (p *IntVector) AppendVector(x *IntVector)</code>\n<p>\nAppendVector appends the entire vector x to the end of this vector.\n</p>\n\n",name:"AppendVector"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.At!\">At</a></h2>\n<code>func (p *IntVector) At(i int) int</code>\n<p>\nAt returns the i&#39;th element of the vector.\n</p>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Cap!\">Cap</a></h2>\n<code>func (p *IntVector) Cap() int</code>\n<p>\nCap returns the capacity of the vector; that is, the\nmaximum length the vector can grow without resizing.\nSame as cap(*p).\n</p>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Copy!\">Copy</a></h2>\n<code>func (p *IntVector) Copy() IntVector</code>\n<p>\nCopy makes a copy of the vector and returns it.\n</p>\n\n",name:"Copy"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Cut!\">Cut</a></h2>\n<code>func (p *IntVector) Cut(i, j int)</code>\n<p>\nCut deletes elements i through j-1, inclusive.\n</p>\n\n",name:"Cut"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Delete!\">Delete</a></h2>\n<code>func (p *IntVector) Delete(i int)</code>\n<p>\nDelete deletes the i&#39;th element of the vector.  The gap is closed so the old\nelement at index i+1 has index i afterwards.\n</p>\n\n",name:"Delete"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Do!\">Do</a></h2>\n<code>func (p *IntVector) Do(f func(elem int))</code>\n<p>\nDo calls function f for each element of the vector, in order.\nThe behavior of Do is undefined if f changes *p.\n</p>\n\n",name:"Do"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Expand!\">Expand</a></h2>\n<code>func (p *IntVector) Expand(i, n int)</code>\n<p>\nInsert n elements at position i.\n</p>\n\n",name:"Expand"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Extend!\">Extend</a></h2>\n<code>func (p *IntVector) Extend(n int)</code>\n<p>\nInsert n elements at the end of a vector.\n</p>\n\n",name:"Extend"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Insert!\">Insert</a></h2>\n<code>func (p *IntVector) Insert(i int, x int)</code>\n<p>\nInsert inserts into the vector an element of value x before\nthe current element at index i.\n</p>\n\n",name:"Insert"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.InsertVector!\">InsertVector</a></h2>\n<code>func (p *IntVector) InsertVector(i int, x *IntVector)</code>\n<p>\nInsertVector inserts into the vector the contents of the vector\nx such that the 0th element of x appears at index i after insertion.\n</p>\n\n",name:"InsertVector"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Last!\">Last</a></h2>\n<code>func (p *IntVector) Last() int</code>\n<p>\nLast returns the element in the vector of highest index.\n</p>\n\n",name:"Last"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Len!\">Len</a></h2>\n<code>func (p *IntVector) Len() int</code>\n<p>\nLen returns the number of elements in the vector.\nSame as len(*p).\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Less!\">Less</a></h2>\n<code>func (p *IntVector) Less(i, j int) bool</code>\n<p>\nLess returns a boolean denoting whether the i&#39;th element is less than the j&#39;th element.\n</p>\n\n",name:"Less"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Pop!\">Pop</a></h2>\n<code>func (p *IntVector) Pop() int</code>\n<p>\nPop deletes the last element of the vector.\n</p>\n\n",name:"Pop"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Push!\">Push</a></h2>\n<code>func (p *IntVector) Push(x int)</code>\n<p>\nPush appends x to the end of the vector.\n</p>\n\n",name:"Push"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Resize!\">Resize</a></h2>\n<code>func (p *IntVector) Resize(length, capacity int) *IntVector</code>\n<p>\nResize changes the length and capacity of a vector.\nIf the new length is shorter than the current length, Resize discards\ntrailing elements. If the new length is longer than the current length,\nResize adds the respective zero values for the additional elements. The capacity\nparameter is ignored unless the new length or capacity is longer than the current\ncapacity. The resized vector&#39;s capacity may be larger than the requested capacity.\n</p>\n\n",name:"Resize"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Set!\">Set</a></h2>\n<code>func (p *IntVector) Set(i int, x int)</code>\n<p>\nSet sets the i&#39;th element of the vector to value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Slice!\">Slice</a></h2>\n<code>func (p *IntVector) Slice(i, j int) *IntVector</code>\n<p>\nSlice returns a new sub-vector by slicing the old one to extract slice [i:j].\nThe elements are copied. The original vector is unchanged.\n</p>\n\n",name:"Slice"},{html:"\n<h2><a class=\"black\" href=\"?m:IntVector\">func (*IntVector)</a> <a href=\"?m:IntVector.Swap!\">Swap</a></h2>\n<code>func (p *IntVector) Swap(i, j int)</code>\n<p>\nSwap exchanges the elements at indexes i and j.\n</p>\n\n",name:"Swap"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LessInterface!\">LessInterface</a></h2>\n<pre>type LessInterface interface {\n\tLess(y interface{}) bool\n}</pre>\n<p>\nLessInterface provides partial support of the sort.Interface.\n</p>\n\n",name:"LessInterface","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringVector!\">StringVector</a></h2>\n<pre>type StringVector []string</pre>\n<p>\nStringVector is a container for numbered sequences of elements of type string.\nA vector&#39;s length and capacity adjusts automatically as necessary.\nThe zero value for StringVector is an empty vector ready to use.\n</p>\n\n",name:"StringVector","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.AppendVector!\">AppendVector</a></h2>\n<code>func (p *StringVector) AppendVector(x *StringVector)</code>\n<p>\nAppendVector appends the entire vector x to the end of this vector.\n</p>\n\n",name:"AppendVector"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.At!\">At</a></h2>\n<code>func (p *StringVector) At(i int) string</code>\n<p>\nAt returns the i&#39;th element of the vector.\n</p>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Cap!\">Cap</a></h2>\n<code>func (p *StringVector) Cap() int</code>\n<p>\nCap returns the capacity of the vector; that is, the\nmaximum length the vector can grow without resizing.\nSame as cap(*p).\n</p>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Copy!\">Copy</a></h2>\n<code>func (p *StringVector) Copy() StringVector</code>\n<p>\nCopy makes a copy of the vector and returns it.\n</p>\n\n",name:"Copy"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Cut!\">Cut</a></h2>\n<code>func (p *StringVector) Cut(i, j int)</code>\n<p>\nCut deletes elements i through j-1, inclusive.\n</p>\n\n",name:"Cut"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Delete!\">Delete</a></h2>\n<code>func (p *StringVector) Delete(i int)</code>\n<p>\nDelete deletes the i&#39;th element of the vector.  The gap is closed so the old\nelement at index i+1 has index i afterwards.\n</p>\n\n",name:"Delete"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Do!\">Do</a></h2>\n<code>func (p *StringVector) Do(f func(elem string))</code>\n<p>\nDo calls function f for each element of the vector, in order.\nThe behavior of Do is undefined if f changes *p.\n</p>\n\n",name:"Do"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Expand!\">Expand</a></h2>\n<code>func (p *StringVector) Expand(i, n int)</code>\n<p>\nInsert n elements at position i.\n</p>\n\n",name:"Expand"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Extend!\">Extend</a></h2>\n<code>func (p *StringVector) Extend(n int)</code>\n<p>\nInsert n elements at the end of a vector.\n</p>\n\n",name:"Extend"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Insert!\">Insert</a></h2>\n<code>func (p *StringVector) Insert(i int, x string)</code>\n<p>\nInsert inserts into the vector an element of value x before\nthe current element at index i.\n</p>\n\n",name:"Insert"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.InsertVector!\">InsertVector</a></h2>\n<code>func (p *StringVector) InsertVector(i int, x *StringVector)</code>\n<p>\nInsertVector inserts into the vector the contents of the vector\nx such that the 0th element of x appears at index i after insertion.\n</p>\n\n",name:"InsertVector"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Last!\">Last</a></h2>\n<code>func (p *StringVector) Last() string</code>\n<p>\nLast returns the element in the vector of highest index.\n</p>\n\n",name:"Last"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Len!\">Len</a></h2>\n<code>func (p *StringVector) Len() int</code>\n<p>\nLen returns the number of elements in the vector.\nSame as len(*p).\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Less!\">Less</a></h2>\n<code>func (p *StringVector) Less(i, j int) bool</code>\n<p>\nLess returns a boolean denoting whether the i&#39;th element is less than the j&#39;th element.\n</p>\n\n",name:"Less"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Pop!\">Pop</a></h2>\n<code>func (p *StringVector) Pop() string</code>\n<p>\nPop deletes the last element of the vector.\n</p>\n\n",name:"Pop"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Push!\">Push</a></h2>\n<code>func (p *StringVector) Push(x string)</code>\n<p>\nPush appends x to the end of the vector.\n</p>\n\n",name:"Push"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Resize!\">Resize</a></h2>\n<code>func (p *StringVector) Resize(length, capacity int) *StringVector</code>\n<p>\nResize changes the length and capacity of a vector.\nIf the new length is shorter than the current length, Resize discards\ntrailing elements. If the new length is longer than the current length,\nResize adds the respective zero values for the additional elements. The capacity\nparameter is ignored unless the new length or capacity is longer than the current\ncapacity. The resized vector&#39;s capacity may be larger than the requested capacity.\n</p>\n\n",name:"Resize"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Set!\">Set</a></h2>\n<code>func (p *StringVector) Set(i int, x string)</code>\n<p>\nSet sets the i&#39;th element of the vector to value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Slice!\">Slice</a></h2>\n<code>func (p *StringVector) Slice(i, j int) *StringVector</code>\n<p>\nSlice returns a new sub-vector by slicing the old one to extract slice [i:j].\nThe elements are copied. The original vector is unchanged.\n</p>\n\n",name:"Slice"},{html:"\n<h2><a class=\"black\" href=\"?m:StringVector\">func (*StringVector)</a> <a href=\"?m:StringVector.Swap!\">Swap</a></h2>\n<code>func (p *StringVector) Swap(i, j int)</code>\n<p>\nSwap exchanges the elements at indexes i and j.\n</p>\n\n",name:"Swap"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Vector!\">Vector</a></h2>\n<pre>type Vector []interface{}</pre>\n<p>\nVector is a container for numbered sequences of elements of type interface{}.\nA vector&#39;s length and capacity adjusts automatically as necessary.\nThe zero value for Vector is an empty vector ready to use.\n</p>\n\n",name:"Vector","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.AppendVector!\">AppendVector</a></h2>\n<code>func (p *Vector) AppendVector(x *Vector)</code>\n<p>\nAppendVector appends the entire vector x to the end of this vector.\n</p>\n\n",name:"AppendVector"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.At!\">At</a></h2>\n<code>func (p *Vector) At(i int) interface{}</code>\n<p>\nAt returns the i&#39;th element of the vector.\n</p>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Cap!\">Cap</a></h2>\n<code>func (p *Vector) Cap() int</code>\n<p>\nCap returns the capacity of the vector; that is, the\nmaximum length the vector can grow without resizing.\nSame as cap(*p).\n</p>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Copy!\">Copy</a></h2>\n<code>func (p *Vector) Copy() Vector</code>\n<p>\nCopy makes a copy of the vector and returns it.\n</p>\n\n",name:"Copy"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Cut!\">Cut</a></h2>\n<code>func (p *Vector) Cut(i, j int)</code>\n<p>\nCut deletes elements i through j-1, inclusive.\n</p>\n\n",name:"Cut"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Delete!\">Delete</a></h2>\n<code>func (p *Vector) Delete(i int)</code>\n<p>\nDelete deletes the i&#39;th element of the vector.  The gap is closed so the old\nelement at index i+1 has index i afterwards.\n</p>\n\n",name:"Delete"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Do!\">Do</a></h2>\n<code>func (p *Vector) Do(f func(elem interface{}))</code>\n<p>\nDo calls function f for each element of the vector, in order.\nThe behavior of Do is undefined if f changes *p.\n</p>\n\n",name:"Do"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Expand!\">Expand</a></h2>\n<code>func (p *Vector) Expand(i, n int)</code>\n<p>\nInsert n elements at position i.\n</p>\n\n",name:"Expand"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Extend!\">Extend</a></h2>\n<code>func (p *Vector) Extend(n int)</code>\n<p>\nInsert n elements at the end of a vector.\n</p>\n\n",name:"Extend"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Insert!\">Insert</a></h2>\n<code>func (p *Vector) Insert(i int, x interface{})</code>\n<p>\nInsert inserts into the vector an element of value x before\nthe current element at index i.\n</p>\n\n",name:"Insert"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.InsertVector!\">InsertVector</a></h2>\n<code>func (p *Vector) InsertVector(i int, x *Vector)</code>\n<p>\nInsertVector inserts into the vector the contents of the vector\nx such that the 0th element of x appears at index i after insertion.\n</p>\n\n",name:"InsertVector"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Last!\">Last</a></h2>\n<code>func (p *Vector) Last() interface{}</code>\n<p>\nLast returns the element in the vector of highest index.\n</p>\n\n",name:"Last"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Len!\">Len</a></h2>\n<code>func (p *Vector) Len() int</code>\n<p>\nLen returns the number of elements in the vector.\nSame as len(*p).\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Less!\">Less</a></h2>\n<code>func (p *Vector) Less(i, j int) bool</code>\n<p>\nLess returns a boolean denoting whether the i&#39;th element is less than the j&#39;th element.\n</p>\n\n",name:"Less"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Pop!\">Pop</a></h2>\n<code>func (p *Vector) Pop() interface{}</code>\n<p>\nPop deletes the last element of the vector.\n</p>\n\n",name:"Pop"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Push!\">Push</a></h2>\n<code>func (p *Vector) Push(x interface{})</code>\n<p>\nPush appends x to the end of the vector.\n</p>\n\n",name:"Push"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Resize!\">Resize</a></h2>\n<code>func (p *Vector) Resize(length, capacity int) *Vector</code>\n<p>\nResize changes the length and capacity of a vector.\nIf the new length is shorter than the current length, Resize discards\ntrailing elements. If the new length is longer than the current length,\nResize adds the respective zero values for the additional elements. The capacity\nparameter is ignored unless the new length or capacity is longer than the current\ncapacity. The resized vector&#39;s capacity may be larger than the requested capacity.\n</p>\n\n",name:"Resize"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Set!\">Set</a></h2>\n<code>func (p *Vector) Set(i int, x interface{})</code>\n<p>\nSet sets the i&#39;th element of the vector to value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Slice!\">Slice</a></h2>\n<code>func (p *Vector) Slice(i, j int) *Vector</code>\n<p>\nSlice returns a new sub-vector by slicing the old one to extract slice [i:j].\nThe elements are copied. The original vector is unchanged.\n</p>\n\n",name:"Slice"},{html:"\n<h2><a class=\"black\" href=\"?m:Vector\">func (*Vector)</a> <a href=\"?m:Vector.Swap!\">Swap</a></h2>\n<code>func (p *Vector) Swap(i, j int)</code>\n<p>\nSwap exchanges the elements at indexes i and j.\n</p>\n\n",name:"Swap"}]}],funcs:[],consts:[],vars:[]}