var gortfmData = {index:"index.html",html:"<p>\nThe tar package implements access to tar archives.\nIt aims to cover most of the variations, including those produced\nby GNU and BSD tars.\n</p>\n<p>\nReferences:\n</p>\n<pre><a href=\"http://www.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=5\">http://www.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=5</a>\n<a href=\"http://www.gnu.org/software/tar/manual/html_node/Standard.html\">http://www.gnu.org/software/tar/manual/html_node/Standard.html</a>\n</pre>\n",name:"tar",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Header!\">Header</a></h2>\n<pre>type Header struct {\n\tName     string\n\tMode     int64\n\tUid      int\n\tGid      int\n\tSize     int64\n\tMtime    int64\n\tTypeflag byte\n\tLinkname string\n\tUname    string\n\tGname    string\n\tDevmajor int64\n\tDevminor int64\n\tAtime    int64\n\tCtime    int64\n}</pre>\n<p>\nA Header represents a single header in a tar archive.\nSome fields may not be populated.\n</p>\n\n",name:"Header","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Reader provides sequential access to the contents of a tar archive.\nA tar archive consists of a sequence of files.\nThe Next method advances to the next file in the archive (including the first),\nand then it can be treated as an io.Reader to access the file&#39;s data.\n</p>\n<p>\nExample:\n</p>\n<pre>tr := tar.NewReader(r)\nfor {\n\thdr, err := tr.Next()\n\tif err != nil {\n\t\t// handle error\n\t}\n\tif hdr == nil {\n\t\t// end of tar archive\n\t\tbreak\n\t}\n\tio.Copy(data, tr)\n}\n</pre>\n\n",name:"Reader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Next!\">Next</a></h2>\n<code>func (tr *Reader) Next() (*Header, os.Error)</code>\n<p>\nNext advances to the next entry in the tar archive.\n</p>\n\n",name:"Next"},{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Read!\">Read</a></h2>\n<code>func (tr *Reader) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead reads from the current entry in the tar archive.\nIt returns 0, os.EOF when it reaches the end of that entry,\nuntil Next is called to advance to the next entry.\n</p>\n\n",name:"Read"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\n<pre>type Writer struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Writer provides sequential writing of a tar archive in POSIX.1 format.\nA tar archive consists of a sequence of files.\nCall WriteHeader to begin a new file, and then call Write to supply that file&#39;s data,\nwriting at most hdr.Size bytes in total.\n</p>\n<p>\nExample:\n</p>\n<pre>tw := tar.NewWriter(w)\nhdr := new(Header)\nhdr.Size = length of data in bytes\n// populate other hdr fields as desired\nif err := tw.WriteHeader(hdr); err != nil {\n\t// handle error\n}\nio.Copy(tw, data)\ntw.Close()\n</pre>\n\n",name:"Writer","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Close!\">Close</a></h2>\n<code>func (tw *Writer) Close() os.Error</code>\n<p>\nClose closes the tar archive, flushing any unwritten\ndata to the underlying writer.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Flush!\">Flush</a></h2>\n<code>func (tw *Writer) Flush() os.Error</code>\n<p>\nFlush finishes writing the current file (optional).\n</p>\n\n",name:"Flush"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Write!\">Write</a></h2>\n<code>func (tw *Writer) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite writes to the current entry in the tar archive.\nWrite returns the error ErrWriteTooLong if more than\nhdr.Size bytes are written after WriteHeader.\n</p>\n\n",name:"Write"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.WriteHeader!\">WriteHeader</a></h2>\n<code>func (tw *Writer) WriteHeader(hdr *Header) os.Error</code>\n<p>\nWriteHeader writes hdr and prepares to accept the file&#39;s contents.\nWriteHeader calls Flush if it is not the first header.\nCalling after a Close will return ErrWriteAfterClose.\n</p>\n\n",name:"WriteHeader"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(r io.Reader) *Reader</code>\n<p>\nNewReader creates a new Reader reading from r.\n</p>\n\n",name:"NewReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\n<code>func NewWriter(w io.Writer) *Writer</code>\n<p>\nNewWriter creates a new Writer writing to w.\n</p>\n\n",name:"NewWriter"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TypeReg!\"><em>group</em></a></h2>\n<pre>const (\n\n\t// Types\n\tTypeReg           = &#39;0&#39;\n\tTypeRegA          = &#39;\\x00&#39;\n\tTypeLink          = &#39;1&#39;\n\tTypeSymlink       = &#39;2&#39;\n\tTypeChar          = &#39;3&#39;\n\tTypeBlock         = &#39;4&#39;\n\tTypeDir           = &#39;5&#39;\n\tTypeFifo          = &#39;6&#39;\n\tTypeCont          = &#39;7&#39;\n\tTypeXHeader       = &#39;x&#39;\n\tTypeXGlobalHeader = &#39;g&#39;\n)</pre>\n\n",names:["TypeReg","TypeRegA","TypeLink","TypeSymlink","TypeChar","TypeBlock","TypeDir","TypeFifo","TypeCont","TypeXHeader","TypeXGlobalHeader"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:HeaderError!\">HeaderError</a></h2>\n<pre>var (\n\tHeaderError os.Error = os.ErrorString(&#34;invalid tar header&#34;)\n)</pre>\n\n",names:["HeaderError"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrWriteTooLong!\"><em>group</em></a></h2>\n<pre>var (\n\tErrWriteTooLong    = os.NewError(&#34;write too long&#34;)\n\tErrFieldTooLong    = os.NewError(&#34;header field too long&#34;)\n\tErrWriteAfterClose = os.NewError(&#34;write after close&#34;)\n)</pre>\n\n",names:["ErrWriteTooLong","ErrFieldTooLong","ErrWriteAfterClose"],type:""}]}