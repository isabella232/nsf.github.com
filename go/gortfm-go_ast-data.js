var gortfmData = {index:"index.html",html:"<p>\nPackage ast declares the types used to represent syntax trees for Go\npackages.\n</p>\n",name:"ast",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\n<pre>type ArrayType struct {\n\tLbrack token.Pos // position of &#34;[&#34;\n\tLen    Expr      // Ellipsis node for [...]T array types, nil for slice types\n\tElt    Expr      // element type\n}</pre>\n<p>\nAn ArrayType node represents an array or slice type.\n</p>\n\n",name:"ArrayType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.End!\">End</a></h2>\n<code>func (x *ArrayType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Pos!\">Pos</a></h2>\n<code>func (x *ArrayType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AssignStmt!\">AssignStmt</a></h2>\n<pre>type AssignStmt struct {\n\tLhs    []Expr\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // assignment token, DEFINE\n\tRhs    []Expr\n}</pre>\n<p>\nAn AssignStmt node represents an assignment or\na short variable declaration.\n</p>\n\n",name:"AssignStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:AssignStmt\">func (*AssignStmt)</a> <a href=\"?m:AssignStmt.End!\">End</a></h2>\n<code>func (s *AssignStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:AssignStmt\">func (*AssignStmt)</a> <a href=\"?m:AssignStmt.Pos!\">Pos</a></h2>\n<code>func (s *AssignStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadDecl!\">BadDecl</a></h2>\n<pre>type BadDecl struct {\n\tFrom, To token.Pos // position range of bad declaration\n}</pre>\n<p>\nA BadDecl node is a placeholder for declarations containing\nsyntax errors for which no correct declaration nodes can be\ncreated.\n</p>\n\n",name:"BadDecl","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BadDecl\">func (*BadDecl)</a> <a href=\"?m:BadDecl.End!\">End</a></h2>\n<code>func (d *BadDecl) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BadDecl\">func (*BadDecl)</a> <a href=\"?m:BadDecl.Pos!\">Pos</a></h2>\n<code>func (d *BadDecl) Pos() token.Pos</code>\n<p>\nPos and End implementations for declaration nodes.\n</p>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadExpr!\">BadExpr</a></h2>\n<pre>type BadExpr struct {\n\tFrom, To token.Pos // position range of bad expression\n}</pre>\n<p>\nA BadExpr node is a placeholder for expressions containing\nsyntax errors for which no correct expression nodes can be\ncreated.\n</p>\n\n",name:"BadExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BadExpr\">func (*BadExpr)</a> <a href=\"?m:BadExpr.End!\">End</a></h2>\n<code>func (x *BadExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BadExpr\">func (*BadExpr)</a> <a href=\"?m:BadExpr.Pos!\">Pos</a></h2>\n<code>func (x *BadExpr) Pos() token.Pos</code>\n<p>\nPos and End implementations for expression/type nodes.\n</p>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BadStmt!\">BadStmt</a></h2>\n<pre>type BadStmt struct {\n\tFrom, To token.Pos // position range of bad statement\n}</pre>\n<p>\nA BadStmt node is a placeholder for statements containing\nsyntax errors for which no correct statement nodes can be\ncreated.\n</p>\n\n",name:"BadStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BadStmt\">func (*BadStmt)</a> <a href=\"?m:BadStmt.End!\">End</a></h2>\n<code>func (s *BadStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BadStmt\">func (*BadStmt)</a> <a href=\"?m:BadStmt.Pos!\">Pos</a></h2>\n<code>func (s *BadStmt) Pos() token.Pos</code>\n<p>\nPos and End implementations for statement nodes.\n</p>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BasicLit!\">BasicLit</a></h2>\n<pre>type BasicLit struct {\n\tValuePos token.Pos   // literal position\n\tKind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING\n\tValue    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, &#39;a&#39;, &#39;\\x7f&#39;, &#34;foo&#34; or `\\m\\n\\o`\n}</pre>\n<p>\nA BasicLit node represents a literal of basic type.\n</p>\n\n",name:"BasicLit","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BasicLit\">func (*BasicLit)</a> <a href=\"?m:BasicLit.End!\">End</a></h2>\n<code>func (x *BasicLit) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BasicLit\">func (*BasicLit)</a> <a href=\"?m:BasicLit.Pos!\">Pos</a></h2>\n<code>func (x *BasicLit) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BinaryExpr!\">BinaryExpr</a></h2>\n<pre>type BinaryExpr struct {\n\tX     Expr        // left operand\n\tOpPos token.Pos   // position of Op\n\tOp    token.Token // operator\n\tY     Expr        // right operand\n}</pre>\n<p>\nA BinaryExpr node represents a binary expression.\n</p>\n\n",name:"BinaryExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BinaryExpr\">func (*BinaryExpr)</a> <a href=\"?m:BinaryExpr.End!\">End</a></h2>\n<code>func (x *BinaryExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BinaryExpr\">func (*BinaryExpr)</a> <a href=\"?m:BinaryExpr.Pos!\">Pos</a></h2>\n<code>func (x *BinaryExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BlockStmt!\">BlockStmt</a></h2>\n<pre>type BlockStmt struct {\n\tLbrace token.Pos // position of &#34;{&#34;\n\tList   []Stmt\n\tRbrace token.Pos // position of &#34;}&#34;\n}</pre>\n<p>\nA BlockStmt node represents a braced statement list.\n</p>\n\n",name:"BlockStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BlockStmt\">func (*BlockStmt)</a> <a href=\"?m:BlockStmt.End!\">End</a></h2>\n<code>func (s *BlockStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BlockStmt\">func (*BlockStmt)</a> <a href=\"?m:BlockStmt.Pos!\">Pos</a></h2>\n<code>func (s *BlockStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BranchStmt!\">BranchStmt</a></h2>\n<pre>type BranchStmt struct {\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)\n\tLabel  *Ident      // label name; or nil\n}</pre>\n<p>\nA BranchStmt node represents a break, continue, goto,\nor fallthrough statement.\n</p>\n\n",name:"BranchStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BranchStmt\">func (*BranchStmt)</a> <a href=\"?m:BranchStmt.End!\">End</a></h2>\n<code>func (s *BranchStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:BranchStmt\">func (*BranchStmt)</a> <a href=\"?m:BranchStmt.Pos!\">Pos</a></h2>\n<code>func (s *BranchStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CallExpr!\">CallExpr</a></h2>\n<pre>type CallExpr struct {\n\tFun      Expr      // function expression\n\tLparen   token.Pos // position of &#34;(&#34;\n\tArgs     []Expr    // function arguments; or nil\n\tEllipsis token.Pos // position of &#34;...&#34;, if any\n\tRparen   token.Pos // position of &#34;)&#34;\n}</pre>\n<p>\nA CallExpr node represents an expression followed by an argument list.\n</p>\n\n",name:"CallExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CallExpr\">func (*CallExpr)</a> <a href=\"?m:CallExpr.End!\">End</a></h2>\n<code>func (x *CallExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:CallExpr\">func (*CallExpr)</a> <a href=\"?m:CallExpr.Pos!\">Pos</a></h2>\n<code>func (x *CallExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CaseClause!\">CaseClause</a></h2>\n<pre>type CaseClause struct {\n\tCase  token.Pos // position of &#34;case&#34; or &#34;default&#34; keyword\n\tList  []Expr    // list of expressions or types; nil means default case\n\tColon token.Pos // position of &#34;:&#34;\n\tBody  []Stmt    // statement list; or nil\n}</pre>\n<p>\nA CaseClause represents a case of an expression or type switch statement.\n</p>\n\n",name:"CaseClause","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CaseClause\">func (*CaseClause)</a> <a href=\"?m:CaseClause.End!\">End</a></h2>\n<code>func (s *CaseClause) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:CaseClause\">func (*CaseClause)</a> <a href=\"?m:CaseClause.Pos!\">Pos</a></h2>\n<code>func (s *CaseClause) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\n<pre>type ChanDir int</pre>\n<p>\nThe direction of a channel type is indicated by one\nof the following constants.\n</p>\n\n",name:"ChanDir","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\n<pre>type ChanType struct {\n\tBegin token.Pos // position of &#34;chan&#34; keyword or &#34;&lt;-&#34; (whichever comes first)\n\tDir   ChanDir   // channel direction\n\tValue Expr      // value type\n}</pre>\n<p>\nA ChanType node represents a channel type.\n</p>\n\n",name:"ChanType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.End!\">End</a></h2>\n<code>func (x *ChanType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.Pos!\">Pos</a></h2>\n<code>func (x *ChanType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommClause!\">CommClause</a></h2>\n<pre>type CommClause struct {\n\tCase  token.Pos // position of &#34;case&#34; or &#34;default&#34; keyword\n\tComm  Stmt      // send or receive statement; nil means default case\n\tColon token.Pos // position of &#34;:&#34;\n\tBody  []Stmt    // statement list; or nil\n}</pre>\n<p>\nA CommClause node represents a case of a select statement.\n</p>\n\n",name:"CommClause","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CommClause\">func (*CommClause)</a> <a href=\"?m:CommClause.End!\">End</a></h2>\n<code>func (s *CommClause) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:CommClause\">func (*CommClause)</a> <a href=\"?m:CommClause.Pos!\">Pos</a></h2>\n<code>func (s *CommClause) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Comment!\">Comment</a></h2>\n<pre>type Comment struct {\n\tSlash token.Pos // position of &#34;/&#34; starting the comment\n\tText  string    // comment text (excluding &#39;\\n&#39; for //-style comments)\n}</pre>\n<p>\nA Comment node represents a single //-style or /*-style comment.\n</p>\n\n",name:"Comment","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Comment\">func (*Comment)</a> <a href=\"?m:Comment.End!\">End</a></h2>\n<code>func (c *Comment) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:Comment\">func (*Comment)</a> <a href=\"?m:Comment.Pos!\">Pos</a></h2>\n<code>func (c *Comment) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommentGroup!\">CommentGroup</a></h2>\n<pre>type CommentGroup struct {\n\tList []*Comment // len(List) &gt; 0\n}</pre>\n<p>\nA CommentGroup represents a sequence of comments\nwith no other tokens and no empty lines between.\n</p>\n\n",name:"CommentGroup","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CommentGroup\">func (*CommentGroup)</a> <a href=\"?m:CommentGroup.End!\">End</a></h2>\n<code>func (g *CommentGroup) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:CommentGroup\">func (*CommentGroup)</a> <a href=\"?m:CommentGroup.Pos!\">Pos</a></h2>\n<code>func (g *CommentGroup) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CompositeLit!\">CompositeLit</a></h2>\n<pre>type CompositeLit struct {\n\tType   Expr      // literal type; or nil\n\tLbrace token.Pos // position of &#34;{&#34;\n\tElts   []Expr    // list of composite elements; or nil\n\tRbrace token.Pos // position of &#34;}&#34;\n}</pre>\n<p>\nA CompositeLit node represents a composite literal.\n</p>\n\n",name:"CompositeLit","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CompositeLit\">func (*CompositeLit)</a> <a href=\"?m:CompositeLit.End!\">End</a></h2>\n<code>func (x *CompositeLit) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:CompositeLit\">func (*CompositeLit)</a> <a href=\"?m:CompositeLit.Pos!\">Pos</a></h2>\n<code>func (x *CompositeLit) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decl!\">Decl</a></h2>\n<pre>type Decl interface {\n\tNode\n\t// contains filtered or unexported methods\n}</pre>\n<p>\nAll declaration nodes implement the Decl interface.\n</p>\n\n",name:"Decl","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DeclStmt!\">DeclStmt</a></h2>\n<pre>type DeclStmt struct {\n\tDecl Decl\n}</pre>\n<p>\nA DeclStmt node represents a declaration in a statement list.\n</p>\n\n",name:"DeclStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:DeclStmt\">func (*DeclStmt)</a> <a href=\"?m:DeclStmt.End!\">End</a></h2>\n<code>func (s *DeclStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:DeclStmt\">func (*DeclStmt)</a> <a href=\"?m:DeclStmt.Pos!\">Pos</a></h2>\n<code>func (s *DeclStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DeferStmt!\">DeferStmt</a></h2>\n<pre>type DeferStmt struct {\n\tDefer token.Pos // position of &#34;defer&#34; keyword\n\tCall  *CallExpr\n}</pre>\n<p>\nA DeferStmt node represents a defer statement.\n</p>\n\n",name:"DeferStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:DeferStmt\">func (*DeferStmt)</a> <a href=\"?m:DeferStmt.End!\">End</a></h2>\n<code>func (s *DeferStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:DeferStmt\">func (*DeferStmt)</a> <a href=\"?m:DeferStmt.Pos!\">Pos</a></h2>\n<code>func (s *DeferStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Ellipsis!\">Ellipsis</a></h2>\n<pre>type Ellipsis struct {\n\tEllipsis token.Pos // position of &#34;...&#34;\n\tElt      Expr      // ellipsis element type (parameter lists only); or nil\n}</pre>\n<p>\nAn Ellipsis node stands for the &#34;...&#34; type in a\nparameter list or the &#34;...&#34; length in an array type.\n</p>\n\n",name:"Ellipsis","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Ellipsis\">func (*Ellipsis)</a> <a href=\"?m:Ellipsis.End!\">End</a></h2>\n<code>func (x *Ellipsis) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:Ellipsis\">func (*Ellipsis)</a> <a href=\"?m:Ellipsis.Pos!\">Pos</a></h2>\n<code>func (x *Ellipsis) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EmptyStmt!\">EmptyStmt</a></h2>\n<pre>type EmptyStmt struct {\n\tSemicolon token.Pos // position of preceding &#34;;&#34;\n}</pre>\n<p>\nAn EmptyStmt node represents an empty statement.\nThe &#34;position&#34; of the empty statement is the position\nof the immediately preceding semicolon.\n</p>\n\n",name:"EmptyStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:EmptyStmt\">func (*EmptyStmt)</a> <a href=\"?m:EmptyStmt.End!\">End</a></h2>\n<code>func (s *EmptyStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:EmptyStmt\">func (*EmptyStmt)</a> <a href=\"?m:EmptyStmt.Pos!\">Pos</a></h2>\n<code>func (s *EmptyStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Expr!\">Expr</a></h2>\n<pre>type Expr interface {\n\tNode\n\t// contains filtered or unexported methods\n}</pre>\n<p>\nAll expression nodes implement the Expr interface.\n</p>\n\n",name:"Expr","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ExprStmt!\">ExprStmt</a></h2>\n<pre>type ExprStmt struct {\n\tX Expr // expression\n}</pre>\n<p>\nAn ExprStmt node represents a (stand-alone) expression\nin a statement list.\n</p>\n\n",name:"ExprStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ExprStmt\">func (*ExprStmt)</a> <a href=\"?m:ExprStmt.End!\">End</a></h2>\n<code>func (s *ExprStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ExprStmt\">func (*ExprStmt)</a> <a href=\"?m:ExprStmt.Pos!\">Pos</a></h2>\n<code>func (s *ExprStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Field!\">Field</a></h2>\n<pre>type Field struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tNames   []*Ident      // field/method/parameter names; or nil if anonymous field\n\tType    Expr          // field/method/parameter type\n\tTag     *BasicLit     // field tag; or nil\n\tComment *CommentGroup // line comments; or nil\n}</pre>\n<p>\nA Field represents a Field declaration list in a struct type,\na method list in an interface type, or a parameter/result declaration\nin a signature.\n</p>\n\n",name:"Field","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Field\">func (*Field)</a> <a href=\"?m:Field.End!\">End</a></h2>\n<code>func (f *Field) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:Field\">func (*Field)</a> <a href=\"?m:Field.Pos!\">Pos</a></h2>\n<code>func (f *Field) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FieldFilter!\">FieldFilter</a></h2>\n<pre>type FieldFilter func(name string, value reflect.Value) bool</pre>\n<p>\nA FieldFilter may be provided to Fprint to control the output.\n</p>\n\n",name:"FieldFilter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FieldList!\">FieldList</a></h2>\n<pre>type FieldList struct {\n\tOpening token.Pos // position of opening parenthesis/brace, if any\n\tList    []*Field  // field list; or nil\n\tClosing token.Pos // position of closing parenthesis/brace, if any\n}</pre>\n<p>\nA FieldList represents a list of Fields, enclosed by parentheses or braces.\n</p>\n\n",name:"FieldList","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FieldList\">func (*FieldList)</a> <a href=\"?m:FieldList.End!\">End</a></h2>\n<code>func (f *FieldList) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:FieldList\">func (*FieldList)</a> <a href=\"?m:FieldList.NumFields!\">NumFields</a></h2>\n<code>func (f *FieldList) NumFields() int</code>\n<p>\nNumFields returns the number of (named and anonymous fields) in a FieldList.\n</p>\n\n",name:"NumFields"},{html:"\n<h2><a class=\"black\" href=\"?m:FieldList\">func (*FieldList)</a> <a href=\"?m:FieldList.Pos!\">Pos</a></h2>\n<code>func (f *FieldList) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\n<pre>type File struct {\n\tDoc        *CommentGroup   // associated documentation; or nil\n\tPackage    token.Pos       // position of &#34;package&#34; keyword\n\tName       *Ident          // package name\n\tDecls      []Decl          // top-level declarations; or nil\n\tScope      *Scope          // package scope (this file only)\n\tImports    []*ImportSpec   // imports in this file\n\tUnresolved []*Ident        // unresolved identifiers in this file\n\tComments   []*CommentGroup // list of all comments in the source file\n}</pre>\n<p>\nA File node represents a Go source file.\n</p>\n<p>\nThe Comments list contains all comments in the source file in order of\nappearance, including the comments that are pointed to from other nodes\nvia Doc and Comment fields.\n</p>\n\n",name:"File","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.End!\">End</a></h2>\n<code>func (f *File) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Pos!\">Pos</a></h2>\n<code>func (f *File) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Filter!\">Filter</a></h2>\n<pre>type Filter func(string) bool</pre>\n\n",name:"Filter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ForStmt!\">ForStmt</a></h2>\n<pre>type ForStmt struct {\n\tFor  token.Pos // position of &#34;for&#34; keyword\n\tInit Stmt      // initialization statement; or nil\n\tCond Expr      // condition; or nil\n\tPost Stmt      // post iteration statement; or nil\n\tBody *BlockStmt\n}</pre>\n<p>\nA ForStmt represents a for statement.\n</p>\n\n",name:"ForStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ForStmt\">func (*ForStmt)</a> <a href=\"?m:ForStmt.End!\">End</a></h2>\n<code>func (s *ForStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ForStmt\">func (*ForStmt)</a> <a href=\"?m:ForStmt.Pos!\">Pos</a></h2>\n<code>func (s *ForStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncDecl!\">FuncDecl</a></h2>\n<pre>type FuncDecl struct {\n\tDoc  *CommentGroup // associated documentation; or nil\n\tRecv *FieldList    // receiver (methods); or nil (functions)\n\tName *Ident        // function/method name\n\tType *FuncType     // position of Func keyword, parameters and results\n\tBody *BlockStmt    // function body; or nil (forward declaration)\n}</pre>\n<p>\nA FuncDecl node represents a function declaration.\n</p>\n\n",name:"FuncDecl","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FuncDecl\">func (*FuncDecl)</a> <a href=\"?m:FuncDecl.End!\">End</a></h2>\n<code>func (d *FuncDecl) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncDecl\">func (*FuncDecl)</a> <a href=\"?m:FuncDecl.Pos!\">Pos</a></h2>\n<code>func (d *FuncDecl) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncLit!\">FuncLit</a></h2>\n<pre>type FuncLit struct {\n\tType *FuncType  // function type\n\tBody *BlockStmt // function body\n}</pre>\n<p>\nA FuncLit node represents a function literal.\n</p>\n\n",name:"FuncLit","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FuncLit\">func (*FuncLit)</a> <a href=\"?m:FuncLit.End!\">End</a></h2>\n<code>func (x *FuncLit) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncLit\">func (*FuncLit)</a> <a href=\"?m:FuncLit.Pos!\">Pos</a></h2>\n<code>func (x *FuncLit) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\n<pre>type FuncType struct {\n\tFunc    token.Pos  // position of &#34;func&#34; keyword\n\tParams  *FieldList // (incoming) parameters; or nil\n\tResults *FieldList // (outgoing) results; or nil\n}</pre>\n<p>\nA FuncType node represents a function type.\n</p>\n\n",name:"FuncType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.End!\">End</a></h2>\n<code>func (x *FuncType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.Pos!\">Pos</a></h2>\n<code>func (x *FuncType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GenDecl!\">GenDecl</a></h2>\n<pre>type GenDecl struct {\n\tDoc    *CommentGroup // associated documentation; or nil\n\tTokPos token.Pos     // position of Tok\n\tTok    token.Token   // IMPORT, CONST, TYPE, VAR\n\tLparen token.Pos     // position of &#39;(&#39;, if any\n\tSpecs  []Spec\n\tRparen token.Pos // position of &#39;)&#39;, if any\n}</pre>\n<p>\nA GenDecl node (generic declaration node) represents an import,\nconstant, type or variable declaration. A valid Lparen position\n(Lparen.Line &gt; 0) indicates a parenthesized declaration.\n</p>\n<p>\nRelationship between Tok value and Specs element type:\n</p>\n<pre>token.IMPORT  *ImportSpec\ntoken.CONST   *ValueSpec\ntoken.TYPE    *TypeSpec\ntoken.VAR     *ValueSpec\n</pre>\n\n",name:"GenDecl","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:GenDecl\">func (*GenDecl)</a> <a href=\"?m:GenDecl.End!\">End</a></h2>\n<code>func (d *GenDecl) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:GenDecl\">func (*GenDecl)</a> <a href=\"?m:GenDecl.Pos!\">Pos</a></h2>\n<code>func (d *GenDecl) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoStmt!\">GoStmt</a></h2>\n<pre>type GoStmt struct {\n\tGo   token.Pos // position of &#34;go&#34; keyword\n\tCall *CallExpr\n}</pre>\n<p>\nA GoStmt node represents a go statement.\n</p>\n\n",name:"GoStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:GoStmt\">func (*GoStmt)</a> <a href=\"?m:GoStmt.End!\">End</a></h2>\n<code>func (s *GoStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:GoStmt\">func (*GoStmt)</a> <a href=\"?m:GoStmt.Pos!\">Pos</a></h2>\n<code>func (s *GoStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Ident!\">Ident</a></h2>\n<pre>type Ident struct {\n\tNamePos token.Pos // identifier position\n\tName    string    // identifier name\n\tObj     *Object   // denoted object; or nil\n}</pre>\n<p>\nAn Ident node represents an identifier.\n</p>\n\n",name:"Ident","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.End!\">End</a></h2>\n<code>func (x *Ident) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.IsExported!\">IsExported</a></h2>\n<code>func (id *Ident) IsExported() bool</code>\n<p>\nIsExported returns whether id is an exported Go symbol\n(i.e., whether it begins with an uppercase letter).\n</p>\n\n",name:"IsExported"},{html:"\n<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.Pos!\">Pos</a></h2>\n<code>func (x *Ident) Pos() token.Pos</code>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:Ident\">func (*Ident)</a> <a href=\"?m:Ident.String!\">String</a></h2>\n<code>func (id *Ident) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IfStmt!\">IfStmt</a></h2>\n<pre>type IfStmt struct {\n\tIf   token.Pos // position of &#34;if&#34; keyword\n\tInit Stmt      // initialization statement; or nil\n\tCond Expr      // condition\n\tBody *BlockStmt\n\tElse Stmt // else branch; or nil\n}</pre>\n<p>\nAn IfStmt node represents an if statement.\n</p>\n\n",name:"IfStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IfStmt\">func (*IfStmt)</a> <a href=\"?m:IfStmt.End!\">End</a></h2>\n<code>func (s *IfStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:IfStmt\">func (*IfStmt)</a> <a href=\"?m:IfStmt.Pos!\">Pos</a></h2>\n<code>func (s *IfStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ImportSpec!\">ImportSpec</a></h2>\n<pre>type ImportSpec struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tName    *Ident        // local package name (including &#34;.&#34;); or nil\n\tPath    *BasicLit     // import path\n\tComment *CommentGroup // line comments; or nil\n}</pre>\n<p>\nAn ImportSpec node represents a single package import.\n</p>\n\n",name:"ImportSpec","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ImportSpec\">func (*ImportSpec)</a> <a href=\"?m:ImportSpec.End!\">End</a></h2>\n<code>func (s *ImportSpec) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ImportSpec\">func (*ImportSpec)</a> <a href=\"?m:ImportSpec.Pos!\">Pos</a></h2>\n<code>func (s *ImportSpec) Pos() token.Pos</code>\n<p>\nPos and End implementations for spec nodes.\n</p>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Importer!\">Importer</a></h2>\n<pre>type Importer func(imports map[string]*Object, path string) (pkg *Object, err os.Error)</pre>\n<p>\nAn Importer resolves import paths to package Objects.\nThe imports map records the packages already imported,\nindexed by package id (canonical import path).\nAn Importer must determine the canonical import path and\ncheck the map to see if it is already present in the imports map.\nIf so, the Importer can return the map entry.  Otherwise, the\nImporter should load the package data for the given path into\na new *Object (pkg), record pkg in the imports map, and then\nreturn pkg.\n</p>\n\n",name:"Importer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IncDecStmt!\">IncDecStmt</a></h2>\n<pre>type IncDecStmt struct {\n\tX      Expr\n\tTokPos token.Pos   // position of Tok\n\tTok    token.Token // INC or DEC\n}</pre>\n<p>\nAn IncDecStmt node represents an increment or decrement statement.\n</p>\n\n",name:"IncDecStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IncDecStmt\">func (*IncDecStmt)</a> <a href=\"?m:IncDecStmt.End!\">End</a></h2>\n<code>func (s *IncDecStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:IncDecStmt\">func (*IncDecStmt)</a> <a href=\"?m:IncDecStmt.Pos!\">Pos</a></h2>\n<code>func (s *IncDecStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IndexExpr!\">IndexExpr</a></h2>\n<pre>type IndexExpr struct {\n\tX      Expr      // expression\n\tLbrack token.Pos // position of &#34;[&#34;\n\tIndex  Expr      // index expression\n\tRbrack token.Pos // position of &#34;]&#34;\n}</pre>\n<p>\nAn IndexExpr node represents an expression followed by an index.\n</p>\n\n",name:"IndexExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IndexExpr\">func (*IndexExpr)</a> <a href=\"?m:IndexExpr.End!\">End</a></h2>\n<code>func (x *IndexExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:IndexExpr\">func (*IndexExpr)</a> <a href=\"?m:IndexExpr.Pos!\">Pos</a></h2>\n<code>func (x *IndexExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\n<pre>type InterfaceType struct {\n\tInterface  token.Pos  // position of &#34;interface&#34; keyword\n\tMethods    *FieldList // list of methods\n\tIncomplete bool       // true if (source) methods are missing in the Methods list\n}</pre>\n<p>\nAn InterfaceType node represents an interface type.\n</p>\n\n",name:"InterfaceType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.End!\">End</a></h2>\n<code>func (x *InterfaceType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.Pos!\">Pos</a></h2>\n<code>func (x *InterfaceType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeyValueExpr!\">KeyValueExpr</a></h2>\n<pre>type KeyValueExpr struct {\n\tKey   Expr\n\tColon token.Pos // position of &#34;:&#34;\n\tValue Expr\n}</pre>\n<p>\nA KeyValueExpr node represents (key : value) pairs\nin composite literals.\n</p>\n\n",name:"KeyValueExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:KeyValueExpr\">func (*KeyValueExpr)</a> <a href=\"?m:KeyValueExpr.End!\">End</a></h2>\n<code>func (x *KeyValueExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:KeyValueExpr\">func (*KeyValueExpr)</a> <a href=\"?m:KeyValueExpr.Pos!\">Pos</a></h2>\n<code>func (x *KeyValueExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LabeledStmt!\">LabeledStmt</a></h2>\n<pre>type LabeledStmt struct {\n\tLabel *Ident\n\tColon token.Pos // position of &#34;:&#34;\n\tStmt  Stmt\n}</pre>\n<p>\nA LabeledStmt node represents a labeled statement.\n</p>\n\n",name:"LabeledStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:LabeledStmt\">func (*LabeledStmt)</a> <a href=\"?m:LabeledStmt.End!\">End</a></h2>\n<code>func (s *LabeledStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:LabeledStmt\">func (*LabeledStmt)</a> <a href=\"?m:LabeledStmt.Pos!\">Pos</a></h2>\n<code>func (s *LabeledStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\n<pre>type MapType struct {\n\tMap   token.Pos // position of &#34;map&#34; keyword\n\tKey   Expr\n\tValue Expr\n}</pre>\n<p>\nA MapType node represents a map type.\n</p>\n\n",name:"MapType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.End!\">End</a></h2>\n<code>func (x *MapType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.Pos!\">Pos</a></h2>\n<code>func (x *MapType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MergeMode!\">MergeMode</a></h2>\n<pre>type MergeMode uint</pre>\n<p>\nThe MergeMode flags control the behavior of MergePackageFiles.\n</p>\n\n",name:"MergeMode","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Node!\">Node</a></h2>\n<pre>type Node interface {\n\tPos() token.Pos // position of first character belonging to the node\n\tEnd() token.Pos // position of first character immediately after the node\n}</pre>\n<p>\nAll node types implement the Node interface.\n</p>\n\n",name:"Node","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ObjKind!\">ObjKind</a></h2>\n<pre>type ObjKind int</pre>\n<p>\nObKind describes what an object represents.\n</p>\n\n",name:"ObjKind","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ObjKind\">func (ObjKind)</a> <a href=\"?m:ObjKind.String!\">String</a></h2>\n<code>func (kind ObjKind) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Object!\">Object</a></h2>\n<pre>type Object struct {\n\tKind ObjKind\n\tName string      // declared name\n\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, or LabeledStmt; or nil\n\tData interface{} // object-specific data; or nil\n\tType interface{} // place holder for type information; may be nil\n}</pre>\n<p>\nAn Object describes a named language entity such as a package,\nconstant, type, variable, function (incl. methods), or label.\n</p>\n<p>\nThe Data fields contains object-specific data:\n</p>\n<pre>Kind    Data type    Data value\nPkg\t*Scope       package scope\nCon     int          iota for the respective declaration\nCon     != nil       constant value\n</pre>\n\n",name:"Object","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Object\">func (*Object)</a> <a href=\"?m:Object.Pos!\">Pos</a></h2>\n<code>func (obj *Object) Pos() token.Pos</code>\n<p>\nPos computes the source position of the declaration of an object name.\nThe result may be an invalid position if it cannot be computed\n(obj.Decl may be nil or not correct).\n</p>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Package!\">Package</a></h2>\n<pre>type Package struct {\n\tName    string             // package name\n\tScope   *Scope             // package scope across all files\n\tImports map[string]*Object // map of package id -&gt; package object\n\tFiles   map[string]*File   // Go source files by filename\n}</pre>\n<p>\nA Package node represents a set of source files\ncollectively building a Go package.\n</p>\n\n",name:"Package","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Package\">func (*Package)</a> <a href=\"?m:Package.End!\">End</a></h2>\n<code>func (p *Package) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:Package\">func (*Package)</a> <a href=\"?m:Package.Pos!\">Pos</a></h2>\n<code>func (p *Package) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ParenExpr!\">ParenExpr</a></h2>\n<pre>type ParenExpr struct {\n\tLparen token.Pos // position of &#34;(&#34;\n\tX      Expr      // parenthesized expression\n\tRparen token.Pos // position of &#34;)&#34;\n}</pre>\n<p>\nA ParenExpr node represents a parenthesized expression.\n</p>\n\n",name:"ParenExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ParenExpr\">func (*ParenExpr)</a> <a href=\"?m:ParenExpr.End!\">End</a></h2>\n<code>func (x *ParenExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ParenExpr\">func (*ParenExpr)</a> <a href=\"?m:ParenExpr.Pos!\">Pos</a></h2>\n<code>func (x *ParenExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RangeStmt!\">RangeStmt</a></h2>\n<pre>type RangeStmt struct {\n\tFor        token.Pos   // position of &#34;for&#34; keyword\n\tKey, Value Expr        // Value may be nil\n\tTokPos     token.Pos   // position of Tok\n\tTok        token.Token // ASSIGN, DEFINE\n\tX          Expr        // value to range over\n\tBody       *BlockStmt\n}</pre>\n<p>\nA RangeStmt represents a for statement with a range clause.\n</p>\n\n",name:"RangeStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RangeStmt\">func (*RangeStmt)</a> <a href=\"?m:RangeStmt.End!\">End</a></h2>\n<code>func (s *RangeStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:RangeStmt\">func (*RangeStmt)</a> <a href=\"?m:RangeStmt.Pos!\">Pos</a></h2>\n<code>func (s *RangeStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReturnStmt!\">ReturnStmt</a></h2>\n<pre>type ReturnStmt struct {\n\tReturn  token.Pos // position of &#34;return&#34; keyword\n\tResults []Expr    // result expressions; or nil\n}</pre>\n<p>\nA ReturnStmt node represents a return statement.\n</p>\n\n",name:"ReturnStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReturnStmt\">func (*ReturnStmt)</a> <a href=\"?m:ReturnStmt.End!\">End</a></h2>\n<code>func (s *ReturnStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ReturnStmt\">func (*ReturnStmt)</a> <a href=\"?m:ReturnStmt.Pos!\">Pos</a></h2>\n<code>func (s *ReturnStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scope!\">Scope</a></h2>\n<pre>type Scope struct {\n\tOuter   *Scope\n\tObjects map[string]*Object\n}</pre>\n<p>\nA Scope maintains the set of named language entities declared\nin the scope and a link to the immediately surrounding (outer)\nscope.\n</p>\n\n",name:"Scope","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Scope\">func (*Scope)</a> <a href=\"?m:Scope.Insert!\">Insert</a></h2>\n<code>func (s *Scope) Insert(obj *Object) (alt *Object)</code>\n<p>\nInsert attempts to insert a named object obj into the scope s.\nIf the scope already contains an object alt with the same name,\nInsert leaves the scope unchanged and returns alt. Otherwise\nit inserts obj and returns nil.&#34;\n</p>\n\n",name:"Insert"},{html:"\n<h2><a class=\"black\" href=\"?m:Scope\">func (*Scope)</a> <a href=\"?m:Scope.Lookup!\">Lookup</a></h2>\n<code>func (s *Scope) Lookup(name string) *Object</code>\n<p>\nLookup returns the object with the given name if it is\nfound in scope s, otherwise it returns nil. Outer scopes\nare ignored.\n</p>\n\n",name:"Lookup"},{html:"\n<h2><a class=\"black\" href=\"?m:Scope\">func (*Scope)</a> <a href=\"?m:Scope.String!\">String</a></h2>\n<code>func (s *Scope) String() string</code>\n<p>\nDebugging support\n</p>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SelectStmt!\">SelectStmt</a></h2>\n<pre>type SelectStmt struct {\n\tSelect token.Pos  // position of &#34;select&#34; keyword\n\tBody   *BlockStmt // CommClauses only\n}</pre>\n<p>\nAn SelectStmt node represents a select statement.\n</p>\n\n",name:"SelectStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SelectStmt\">func (*SelectStmt)</a> <a href=\"?m:SelectStmt.End!\">End</a></h2>\n<code>func (s *SelectStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:SelectStmt\">func (*SelectStmt)</a> <a href=\"?m:SelectStmt.Pos!\">Pos</a></h2>\n<code>func (s *SelectStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SelectorExpr!\">SelectorExpr</a></h2>\n<pre>type SelectorExpr struct {\n\tX   Expr   // expression\n\tSel *Ident // field selector\n}</pre>\n<p>\nA SelectorExpr node represents an expression followed by a selector.\n</p>\n\n",name:"SelectorExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SelectorExpr\">func (*SelectorExpr)</a> <a href=\"?m:SelectorExpr.End!\">End</a></h2>\n<code>func (x *SelectorExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:SelectorExpr\">func (*SelectorExpr)</a> <a href=\"?m:SelectorExpr.Pos!\">Pos</a></h2>\n<code>func (x *SelectorExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SendStmt!\">SendStmt</a></h2>\n<pre>type SendStmt struct {\n\tChan  Expr\n\tArrow token.Pos // position of &#34;&lt;-&#34;\n\tValue Expr\n}</pre>\n<p>\nA SendStmt node represents a send statement.\n</p>\n\n",name:"SendStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SendStmt\">func (*SendStmt)</a> <a href=\"?m:SendStmt.End!\">End</a></h2>\n<code>func (s *SendStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:SendStmt\">func (*SendStmt)</a> <a href=\"?m:SendStmt.Pos!\">Pos</a></h2>\n<code>func (s *SendStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceExpr!\">SliceExpr</a></h2>\n<pre>type SliceExpr struct {\n\tX      Expr      // expression\n\tLbrack token.Pos // position of &#34;[&#34;\n\tLow    Expr      // begin of slice range; or nil\n\tHigh   Expr      // end of slice range; or nil\n\tRbrack token.Pos // position of &#34;]&#34;\n}</pre>\n<p>\nAn SliceExpr node represents an expression followed by slice indices.\n</p>\n\n",name:"SliceExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SliceExpr\">func (*SliceExpr)</a> <a href=\"?m:SliceExpr.End!\">End</a></h2>\n<code>func (x *SliceExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceExpr\">func (*SliceExpr)</a> <a href=\"?m:SliceExpr.Pos!\">Pos</a></h2>\n<code>func (x *SliceExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Spec!\">Spec</a></h2>\n<pre>type Spec interface {\n\tNode\n\t// contains filtered or unexported methods\n}</pre>\n<p>\nThe Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec.\n</p>\n\n",name:"Spec","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StarExpr!\">StarExpr</a></h2>\n<pre>type StarExpr struct {\n\tStar token.Pos // position of &#34;*&#34;\n\tX    Expr      // operand\n}</pre>\n<p>\nA StarExpr node represents an expression of the form &#34;*&#34; Expression.\nSemantically it could be a unary &#34;*&#34; expression, or a pointer type.\n</p>\n\n",name:"StarExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StarExpr\">func (*StarExpr)</a> <a href=\"?m:StarExpr.End!\">End</a></h2>\n<code>func (x *StarExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:StarExpr\">func (*StarExpr)</a> <a href=\"?m:StarExpr.Pos!\">Pos</a></h2>\n<code>func (x *StarExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Stmt!\">Stmt</a></h2>\n<pre>type Stmt interface {\n\tNode\n\t// contains filtered or unexported methods\n}</pre>\n<p>\nAll statement nodes implement the Stmt interface.\n</p>\n\n",name:"Stmt","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\n<pre>type StructType struct {\n\tStruct     token.Pos  // position of &#34;struct&#34; keyword\n\tFields     *FieldList // list of field declarations\n\tIncomplete bool       // true if (source) fields are missing in the Fields list\n}</pre>\n<p>\nA StructType node represents a struct type.\n</p>\n\n",name:"StructType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.End!\">End</a></h2>\n<code>func (x *StructType) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.Pos!\">Pos</a></h2>\n<code>func (x *StructType) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SwitchStmt!\">SwitchStmt</a></h2>\n<pre>type SwitchStmt struct {\n\tSwitch token.Pos  // position of &#34;switch&#34; keyword\n\tInit   Stmt       // initialization statement; or nil\n\tTag    Expr       // tag expression; or nil\n\tBody   *BlockStmt // CaseClauses only\n}</pre>\n<p>\nA SwitchStmt node represents an expression switch statement.\n</p>\n\n",name:"SwitchStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SwitchStmt\">func (*SwitchStmt)</a> <a href=\"?m:SwitchStmt.End!\">End</a></h2>\n<code>func (s *SwitchStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:SwitchStmt\">func (*SwitchStmt)</a> <a href=\"?m:SwitchStmt.Pos!\">Pos</a></h2>\n<code>func (s *SwitchStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeAssertExpr!\">TypeAssertExpr</a></h2>\n<pre>type TypeAssertExpr struct {\n\tX    Expr // expression\n\tType Expr // asserted type; nil means type switch X.(type)\n}</pre>\n<p>\nA TypeAssertExpr node represents an expression followed by a\ntype assertion.\n</p>\n\n",name:"TypeAssertExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertExpr\">func (*TypeAssertExpr)</a> <a href=\"?m:TypeAssertExpr.End!\">End</a></h2>\n<code>func (x *TypeAssertExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertExpr\">func (*TypeAssertExpr)</a> <a href=\"?m:TypeAssertExpr.Pos!\">Pos</a></h2>\n<code>func (x *TypeAssertExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeSpec!\">TypeSpec</a></h2>\n<pre>type TypeSpec struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tName    *Ident        // type name\n\tType    Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes\n\tComment *CommentGroup // line comments; or nil\n}</pre>\n<p>\nA TypeSpec node represents a type declaration (TypeSpec production).\n</p>\n\n",name:"TypeSpec","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TypeSpec\">func (*TypeSpec)</a> <a href=\"?m:TypeSpec.End!\">End</a></h2>\n<code>func (s *TypeSpec) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeSpec\">func (*TypeSpec)</a> <a href=\"?m:TypeSpec.Pos!\">Pos</a></h2>\n<code>func (s *TypeSpec) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeSwitchStmt!\">TypeSwitchStmt</a></h2>\n<pre>type TypeSwitchStmt struct {\n\tSwitch token.Pos  // position of &#34;switch&#34; keyword\n\tInit   Stmt       // initialization statement; or nil\n\tAssign Stmt       // x := y.(type) or y.(type)\n\tBody   *BlockStmt // CaseClauses only\n}</pre>\n<p>\nAn TypeSwitchStmt node represents a type switch statement.\n</p>\n\n",name:"TypeSwitchStmt","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TypeSwitchStmt\">func (*TypeSwitchStmt)</a> <a href=\"?m:TypeSwitchStmt.End!\">End</a></h2>\n<code>func (s *TypeSwitchStmt) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeSwitchStmt\">func (*TypeSwitchStmt)</a> <a href=\"?m:TypeSwitchStmt.Pos!\">Pos</a></h2>\n<code>func (s *TypeSwitchStmt) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnaryExpr!\">UnaryExpr</a></h2>\n<pre>type UnaryExpr struct {\n\tOpPos token.Pos   // position of Op\n\tOp    token.Token // operator\n\tX     Expr        // operand\n}</pre>\n<p>\nA UnaryExpr node represents a unary expression.\nUnary &#34;*&#34; expressions are represented via StarExpr nodes.\n</p>\n\n",name:"UnaryExpr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnaryExpr\">func (*UnaryExpr)</a> <a href=\"?m:UnaryExpr.End!\">End</a></h2>\n<code>func (x *UnaryExpr) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:UnaryExpr\">func (*UnaryExpr)</a> <a href=\"?m:UnaryExpr.Pos!\">Pos</a></h2>\n<code>func (x *UnaryExpr) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ValueSpec!\">ValueSpec</a></h2>\n<pre>type ValueSpec struct {\n\tDoc     *CommentGroup // associated documentation; or nil\n\tNames   []*Ident      // value names (len(Names) &gt; 0)\n\tType    Expr          // value type; or nil\n\tValues  []Expr        // initial values; or nil\n\tComment *CommentGroup // line comments; or nil\n}</pre>\n<p>\nA ValueSpec node represents a constant or variable declaration\n(ConstSpec or VarSpec production).\n</p>\n\n",name:"ValueSpec","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ValueSpec\">func (*ValueSpec)</a> <a href=\"?m:ValueSpec.End!\">End</a></h2>\n<code>func (s *ValueSpec) End() token.Pos</code>\n\n",name:"End"},{html:"\n<h2><a class=\"black\" href=\"?m:ValueSpec\">func (*ValueSpec)</a> <a href=\"?m:ValueSpec.Pos!\">Pos</a></h2>\n<code>func (s *ValueSpec) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Visitor!\">Visitor</a></h2>\n<pre>type Visitor interface {\n\tVisit(node Node) (w Visitor)\n}</pre>\n<p>\nA Visitor&#39;s Visit method is invoked for each node encountered by Walk.\nIf the result visitor w is not nil, Walk visits each of the children\nof node with the visitor w, followed by a call of w.Visit(nil).\n</p>\n\n",name:"Visitor","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileExports!\">FileExports</a></h2>\n<code>func FileExports(src *File) bool</code>\n<p>\nFileExports trims the AST for a Go source file in place such that only\nexported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped, and the function bodies of exported functions are set to nil.\nThe File.comments list is not changed.\n</p>\n<p>\nFileExports returns true if there is an exported declaration; it returns\nfalse otherwise.\n</p>\n\n",name:"FileExports"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilterDecl!\">FilterDecl</a></h2>\n<code>func FilterDecl(decl Decl, f Filter) bool</code>\n<p>\nFilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don&#39;t pass through the filter f.\n</p>\n<p>\nFilterDecl returns true if there are any declared names left after\nfiltering; it returns false otherwise.\n</p>\n\n",name:"FilterDecl"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilterFile!\">FilterFile</a></h2>\n<code>func FilterFile(src *File, f Filter) bool</code>\n<p>\nFilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don&#39;t\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST.\nThe File.comments list is not changed.\n</p>\n<p>\nFilterFile returns true if there are any top-level declarations\nleft after filtering; it returns false otherwise.\n</p>\n\n",name:"FilterFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilterPackage!\">FilterPackage</a></h2>\n<code>func FilterPackage(pkg *Package, f Filter) bool</code>\n<p>\nFilterPackage trims the AST for a Go package in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don&#39;t\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST.\nThe pkg.Files list is not changed, so that file names and top-level\npackage comments don&#39;t get lost.\n</p>\n<p>\nFilterPackage returns true if there are any top-level declarations\nleft after filtering; it returns false otherwise.\n</p>\n\n",name:"FilterPackage"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fprint!\">Fprint</a></h2>\n<code>func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n int, err os.Error)</code>\n<p>\nFprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n</p>\n<p>\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nare printed; all others are filtered from the output.\n</p>\n\n",name:"Fprint"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Inspect!\">Inspect</a></h2>\n<code>func Inspect(node Node, f func(Node) bool)</code>\n<p>\nInspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nfor all the non-nil children of node, recursively.\n</p>\n\n",name:"Inspect"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IsExported!\">IsExported</a></h2>\n<code>func IsExported(name string) bool</code>\n<p>\nIsExported returns whether name is an exported Go symbol\n(i.e., whether it begins with an uppercase letter).\n</p>\n\n",name:"IsExported"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MergePackageFiles!\">MergePackageFiles</a></h2>\n<code>func MergePackageFiles(pkg *Package, mode MergeMode) *File</code>\n<p>\nMergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n</p>\n\n",name:"MergePackageFiles"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewIdent!\">NewIdent</a></h2>\n<code>func NewIdent(name string) *Ident</code>\n<p>\nNewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n</p>\n\n",name:"NewIdent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewObj!\">NewObj</a></h2>\n<code>func NewObj(kind ObjKind, name string) *Object</code>\n<p>\nNewObj creates a new object of a given kind and name.\n</p>\n\n",name:"NewObj"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewPackage!\">NewPackage</a></h2>\n<code>func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, os.Error)</code>\n<p>\nNewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file&#39;s Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n</p>\n\n",name:"NewPackage"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewScope!\">NewScope</a></h2>\n<code>func NewScope(outer *Scope) *Scope</code>\n<p>\nNewScope creates a new scope nested in the outer scope.\n</p>\n\n",name:"NewScope"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotNilFilter!\">NotNilFilter</a></h2>\n<code>func NotNilFilter(_ string, v reflect.Value) bool</code>\n<p>\nNotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n</p>\n\n",name:"NotNilFilter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PackageExports!\">PackageExports</a></h2>\n<code>func PackageExports(pkg *Package) bool</code>\n<p>\nPackageExports trims the AST for a Go package in place such that only\nexported nodes remain. The pkg.Files list is not changed, so that file\nnames and top-level package comments don&#39;t get lost.\n</p>\n<p>\nPackageExports returns true if there is an exported declaration; it\nreturns false otherwise.\n</p>\n\n",name:"PackageExports"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Print!\">Print</a></h2>\n<code>func Print(fset *token.FileSet, x interface{}) (int, os.Error)</code>\n<p>\nPrint prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n</p>\n\n",name:"Print"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Walk!\">Walk</a></h2>\n<code>func Walk(v Visitor, node Node)</code>\n<p>\nWalk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n</p>\n\n",name:"Walk"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ObjKind!\">ObjKind</a></h2>\n<pre>const (\n\tBad ObjKind = iota // for error handling\n\tPkg                // package\n\tCon                // constant\n\tTyp                // type\n\tVar                // variable\n\tFun                // function or method\n\tLbl                // label\n)</pre>\n<p>\nThe list of possible Object kinds.\n</p>\n\n",names:["Bad","Pkg","Con","Typ","Var","Fun","Lbl"],type:"ObjKind"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\n<pre>const (\n\tSEND ChanDir = 1 &lt;&lt; iota\n\tRECV\n)</pre>\n\n",names:["SEND","RECV"],type:"ChanDir"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:MergeMode!\">MergeMode</a></h2>\n<pre>const (\n\t// If set, duplicate function declarations are excluded.\n\tFilterFuncDuplicates MergeMode = 1 &lt;&lt; iota\n\t// If set, comments that are not associated with a specific\n\t// AST node (as Doc or Comment) are excluded.\n\tFilterUnassociatedComments\n)</pre>\n\n",names:["FilterFuncDuplicates","FilterUnassociatedComments"],type:"MergeMode"}],vars:[]}