var gortfmData = {index:"index.html",html:"<p>\nThis package implements RC4 encryption, as defined in Bruce Schneier&#39;s\nApplied Cryptography.\n</p>\n",name:"rc4",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cipher!\">Cipher</a></h2>\n<pre>type Cipher struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Cipher is an instance of RC4 using a particular key.\n</p>\n\n",name:"Cipher","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Cipher\">func (*Cipher)</a> <a href=\"?m:Cipher.Reset!\">Reset</a></h2>\n<code>func (c *Cipher) Reset()</code>\n<p>\nReset zeros the key data so that it will no longer appear in the\nprocess&#39;s memory.\n</p>\n\n",name:"Reset"},{html:"\n<h2><a class=\"black\" href=\"?m:Cipher\">func (*Cipher)</a> <a href=\"?m:Cipher.XORKeyStream!\">XORKeyStream</a></h2>\n<code>func (c *Cipher) XORKeyStream(dst, src []byte)</code>\n<p>\nXORKeyStream sets dst to the result of XORing src with the key stream.\nDst and src may be the same slice but otherwise should not overlap.\n</p>\n\n",name:"XORKeyStream"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeySizeError!\">KeySizeError</a></h2>\n<pre>type KeySizeError int</pre>\n\n",name:"KeySizeError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:KeySizeError\">func (KeySizeError)</a> <a href=\"?m:KeySizeError.String!\">String</a></h2>\n<code>func (k KeySizeError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCipher!\">NewCipher</a></h2>\n<code>func NewCipher(key []byte) (*Cipher, os.Error)</code>\n<p>\nNewCipher creates and returns a new Cipher.  The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n</p>\n\n",name:"NewCipher"}],consts:[],vars:[]}