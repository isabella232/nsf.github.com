var gortfmData = {index:"index.html",html:"<p>\nThis package partially implements the TLS 1.1 protocol, as specified in RFC 4346.\n</p>\n",name:"tls",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CASet!\">CASet</a></h2>\n<pre>type CASet struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA CASet is a set of certificates.\n</p>\n\n",name:"CASet","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CASet\">func (*CASet)</a> <a href=\"?m:CASet.FindParent!\">FindParent</a></h2>\n<code>func (s *CASet) FindParent(cert *x509.Certificate) (parent *x509.Certificate)</code>\n<p>\nFindParent attempts to find the certificate in s which signs the given\ncertificate. If no such certificate can be found, it returns nil.\n</p>\n\n",name:"FindParent"},{html:"\n<h2><a class=\"black\" href=\"?m:CASet\">func (*CASet)</a> <a href=\"?m:CASet.SetFromPEM!\">SetFromPEM</a></h2>\n<code>func (s *CASet) SetFromPEM(pemCerts []byte) (ok bool)</code>\n<p>\nSetFromPEM attempts to parse a series of PEM encoded root certificates. It\nappends any certificates found to s and returns true if any certificates\nwere successfully parsed. On many Linux systems, /etc/ssl/cert.pem will\ncontains the system wide set of root CAs in a format suitable for this\nfunction.\n</p>\n\n",name:"SetFromPEM"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Certificate!\">Certificate</a></h2>\n<pre>type Certificate struct {\n\t// Certificate contains a chain of one or more certificates. Leaf\n\t// certificate first.\n\tCertificate [][]byte\n\tPrivateKey  *rsa.PrivateKey\n}</pre>\n\n",name:"Certificate","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\n<pre>type Config struct {\n\t// Rand provides the source of entropy for nonces and RSA blinding.\n\tRand io.Reader\n\t// Time returns the current time as the number of seconds since the epoch.\n\tTime func() int64\n\t// Certificates contains one or more certificate chains.\n\tCertificates []Certificate\n\tRootCAs      *CASet\n\t// NextProtos is a list of supported, application level protocols.\n\t// Currently only server-side handling is supported.\n\tNextProtos []string\n\t// ServerName is included in the client&#39;s handshake to support virtual\n\t// hosting.\n\tServerName string\n\t// AuthenticateClient determines if a server will request a certificate\n\t// from the client. It does not require that the client send a\n\t// certificate nor, if it does, that the certificate is anything more\n\t// than self-signed.\n\tAuthenticateClient bool\n}</pre>\n<p>\nA Config structure is used to configure a TLS client or server. After one\nhas been passed to a TLS function it must not be modified.\n</p>\n\n",name:"Config","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\n<pre>type Conn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Conn represents a secured connection.\nIt implements the net.Conn interface.\n</p>\n\n",name:"Conn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Close!\">Close</a></h2>\n<code>func (c *Conn) Close() os.Error</code>\n<p>\nClose closes the connection.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.ConnectionState!\">ConnectionState</a></h2>\n<code>func (c *Conn) ConnectionState() ConnectionState</code>\n<p>\nConnectionState returns basic TLS details about the connection.\n</p>\n\n",name:"ConnectionState"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Handshake!\">Handshake</a></h2>\n<code>func (c *Conn) Handshake() os.Error</code>\n<p>\nHandshake runs the client or server handshake\nprotocol if it has not yet been run.\nMost uses of this package need not call Handshake\nexplicitly: the first Read or Write will call it automatically.\n</p>\n\n",name:"Handshake"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (c *Conn) LocalAddr() net.Addr</code>\n<p>\nLocalAddr returns the local network address.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.OCSPResponse!\">OCSPResponse</a></h2>\n<code>func (c *Conn) OCSPResponse() []byte</code>\n<p>\nOCSPResponse returns the stapled OCSP response from the TLS server, if\nany. (Only valid for client connections.)\n</p>\n\n",name:"OCSPResponse"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.PeerCertificates!\">PeerCertificates</a></h2>\n<code>func (c *Conn) PeerCertificates() []*x509.Certificate</code>\n<p>\nPeerCertificates returns the certificate chain that was presented by the\nother side.\n</p>\n\n",name:"PeerCertificates"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Read!\">Read</a></h2>\n<code>func (c *Conn) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead can be made to time out and return err == os.EAGAIN\nafter a fixed time limit; see SetTimeout and SetReadTimeout.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (c *Conn) RemoteAddr() net.Addr</code>\n<p>\nRemoteAddr returns the remote network address.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (c *Conn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout sets the time (in nanoseconds) that\nRead will wait for data before returning os.EAGAIN.\nSetting nsec == 0 (the default) disables the deadline.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (c *Conn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout sets the read deadline associated with the connection.\nThere is no write deadline.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (c *Conn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWriteTimeout exists to satisfy the net.Conn interface\nbut is not implemented by TLS.  It always returns an error.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.VerifyHostname!\">VerifyHostname</a></h2>\n<code>func (c *Conn) VerifyHostname(host string) os.Error</code>\n<p>\nVerifyHostname checks that the peer certificate chain is valid for\nconnecting to host.  If so, it returns nil; if not, it returns an os.Error\ndescribing the problem.\n</p>\n\n",name:"VerifyHostname"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Write!\">Write</a></h2>\n<code>func (c *Conn) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite writes data to the connection.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ConnectionState!\">ConnectionState</a></h2>\n<pre>type ConnectionState struct {\n\tHandshakeComplete  bool\n\tCipherSuite        uint16\n\tNegotiatedProtocol string\n}</pre>\n\n",name:"ConnectionState","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Listener!\">Listener</a></h2>\n<pre>type Listener struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"Listener","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Accept!\">Accept</a></h2>\n<code>func (l *Listener) Accept() (c net.Conn, err os.Error)</code>\n\n",name:"Accept"},{html:"\n<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Addr!\">Addr</a></h2>\n<code>func (l *Listener) Addr() net.Addr</code>\n\n",name:"Addr"},{html:"\n<h2><a class=\"black\" href=\"?m:Listener\">func (*Listener)</a> <a href=\"?m:Listener.Close!\">Close</a></h2>\n<code>func (l *Listener) Close() os.Error</code>\n\n",name:"Close"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Client!\">Client</a></h2>\n<code>func Client(conn net.Conn, config *Config) *Conn</code>\n\n",name:"Client"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\n<code>func Dial(network, laddr, raddr string) (net.Conn, os.Error)</code>\n\n",name:"Dial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Listen!\">Listen</a></h2>\n<code>func Listen(network, laddr string, config *Config) (net.Listener, os.Error)</code>\n\n",name:"Listen"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LoadX509KeyPair!\">LoadX509KeyPair</a></h2>\n<code>func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.Error)</code>\n<p>\nLoadX509KeyPair reads and parses a public/private key pair from a pair of\nfiles. The files must contain PEM encoded data.\n</p>\n\n",name:"LoadX509KeyPair"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCASet!\">NewCASet</a></h2>\n<code>func NewCASet() *CASet</code>\n\n",name:"NewCASet"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewListener!\">NewListener</a></h2>\n<code>func NewListener(listener net.Listener, config *Config) (l *Listener)</code>\n<p>\nNewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must have\nat least one certificate.\n</p>\n\n",name:"NewListener"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Server!\">Server</a></h2>\n<code>func Server(conn net.Conn, config *Config) *Conn</code>\n\n",name:"Server"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TLS_RSA_WITH_RC4_128_SHA!\">TLS_RSA_WITH_RC4_128_SHA</a></h2>\n<pre>const (\n\tTLS_RSA_WITH_RC4_128_SHA uint16 = 5\n)</pre>\n<p>\nTLS cipher suites.\n</p>\n\n",names:["TLS_RSA_WITH_RC4_128_SHA"],type:""}],vars:[]}