var gortfmData = {index:"index.html",html:"<p>\nPackage spdy is an incomplete implementation of the SPDY protocol.\n</p>\n<p>\nThe implementation follows draft 2 of the spec:\n<a href=\"https://sites.google.com/a/chromium.org/dev/spdy/spdy-protocol/spdy-protocol-draft2\">https://sites.google.com/a/chromium.org/dev/spdy/spdy-protocol/spdy-protocol-draft2</a>\n</p>\n",name:"spdy",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ControlFrameType!\">ControlFrameType</a></h2>\n<pre>type ControlFrameType uint16</pre>\n<p>\nControlFrameType stores the type field in a control frame header.\n</p>\n\n",name:"ControlFrameType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ControlFrameType\">func (ControlFrameType)</a> <a href=\"?m:ControlFrameType.String!\">String</a></h2>\n<code>func (t ControlFrameType) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Frame!\">Frame</a></h2>\n<pre>type Frame struct {\n\tHeader [4]byte\n\tFlags  FrameFlags\n\tData   []byte\n}</pre>\n<p>\nA Frame is a framed message as sent between clients and servers.\nThere are two types of frames: control frames and data frames.\n</p>\n\n",name:"Frame","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (Frame)</a> <a href=\"?m:Frame.IsControl!\">IsControl</a></h2>\n<code>func (f Frame) IsControl() bool</code>\n<p>\nIsControl returns whether the frame holds a control frame.\n</p>\n\n",name:"IsControl"},{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (Frame)</a> <a href=\"?m:Frame.StreamId!\">StreamId</a></h2>\n<code>func (f Frame) StreamId() (id uint32)</code>\n<p>\nStreamId returns the stream ID field if the frame is a data frame, otherwise it returns zero.\n</p>\n\n",name:"StreamId"},{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (Frame)</a> <a href=\"?m:Frame.Type!\">Type</a></h2>\n<code>func (f Frame) Type() ControlFrameType</code>\n<p>\nType obtains the type field if the frame is a control frame, otherwise it returns zero.\n</p>\n\n",name:"Type"},{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (Frame)</a> <a href=\"?m:Frame.WriteTo!\">WriteTo</a></h2>\n<code>func (f Frame) WriteTo(w io.Writer) (n int64, err os.Error)</code>\n<p>\nWriteTo writes the frame in the SPDY format.\n</p>\n\n",name:"WriteTo"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FrameFlags!\">FrameFlags</a></h2>\n<pre>type FrameFlags uint8</pre>\n\n",name:"FrameFlags","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HeaderReader!\">HeaderReader</a></h2>\n<pre>type HeaderReader struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA HeaderReader reads zlib-compressed headers.\n</p>\n\n",name:"HeaderReader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HeaderReader\">func (*HeaderReader)</a> <a href=\"?m:HeaderReader.Decode!\">Decode</a></h2>\n<code>func (hr *HeaderReader) Decode(data []byte) (h http.Header, err os.Error)</code>\n<p>\nDecode reads a set of headers from a block of bytes.\n</p>\n\n",name:"Decode"},{html:"\n<h2><a class=\"black\" href=\"?m:HeaderReader\">func (*HeaderReader)</a> <a href=\"?m:HeaderReader.ReadHeader!\">ReadHeader</a></h2>\n<code>func (hr *HeaderReader) ReadHeader(r io.Reader) (h http.Header, err os.Error)</code>\n<p>\nReadHeader reads a set of headers from a reader.\n</p>\n\n",name:"ReadHeader"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HeaderWriter!\">HeaderWriter</a></h2>\n<pre>type HeaderWriter struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nHeaderWriter will write zlib-compressed headers on different streams.\n</p>\n\n",name:"HeaderWriter","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HeaderWriter\">func (*HeaderWriter)</a> <a href=\"?m:HeaderWriter.Encode!\">Encode</a></h2>\n<code>func (hw *HeaderWriter) Encode(h http.Header) (data []byte)</code>\n<p>\nEncode returns a compressed header block.\n</p>\n\n",name:"Encode"},{html:"\n<h2><a class=\"black\" href=\"?m:HeaderWriter\">func (*HeaderWriter)</a> <a href=\"?m:HeaderWriter.WriteHeader!\">WriteHeader</a></h2>\n<code>func (hw *HeaderWriter) WriteHeader(w io.Writer, h http.Header) (err os.Error)</code>\n<p>\nWriteHeader writes a header block directly to an output.\n</p>\n\n",name:"WriteHeader"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ControlFrame!\">ControlFrame</a></h2>\n<code>func ControlFrame(t ControlFrameType, f FrameFlags, data []byte) Frame</code>\n<p>\nControlFrame creates a control frame with the given information.\n</p>\n\n",name:"ControlFrame"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DataFrame!\">DataFrame</a></h2>\n<code>func DataFrame(streamId uint32, f FrameFlags, data []byte) Frame</code>\n<p>\nDataFrame creates a data frame with the given information.\n</p>\n\n",name:"DataFrame"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewHeaderReader!\">NewHeaderReader</a></h2>\n<code>func NewHeaderReader() (hr *HeaderReader)</code>\n<p>\nNewHeaderReader creates a HeaderReader with the initial dictionary.\n</p>\n\n",name:"NewHeaderReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewHeaderWriter!\">NewHeaderWriter</a></h2>\n<code>func NewHeaderWriter(level int) (hw *HeaderWriter)</code>\n<p>\nNewHeaderWriter creates a HeaderWriter ready to compress headers.\n</p>\n\n",name:"NewHeaderWriter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadFrame!\">ReadFrame</a></h2>\n<code>func ReadFrame(r io.Reader) (f Frame, err os.Error)</code>\n<p>\nReadFrame reads an entire frame into memory.\n</p>\n\n",name:"ReadFrame"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Version!\">Version</a></h2>\n<pre>const Version = 2</pre>\n<p>\nVersion is the protocol version number that this package implements.\n</p>\n\n",names:["Version"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ControlFrameType!\">ControlFrameType</a></h2>\n<pre>const (\n\tTypeSynStream    ControlFrameType = 0x0001\n\tTypeSynReply                      = 0x0002\n\tTypeRstStream                     = 0x0003\n\tTypeSettings                      = 0x0004\n\tTypeNoop                          = 0x0005\n\tTypePing                          = 0x0006\n\tTypeGoaway                        = 0x0007\n\tTypeHeaders                       = 0x0008\n\tTypeWindowUpdate                  = 0x0009\n)</pre>\n<p>\nControl frame type constants\n</p>\n\n",names:["TypeSynStream","TypeSynReply","TypeRstStream","TypeSettings","TypeNoop","TypePing","TypeGoaway","TypeHeaders","TypeWindowUpdate"],type:"ControlFrameType"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:FrameFlags!\">FrameFlags</a></h2>\n<pre>const (\n\tFlagFin            FrameFlags = 0x01\n\tFlagUnidirectional            = 0x02\n)</pre>\n<p>\nStream frame flags\n</p>\n\n",names:["FlagFin","FlagUnidirectional"],type:"FrameFlags"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:FrameFlags!\">FlagClearPreviouslyPersistedSettings</a></h2>\n<pre>const (\n\tFlagClearPreviouslyPersistedSettings FrameFlags = 0x01\n)</pre>\n<p>\nSETTINGS frame flags\n</p>\n\n",names:["FlagClearPreviouslyPersistedSettings"],type:"FrameFlags"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:MaxDataLength!\">MaxDataLength</a></h2>\n<pre>const MaxDataLength = 1&lt;&lt;24 - 1</pre>\n<p>\nMaxDataLength is the maximum number of bytes that can be stored in one frame.\n</p>\n\n",names:["MaxDataLength"],type:""}],vars:[]}