var gortfmData = {index:"index.html",html:"<p>\nPackage pem implements the PEM data encoding, which originated in Privacy\nEnhanced Mail. The most common use of PEM encoding today is in TLS keys and\ncertificates. See RFC 1421.\n</p>\n",name:"pem",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Block!\">Block</a></h2>\n<pre>type Block struct {\n\tType    string            // The type, taken from the preamble (i.e. &#34;RSA PRIVATE KEY&#34;).\n\tHeaders map[string]string // Optional headers.\n\tBytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}</pre>\n<p>\nA Block represents a PEM encoded structure.\n</p>\n<p>\nThe encoded form is:\n</p>\n<pre>-----BEGIN Type-----\nHeaders\nbase64-encoded Bytes\n-----END Type-----\n</pre>\n<p>\nwhere Headers is a possibly empty sequence of Key: Value lines.\n</p>\n\n",name:"Block","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Decode!\">Decode</a></h2>\n<code>func Decode(data []byte) (p *Block, rest []byte)</code>\n<p>\nDecode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n</p>\n\n",name:"Decode"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Encode!\">Encode</a></h2>\n<code>func Encode(out io.Writer, b *Block) (err os.Error)</code>\n\n",name:"Encode"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodeToMemory!\">EncodeToMemory</a></h2>\n<code>func EncodeToMemory(b *Block) []byte</code>\n\n",name:"EncodeToMemory"}],consts:[],vars:[]}