var gortfmData = {index:"index.html",html:"<p>\nINCOMPLETE PACKAGE.\nThis package implements typechecking of a Go AST.\nThe result of the typecheck is an augmented AST\nwith object and type information for each identifier.\n</p>\n",name:"typechecker",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Form!\">Form</a></h2>\n<pre>type Form int</pre>\n<p>\nForm describes the form of a type.\n</p>\n\n",name:"Form","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Form\">func (Form)</a> <a href=\"?m:Form.String!\">String</a></h2>\n<code>func (form Form) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Importer!\">Importer</a></h2>\n<pre>type Importer func(path string) ([]byte, os.Error)</pre>\n<p>\nAn importer takes an import path and returns the data describing the\nrespective package&#39;s exported interface. The data format is TBD.\n</p>\n\n",name:"Importer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type struct {\n\tForm     Form\n\tObj      *ast.Object // corresponding type name, or nil\n\tScope    *ast.Scope  // fields and methods, always present\n\tN        uint        // basic type id, array length, number of function results, or channel direction\n\tKey, Elt *Type       // map key and array, pointer, slice, map or channel element\n\tParams   *ast.Scope  // function (receiver, input and result) parameters, tuple expressions (results of function calls), or nil\n\tExpr     ast.Expr    // corresponding AST expression\n}</pre>\n<p>\nA Type represents a Go type.\n</p>\n\n",name:"Type","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckFile!\">CheckFile</a></h2>\n<code>func CheckFile(fset *token.FileSet, file *ast.File, importer Importer) os.Error</code>\n<p>\nCheckFile typechecks a single file, but otherwise behaves like\nCheckPackage. If the complete package consists of more than just\none file, the file may not typecheck without errors.\n</p>\n\n",name:"CheckFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckPackage!\">CheckPackage</a></h2>\n<code>func CheckPackage(fset *token.FileSet, pkg *ast.Package, importer Importer) os.Error</code>\n<p>\nCheckPackage typechecks a package and augments the AST by setting\n*ast.Object, *ast.Type, and *ast.Scope fields accordingly. If an\nimporter is provided, it is used to handle imports, otherwise they\nare ignored (likely leading to typechecking errors).\n</p>\n<p>\nIf errors are reported, the AST may be incompletely augmented (fields\nmay be nil) or contain incomplete object, type, or scope information.\n</p>\n\n",name:"CheckPackage"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewType!\">NewType</a></h2>\n<code>func NewType(form Form) *Type</code>\n<p>\nNewType creates a new type of a given form.\n</p>\n\n",name:"NewType"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Form!\">Form</a></h2>\n<pre>const (\n\tBadType    Form = iota // for error handling\n\tUnresolved             // type not fully setup\n\tBasic\n\tArray\n\tStruct\n\tPointer\n\tFunction\n\tMethod\n\tInterface\n\tSlice\n\tMap\n\tChannel\n\tTuple\n)</pre>\n<p>\nThe list of possible type forms.\n</p>\n\n",names:["BadType","Unresolved","Basic","Array","Struct","Pointer","Function","Method","Interface","Slice","Map","Channel","Tuple"],type:"Form"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Bool!\"><em>group</em></a></h2>\n<pre>const (\n\tBool = iota\n\tByte\n\tUint\n\tInt\n\tFloat\n\tComplex\n\tUintptr\n\tString\n\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\n\tFloat32\n\tFloat64\n\n\tComplex64\n\tComplex128\n)</pre>\n<p>\nThe list of basic type id&#39;s.\n</p>\n\n",names:["Bool","Byte","Uint","Int","Float","Complex","Uintptr","String","Uint8","Uint16","Uint32","Uint64","Int8","Int16","Int32","Int64","Float32","Float64","Complex64","Complex128"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:BasicTypes!\">BasicTypes</a></h2>\n<pre>var BasicTypes = map[uint]string{\n\tBool:    &#34;bool&#34;,\n\tByte:    &#34;byte&#34;,\n\tUint:    &#34;uint&#34;,\n\tInt:     &#34;int&#34;,\n\tFloat:   &#34;float&#34;,\n\tComplex: &#34;complex&#34;,\n\tUintptr: &#34;uintptr&#34;,\n\tString:  &#34;string&#34;,\n\n\tUint8:  &#34;uint8&#34;,\n\tUint16: &#34;uint16&#34;,\n\tUint32: &#34;uint32&#34;,\n\tUint64: &#34;uint64&#34;,\n\n\tInt8:  &#34;int8&#34;,\n\tInt16: &#34;int16&#34;,\n\tInt32: &#34;int32&#34;,\n\tInt64: &#34;int64&#34;,\n\n\tFloat32: &#34;float32&#34;,\n\tFloat64: &#34;float64&#34;,\n\n\tComplex64:  &#34;complex64&#34;,\n\tComplex128: &#34;complex128&#34;,\n}</pre>\n\n",names:["BasicTypes"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Universe!\">Universe</a></h2>\n<pre>var Universe *ast.Scope</pre>\n<p>\nThe Universe scope contains all predeclared identifiers.\n</p>\n\n",names:["Universe"],type:""}]}