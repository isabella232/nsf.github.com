var gortfmData = {index:"index.html",html:"<p>\nThe runtime package contains operations that interact with Go&#39;s runtime system,\nsuch as functions to control goroutines. It also includes the low-level type information\nused by the reflect package; see reflect&#39;s documentation for the programmable\ninterface to the run-time type system.\n</p>\n",name:"runtime",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\n<pre>type ArrayType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nArrayType represents a fixed array type.\n</p>\n\n",name:"ArrayType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolType!\">BoolType</a></h2>\n<pre>type BoolType commonType</pre>\n<p>\nBoolType represents a boolean type.\n</p>\n\n",name:"BoolType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\n<pre>type ChanDir int</pre>\n<p>\nChanDir represents a channel type&#39;s direction.\n</p>\n\n",name:"ChanDir","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\n<pre>type ChanType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nChanType represents a channel type.\n</p>\n\n",name:"ChanType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexType!\">ComplexType</a></h2>\n<pre>type ComplexType commonType</pre>\n<p>\nComplexType represents a complex type.\n</p>\n\n",name:"ComplexType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\n<pre>type Error interface {\n\tString() string\n\n\t// RuntimeError is a no-op function but\n\t// serves to distinguish types that are runtime\n\t// errors from ordinary os.Errors: a type is a\n\t// runtime error if it has a RuntimeError method.\n\tRuntimeError()\n}</pre>\n<p>\nThe Error interface identifies a run time error.\n</p>\n\n",name:"Error","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatType!\">FloatType</a></h2>\n<pre>type FloatType commonType</pre>\n<p>\nFloatType represents a float type.\n</p>\n\n",name:"FloatType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Func!\">Func</a></h2>\n<pre>type Func struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"Func","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.Entry!\">Entry</a></h2>\n<code>func (f *Func) Entry() uintptr</code>\n<p>\nEntry returns the entry address of the function.\n</p>\n\n",name:"Entry"},{html:"\n<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.FileLine!\">FileLine</a></h2>\n<code>func (f *Func) FileLine(pc uintptr) (file string, line int)</code>\n<p>\nFileLine returns the file name and line number of the\nsource code corresponding to the program counter pc.\nThe result will not be accurate if pc is not a program\ncounter within f.\n</p>\n\n",name:"FileLine"},{html:"\n<h2><a class=\"black\" href=\"?m:Func\">func (*Func)</a> <a href=\"?m:Func.Name!\">Name</a></h2>\n<code>func (f *Func) Name() string</code>\n<p>\nName returns the name of the function.\n</p>\n\n",name:"Name"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\n<pre>type FuncType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nFuncType represents a function type.\n</p>\n\n",name:"FuncType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntType!\">IntType</a></h2>\n<pre>type IntType commonType</pre>\n<p>\nIntType represents an int type.\n</p>\n\n",name:"IntType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\n<pre>type InterfaceType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nInterfaceType represents an interface type.\n</p>\n\n",name:"InterfaceType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Itable!\">Itable</a></h2>\n<pre>type Itable struct {\n\tItype *Type // (*tab.inter).(*InterfaceType) is the interface type\n\tType  *Type\n\n\tFn [100000]uintptr // bigger than we&#39;ll ever see\n\t// contains unexported fields\n}</pre>\n<p>\n* Must match iface.c:/Itab and compilers.\n* NOTE: this is the version used by the reflection code, there is another\n* one in iface_defs.go that is closer to the original C version.\n</p>\n\n",name:"Itable","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\n<pre>type MapType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nMapType represents a map type.\n</p>\n\n",name:"MapType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MemProfileRecord!\">MemProfileRecord</a></h2>\n<pre>type MemProfileRecord struct {\n\tAllocBytes, FreeBytes     int64       // number of bytes allocated, freed\n\tAllocObjects, FreeObjects int64       // number of objects allocated, freed\n\tStack0                    [32]uintptr // stack trace for this record; ends at first 0 entry\n}</pre>\n<p>\nA MemProfileRecord describes the live objects allocated\nby a particular call sequence (stack trace).\n</p>\n\n",name:"MemProfileRecord","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.InUseBytes!\">InUseBytes</a></h2>\n<code>func (r *MemProfileRecord) InUseBytes() int64</code>\n<p>\nInUseBytes returns the number of bytes in use (AllocBytes - FreeBytes).\n</p>\n\n",name:"InUseBytes"},{html:"\n<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.InUseObjects!\">InUseObjects</a></h2>\n<code>func (r *MemProfileRecord) InUseObjects() int64</code>\n<p>\nInUseObjects returns the number of objects in use (AllocObjects - FreeObjects).\n</p>\n\n",name:"InUseObjects"},{html:"\n<h2><a class=\"black\" href=\"?m:MemProfileRecord\">func (*MemProfileRecord)</a> <a href=\"?m:MemProfileRecord.Stack!\">Stack</a></h2>\n<code>func (r *MemProfileRecord) Stack() []uintptr</code>\n<p>\nStack returns the stack trace associated with the record,\na prefix of r.Stack0.\n</p>\n\n",name:"Stack"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MemStatsType!\">MemStatsType</a></h2>\n<pre>type MemStatsType struct {\n\t// General statistics.\n\t// Not locked during update; approximate.\n\tAlloc      uint64 // bytes allocated and still in use\n\tTotalAlloc uint64 // bytes allocated (even if freed)\n\tSys        uint64 // bytes obtained from system (should be sum of XxxSys below)\n\tLookups    uint64 // number of pointer lookups\n\tMallocs    uint64 // number of mallocs\n\tFrees      uint64 // number of frees\n\n\n\t// Main allocation heap statistics.\n\tHeapAlloc   uint64 // bytes allocated and still in use\n\tHeapSys     uint64 // bytes obtained from system\n\tHeapIdle    uint64 // bytes in idle spans\n\tHeapInuse   uint64 // bytes in non-idle span\n\tHeapObjects uint64 // total number of allocated objects\n\n\n\t// Low-level fixed-size structure allocator statistics.\n\t//\tInuse is bytes used now.\n\t//\tSys is bytes obtained from system.\n\tStackInuse  uint64 // bootstrap stacks\n\tStackSys    uint64\n\tMSpanInuse  uint64 // mspan structures\n\tMSpanSys    uint64\n\tMCacheInuse uint64 // mcache structures\n\tMCacheSys   uint64\n\tBuckHashSys uint64 // profiling bucket hash table\n\n\n\t// Garbage collector statistics.\n\tNextGC       uint64\n\tPauseTotalNs uint64\n\tPauseNs      [256]uint64 // most recent GC pause times\n\tNumGC        uint32\n\tEnableGC     bool\n\tDebugGC      bool\n\n\t// Per-size allocation statistics.\n\t// Not locked during update; approximate.\n\t// 61 is NumSizeClasses in the C code.\n\tBySize [61]struct {\n\t\tSize    uint32\n\t\tMallocs uint64\n\t\tFrees   uint64\n\t}\n}</pre>\n\n",name:"MemStatsType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrType!\">PtrType</a></h2>\n<pre>type PtrType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nPtrType represents a pointer type.\n</p>\n\n",name:"PtrType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceType!\">SliceType</a></h2>\n<pre>type SliceType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nSliceType represents a slice type.\n</p>\n\n",name:"SliceType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringType!\">StringType</a></h2>\n<pre>type StringType commonType</pre>\n<p>\nStringType represents a string type.\n</p>\n\n",name:"StringType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\n<pre>type StructType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nStructType represents a struct type.\n</p>\n\n",name:"StructType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type interface{}</pre>\n<p>\nThe compiler can only construct empty interface values at\ncompile time; non-empty interface values get created\nduring initialization.  Type is an empty interface\nso that the compiler can lay out references as data.\n</p>\n\n",name:"Type","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TypeAssertionError!\">TypeAssertionError</a></h2>\n<pre>type TypeAssertionError struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA TypeAssertionError explains a failed type assertion.\n</p>\n\n",name:"TypeAssertionError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.Asserted!\">Asserted</a></h2>\n<code>func (e *TypeAssertionError) Asserted() Type</code>\n<p>\nAsserted returns the type incorrectly asserted by the type assertion.\n</p>\n\n",name:"Asserted"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.Concrete!\">Concrete</a></h2>\n<code>func (e *TypeAssertionError) Concrete() Type</code>\n<p>\nConcrete returns the type of the concrete value in the failed type assertion.\nIf the interface value was nil, Concrete returns nil.\n</p>\n\n",name:"Concrete"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.MissingMethod!\">MissingMethod</a></h2>\n<code>func (e *TypeAssertionError) MissingMethod() string</code>\n<p>\nIf the type assertion is to an interface type, MissingMethod returns the\nname of a method needed to satisfy that interface type but not implemented\nby Concrete.  If there are multiple such methods,\nMissingMethod returns one; which one is unspecified.\nIf the type assertion is not to an interface type, MissingMethod returns an empty string.\n</p>\n\n",name:"MissingMethod"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.RuntimeError!\">RuntimeError</a></h2>\n<code>func (*TypeAssertionError) RuntimeError()</code>\n\n",name:"RuntimeError"},{html:"\n<h2><a class=\"black\" href=\"?m:TypeAssertionError\">func (*TypeAssertionError)</a> <a href=\"?m:TypeAssertionError.String!\">String</a></h2>\n<code>func (e *TypeAssertionError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintType!\">UintType</a></h2>\n<pre>type UintType commonType</pre>\n<p>\nUintType represents a uint type.\n</p>\n\n",name:"UintType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintptrType!\">UintptrType</a></h2>\n<pre>type UintptrType commonType</pre>\n<p>\nUintptrType represents a uintptr type.\n</p>\n\n",name:"UintptrType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerType!\">UnsafePointerType</a></h2>\n<pre>type UnsafePointerType commonType</pre>\n<p>\nUnsafePointerType represents an unsafe.Pointer type.\n</p>\n\n",name:"UnsafePointerType","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Alloc!\">Alloc</a></h2>\n<code>func Alloc(uintptr) *byte</code>\n<p>\nAlloc allocates a block of the given size.\nFOR TESTING AND DEBUGGING ONLY.\n</p>\n\n",name:"Alloc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Breakpoint!\">Breakpoint</a></h2>\n<code>func Breakpoint()</code>\n<p>\nBreakpoint() executes a breakpoint trap.\n</p>\n\n",name:"Breakpoint"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CPUProfile!\">CPUProfile</a></h2>\n<code>func CPUProfile() []byte</code>\n<p>\nCPUProfile returns the next chunk of binary CPU profiling stack trace data,\nblocking until data is available.  If profiling is turned off and all the profile\ndata accumulated while it was on has been returned, CPUProfile returns nil.\nThe caller must save the returned data before calling CPUProfile again.\nMost clients should use the runtime/pprof package or\nthe testing package&#39;s -test.cpuprofile flag instead of calling\nCPUProfile directly.\n</p>\n\n",name:"CPUProfile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Caller!\">Caller</a></h2>\n<code>func Caller(skip int) (pc uintptr, file string, line int, ok bool)</code>\n<p>\nCaller reports file and line number information about function invocations on\nthe calling goroutine&#39;s stack.  The argument skip is the number of stack frames to\nascend, with 0 identifying the the caller of Caller.  The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall.  The boolean ok is false if it was not possible to recover the information.\n</p>\n\n",name:"Caller"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Callers!\">Callers</a></h2>\n<code>func Callers(skip int, pc []uintptr) int</code>\n<p>\nCallers fills the slice pc with the program counters of function invocations\non the calling goroutine&#39;s stack.  The argument skip is the number of stack frames\nto skip before recording in pc, with 0 starting at the caller of Caller.\nIt returns the number of entries written to pc.\n</p>\n\n",name:"Callers"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Cgocalls!\">Cgocalls</a></h2>\n<code>func Cgocalls() int64</code>\n<p>\nCgocalls returns the number of cgo calls made by the current process.\n</p>\n\n",name:"Cgocalls"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Free!\">Free</a></h2>\n<code>func Free(*byte)</code>\n<p>\nFree frees the block starting at the given pointer.\nFOR TESTING AND DEBUGGING ONLY.\n</p>\n\n",name:"Free"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FuncForPC!\">FuncForPC</a></h2>\n<code>func FuncForPC(pc uintptr) *Func</code>\n<p>\nFuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n</p>\n\n",name:"FuncForPC"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GC!\">GC</a></h2>\n<code>func GC()</code>\n<p>\nGC runs a garbage collection.\n</p>\n\n",name:"GC"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GOMAXPROCS!\">GOMAXPROCS</a></h2>\n<code>func GOMAXPROCS(n int) int</code>\n<p>\nGOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting.  If n &lt; 1, it does not\nchange the current setting.\nThis call will go away when the scheduler improves.\n</p>\n\n",name:"GOMAXPROCS"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GOROOT!\">GOROOT</a></h2>\n<code>func GOROOT() string</code>\n<p>\nGOROOT returns the root of the Go tree.\nIt uses the GOROOT environment variable, if set,\nor else the root used during the Go build.\n</p>\n\n",name:"GOROOT"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Goexit!\">Goexit</a></h2>\n<code>func Goexit()</code>\n<p>\nGoexit terminates the goroutine that calls it.  No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine.\n</p>\n\n",name:"Goexit"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Goroutines!\">Goroutines</a></h2>\n<code>func Goroutines() int32</code>\n<p>\nGoroutines returns the number of goroutines that currently exist.\n</p>\n\n",name:"Goroutines"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Gosched!\">Gosched</a></h2>\n<code>func Gosched()</code>\n<p>\nGosched yields the processor, allowing other goroutines to run.  It does not\nsuspend the current goroutine, so execution resumes automatically.\n</p>\n\n",name:"Gosched"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LockOSThread!\">LockOSThread</a></h2>\n<code>func LockOSThread()</code>\n<p>\nLockOSThread wires the calling goroutine to its current operating system thread.\nUntil the calling goroutine exits or calls UnlockOSThread, it will always\nexecute in that thread, and no other goroutine can.\nLockOSThread cannot be used during init functions.\n</p>\n\n",name:"LockOSThread"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lookup!\">Lookup</a></h2>\n<code>func Lookup(*byte) (*byte, uintptr)</code>\n<p>\nLookup returns the base and size of the block containing the given pointer.\nFOR TESTING AND DEBUGGING ONLY.\n</p>\n\n",name:"Lookup"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MemProfile!\">MemProfile</a></h2>\n<code>func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)</code>\n<p>\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) &gt;= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) &lt; n, MemProfile does not change p and returns n, false.\n</p>\n<p>\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes &gt; 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\nMost clients should use the runtime/pprof package or\nthe testing package&#39;s -test.memprofile flag instead\nof calling MemProfile directly.\n</p>\n\n",name:"MemProfile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Semacquire!\">Semacquire</a></h2>\n<code>func Semacquire(s *uint32)</code>\n<p>\nSemacquire waits until *s &gt; 0 and then atomically decrements it.\nIt is intended as a simple sleep primitive for use by the synchronization\nlibrary and should not be used directly.\n</p>\n\n",name:"Semacquire"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Semrelease!\">Semrelease</a></h2>\n<code>func Semrelease(s *uint32)</code>\n<p>\nSemrelease atomically increments *s and notifies a waiting goroutine\nif one is blocked in Semacquire.\nIt is intended as a simple wakeup primitive for use by the synchronization\nlibrary and should not be used directly.\n</p>\n\n",name:"Semrelease"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SetCPUProfileRate!\">SetCPUProfileRate</a></h2>\n<code>func SetCPUProfileRate(hz int)</code>\n<p>\nSetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz &lt;= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\nMost clients should use the runtime/pprof package or\nthe testing package&#39;s -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n</p>\n\n",name:"SetCPUProfileRate"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SetFinalizer!\">SetFinalizer</a></h2>\n<code>func SetFinalizer(x, f interface{})</code>\n<p>\nSetFinalizer sets the finalizer associated with x to f.\nWhen the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nf(x) in a separate goroutine.  This makes x reachable again, but\nnow without an associated finalizer.  Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat x is unreachable, it will free x.\n</p>\n<p>\nSetFinalizer(x, nil) clears any finalizer associated with x.\n</p>\n<p>\nThe argument x must be a pointer to an object allocated by\ncalling new or by taking the address of a composite literal.\nThe argument f must be a function that takes a single argument\nof x&#39;s type and returns no arguments.  If either of these is not\ntrue, SetFinalizer aborts the program.\n</p>\n<p>\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n</p>\n<p>\nThe finalizer for x is scheduled to run at some arbitrary time after\nx becomes unreachable.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n</p>\n<p>\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n</p>\n<p>\nTODO(rsc): allow f to have (ignored) return values\n</p>\n\n",name:"SetFinalizer"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Siginit!\">Siginit</a></h2>\n<code>func Siginit()</code>\n<p>\nSiginit enables receipt of signals via Sigrecv.  It should typically\nbe called during initialization.\n</p>\n\n",name:"Siginit"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Signame!\">Signame</a></h2>\n<code>func Signame(sig int32) string</code>\n<p>\nSigname returns a string describing the signal, or &#34;&#34; if the signal is unknown.\n</p>\n\n",name:"Signame"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Sigrecv!\">Sigrecv</a></h2>\n<code>func Sigrecv() uint32</code>\n<p>\nSigrecv returns a bitmask of signals that have arrived since the last call to Sigrecv.\nIt blocks until at least one signal arrives.\n</p>\n\n",name:"Sigrecv"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnlockOSThread!\">UnlockOSThread</a></h2>\n<code>func UnlockOSThread()</code>\n<p>\nUnlockOSThread unwires the calling goroutine from its fixed operating system thread.\nIf the calling goroutine has not called LockOSThread, UnlockOSThread is a no-op.\n</p>\n\n",name:"UnlockOSThread"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Version!\">Version</a></h2>\n<code>func Version() string</code>\n<p>\nVersion returns the Go tree&#39;s version string.\nIt is either a sequence number or, when possible,\na release tag like &#34;release.2010-03-04&#34;.\nA trailing + indicates that the tree had local modifications\nat the time of the build.\n</p>\n\n",name:"Version"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\n<pre>const (\n\tRecvDir ChanDir             = 1 &lt;&lt; iota // &lt;-chan\n\tSendDir                                 // chan&lt;-\n\tBothDir = RecvDir | SendDir             // chan\n)</pre>\n\n",names:["RecvDir","SendDir","BothDir"],type:"ChanDir"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GOOS!\">GOOS</a></h2>\n<pre>const GOOS string = theGoos</pre>\n<p>\nGOOS is the Go tree&#39;s operating system target:\none of darwin, freebsd, linux, and so on.\n</p>\n\n",names:["GOOS"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GOARCH!\">GOARCH</a></h2>\n<pre>const GOARCH string = theGoarch</pre>\n<p>\nGOARCH is the Go tree&#39;s architecture target:\n386, amd64, or arm.\n</p>\n\n",names:["GOARCH"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:MemProfileRate!\">MemProfileRate</a></h2>\n<pre>var MemProfileRate int = 512 * 1024</pre>\n<p>\nMemProfileRate controls the fraction of memory allocations\nthat are recorded and reported in the memory profile.\nThe profiler aims to sample an average of\none allocation per MemProfileRate bytes allocated.\n</p>\n<p>\nTo include every allocated block in the profile, set MemProfileRate to 1.\nTo turn off profiling entirely, set MemProfileRate to 0.\n</p>\n<p>\nThe tools that process the memory profiles assume that the\nprofile rate is constant across the lifetime of the program\nand equal to the current value.  Programs that change the\nmemory profiling rate should do so just once, as early as\npossible in the execution of the program (for example,\nat the beginning of main).\n</p>\n\n",names:["MemProfileRate"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:MemStats!\">MemStats</a></h2>\n<pre>var MemStats MemStatsType</pre>\n<p>\nMemStats holds statistics about the memory system.\nThe statistics are only approximate, as they are not interlocked on update.\n</p>\n\n",names:["MemStats"],type:""}]}