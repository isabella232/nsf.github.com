var gortfmData = {index:"index.html",html:"<p>\nThe reflect package implements run-time reflection, allowing a program to\nmanipulate objects with arbitrary types.  The typical use is to take a\nvalue with static type interface{} and extract its dynamic type\ninformation by calling Typeof, which returns an object with interface\ntype Type.  That contains a pointer to a struct of type *StructType,\n*IntType, etc. representing the details of the underlying type.  A type\nswitch or type assertion can reveal which.\n</p>\n<p>\nA call to NewValue creates a Value representing the run-time data; it\ncontains a *StructValue, *IntValue, etc.  MakeZero takes a Type and\nreturns a Value representing a zero value for that type.\n</p>\n",name:"reflect",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayOrSliceType!\">ArrayOrSliceType</a></h2>\n<pre>type ArrayOrSliceType interface {\n\tType\n\tElem() Type\n}</pre>\n<p>\nArrayOrSliceType is the common interface implemented\nby both ArrayType and SliceType.\n</p>\n\n",name:"ArrayOrSliceType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayOrSliceValue!\">ArrayOrSliceValue</a></h2>\n<pre>type ArrayOrSliceValue interface {\n\tValue\n\tLen() int\n\tCap() int\n\tElem(i int) Value\n\t// contains unexported methods\n}</pre>\n<p>\nArrayOrSliceValue is the common interface\nimplemented by both ArrayValue and SliceValue.\n</p>\n\n",name:"ArrayOrSliceValue","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayType!\">ArrayType</a></h2>\n<pre>type ArrayType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nArrayType represents a fixed array type.\n</p>\n\n",name:"ArrayType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Elem!\">Elem</a></h2>\n<code>func (t *ArrayType) Elem() Type</code>\n<p>\nElem returns the type of the array&#39;s elements.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayType\">func (*ArrayType)</a> <a href=\"?m:ArrayType.Len!\">Len</a></h2>\n<code>func (t *ArrayType) Len() int</code>\n<p>\nLen returns the number of elements in the array.\n</p>\n\n",name:"Len"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArrayValue!\">ArrayValue</a></h2>\n<pre>type ArrayValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn ArrayValue represents an array.\n</p>\n\n",name:"ArrayValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Cap!\">Cap</a></h2>\n<code>func (v *ArrayValue) Cap() int</code>\n<p>\nCap returns the capacity of the array (equal to Len()).\n</p>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Elem!\">Elem</a></h2>\n<code>func (v *ArrayValue) Elem(i int) Value</code>\n<p>\nElem returns the i&#39;th element of v.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Len!\">Len</a></h2>\n<code>func (v *ArrayValue) Len() int</code>\n<p>\nLen returns the length of the array.\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.Set!\">Set</a></h2>\n<code>func (v *ArrayValue) Set(x *ArrayValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:ArrayValue\">func (*ArrayValue)</a> <a href=\"?m:ArrayValue.SetValue!\">SetValue</a></h2>\n<code>func (v *ArrayValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolType!\">BoolType</a></h2>\n<pre>type BoolType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nBoolType represents a boolean type.\n</p>\n\n",name:"BoolType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BoolValue!\">BoolValue</a></h2>\n<pre>type BoolValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nBoolValue represents a bool value.\n</p>\n\n",name:"BoolValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.Get!\">Get</a></h2>\n<code>func (v *BoolValue) Get() bool</code>\n<p>\nGet returns the underlying bool value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.Set!\">Set</a></h2>\n<code>func (v *BoolValue) Set(x bool)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:BoolValue\">func (*BoolValue)</a> <a href=\"?m:BoolValue.SetValue!\">SetValue</a></h2>\n<code>func (v *BoolValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanDir!\">ChanDir</a></h2>\n<pre>type ChanDir int</pre>\n<p>\nChanDir represents a channel type&#39;s direction.\n</p>\n\n",name:"ChanDir","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ChanDir\">func (ChanDir)</a> <a href=\"?m:ChanDir.String!\">String</a></h2>\n<code>func (d ChanDir) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanType!\">ChanType</a></h2>\n<pre>type ChanType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nChanType represents a channel type.\n</p>\n\n",name:"ChanType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.Dir!\">Dir</a></h2>\n<code>func (t *ChanType) Dir() ChanDir</code>\n<p>\nDir returns the channel direction.\n</p>\n\n",name:"Dir"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanType\">func (*ChanType)</a> <a href=\"?m:ChanType.Elem!\">Elem</a></h2>\n<code>func (t *ChanType) Elem() Type</code>\n<p>\nElem returns the channel&#39;s element type.\n</p>\n\n",name:"Elem"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ChanValue!\">ChanValue</a></h2>\n<pre>type ChanValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA ChanValue represents a chan.\n</p>\n\n",name:"ChanValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Cap!\">Cap</a></h2>\n<code>func (v *ChanValue) Cap() int</code>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Close!\">Close</a></h2>\n<code>func (v *ChanValue) Close()</code>\n<p>\nClose closes the channel.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Closed!\">Closed</a></h2>\n<code>func (v *ChanValue) Closed() bool</code>\n<p>\nClosed returns the result of closed(c) on the underlying channel.\n</p>\n\n",name:"Closed"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Get!\">Get</a></h2>\n<code>func (v *ChanValue) Get() uintptr</code>\n<p>\nGet returns the uintptr value of v.\nIt is mainly useful for printing.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.IsNil!\">IsNil</a></h2>\n<code>func (v *ChanValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil channel.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Len!\">Len</a></h2>\n<code>func (v *ChanValue) Len() int</code>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Recv!\">Recv</a></h2>\n<code>func (v *ChanValue) Recv() Value</code>\n<p>\nRecv receives and returns a value from the channel v.\n</p>\n\n",name:"Recv"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Send!\">Send</a></h2>\n<code>func (v *ChanValue) Send(x Value)</code>\n<p>\nSend sends x on the channel v.\n</p>\n\n",name:"Send"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.Set!\">Set</a></h2>\n<code>func (v *ChanValue) Set(x *ChanValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.SetValue!\">SetValue</a></h2>\n<code>func (v *ChanValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.TryRecv!\">TryRecv</a></h2>\n<code>func (v *ChanValue) TryRecv() Value</code>\n<p>\nTryRecv attempts to receive a value from the channel v but will not block.\nIt returns the value if one is received, nil otherwise.\n</p>\n\n",name:"TryRecv"},{html:"\n<h2><a class=\"black\" href=\"?m:ChanValue\">func (*ChanValue)</a> <a href=\"?m:ChanValue.TrySend!\">TrySend</a></h2>\n<code>func (v *ChanValue) TrySend(x Value) bool</code>\n<p>\nTrySend attempts to sends x on the channel v but will not block.\nIt returns true if the value was sent, false otherwise.\n</p>\n\n",name:"TrySend"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexType!\">ComplexType</a></h2>\n<pre>type ComplexType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nComplexType represents a complex type.\n</p>\n\n",name:"ComplexType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ComplexValue!\">ComplexValue</a></h2>\n<pre>type ComplexValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nComplexValue represents a complex value.\n</p>\n\n",name:"ComplexValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.Get!\">Get</a></h2>\n<code>func (v *ComplexValue) Get() complex128</code>\n<p>\nGet returns the underlying complex value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.Set!\">Set</a></h2>\n<code>func (v *ComplexValue) Set(x complex128)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:ComplexValue\">func (*ComplexValue)</a> <a href=\"?m:ComplexValue.SetValue!\">SetValue</a></h2>\n<code>func (v *ComplexValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatType!\">FloatType</a></h2>\n<pre>type FloatType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nFloatType represents a float type.\n</p>\n\n",name:"FloatType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FloatValue!\">FloatValue</a></h2>\n<pre>type FloatValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nFloatValue represents a float value.\n</p>\n\n",name:"FloatValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Get!\">Get</a></h2>\n<code>func (v *FloatValue) Get() float64</code>\n<p>\nGet returns the underlying int value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Overflow!\">Overflow</a></h2>\n<code>func (v *FloatValue) Overflow(x float64) bool</code>\n<p>\nOverflow returns true if x cannot be represented by the type of v.\n</p>\n\n",name:"Overflow"},{html:"\n<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.Set!\">Set</a></h2>\n<code>func (v *FloatValue) Set(x float64)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:FloatValue\">func (*FloatValue)</a> <a href=\"?m:FloatValue.SetValue!\">SetValue</a></h2>\n<code>func (v *FloatValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncType!\">FuncType</a></h2>\n<pre>type FuncType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nFuncType represents a function type.\n</p>\n\n",name:"FuncType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.DotDotDot!\">DotDotDot</a></h2>\n<code>func (t *FuncType) DotDotDot() bool</code>\n<p>\nDotDotDot returns true if the final function input parameter\nis a &#34;...&#34; parameter.  If so, t.In(t.NumIn() - 1) returns the\nparameter&#39;s underlying static type []T.\n</p>\n<p>\nFor concreteness, if t is func(x int, y ... float), then\n</p>\n<pre>t.NumIn() == 2\nt.In(0) is the reflect.Type for &#34;int&#34;\nt.In(1) is the reflect.Type for &#34;[]float&#34;\nt.DotDotDot() == true\n</pre>\n\n",name:"DotDotDot"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.In!\">In</a></h2>\n<code>func (t *FuncType) In(i int) Type</code>\n<p>\nIn returns the type of the i&#39;th function input parameter.\n</p>\n\n",name:"In"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.NumIn!\">NumIn</a></h2>\n<code>func (t *FuncType) NumIn() int</code>\n<p>\nNumIn returns the number of input parameters.\n</p>\n\n",name:"NumIn"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.NumOut!\">NumOut</a></h2>\n<code>func (t *FuncType) NumOut() int</code>\n<p>\nNumOut returns the number of function output parameters.\n</p>\n\n",name:"NumOut"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncType\">func (*FuncType)</a> <a href=\"?m:FuncType.Out!\">Out</a></h2>\n<code>func (t *FuncType) Out(i int) Type</code>\n<p>\nOut returns the type of the i&#39;th function output parameter.\n</p>\n\n",name:"Out"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FuncValue!\">FuncValue</a></h2>\n<pre>type FuncValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA FuncValue represents a function value.\n</p>\n\n",name:"FuncValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Call!\">Call</a></h2>\n<code>func (fv *FuncValue) Call(in []Value) []Value</code>\n<p>\nCall calls the function fv with input parameters in.\nIt returns the function&#39;s output parameters as Values.\n</p>\n\n",name:"Call"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Get!\">Get</a></h2>\n<code>func (v *FuncValue) Get() uintptr</code>\n<p>\nGet returns the uintptr value of v.\nIt is mainly useful for printing.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.IsNil!\">IsNil</a></h2>\n<code>func (v *FuncValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil function.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.Set!\">Set</a></h2>\n<code>func (v *FuncValue) Set(x *FuncValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:FuncValue\">func (*FuncValue)</a> <a href=\"?m:FuncValue.SetValue!\">SetValue</a></h2>\n<code>func (v *FuncValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntType!\">IntType</a></h2>\n<pre>type IntType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nIntType represents a signed integer type.\n</p>\n\n",name:"IntType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IntValue!\">IntValue</a></h2>\n<pre>type IntValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nIntValue represents an int value.\n</p>\n\n",name:"IntValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Get!\">Get</a></h2>\n<code>func (v *IntValue) Get() int64</code>\n<p>\nGet returns the underlying int value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Overflow!\">Overflow</a></h2>\n<code>func (v *IntValue) Overflow(x int64) bool</code>\n<p>\nOverflow returns true if x cannot be represented by the type of v.\n</p>\n\n",name:"Overflow"},{html:"\n<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.Set!\">Set</a></h2>\n<code>func (v *IntValue) Set(x int64)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:IntValue\">func (*IntValue)</a> <a href=\"?m:IntValue.SetValue!\">SetValue</a></h2>\n<code>func (v *IntValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceType!\">InterfaceType</a></h2>\n<pre>type InterfaceType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nInterfaceType represents an interface type.\n</p>\n\n",name:"InterfaceType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.Method!\">Method</a></h2>\n<code>func (t *InterfaceType) Method(i int) (m Method)</code>\n<p>\nMethod returns the i&#39;th interface method.\n</p>\n\n",name:"Method"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceType\">func (*InterfaceType)</a> <a href=\"?m:InterfaceType.NumMethod!\">NumMethod</a></h2>\n<code>func (t *InterfaceType) NumMethod() int</code>\n<p>\nNumMethod returns the number of interface methods.\n</p>\n\n",name:"NumMethod"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InterfaceValue!\">InterfaceValue</a></h2>\n<pre>type InterfaceValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn InterfaceValue represents an interface value.\n</p>\n\n",name:"InterfaceValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Elem!\">Elem</a></h2>\n<code>func (v *InterfaceValue) Elem() Value</code>\n<p>\nElem returns the concrete value stored in the interface value v.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Get!\">Get</a></h2>\n<code>func (v *InterfaceValue) Get() [2]uintptr</code>\n<p>\nGet returns the two words that represent an interface in the runtime.\nThose words are useful only when playing unsafe games.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.IsNil!\">IsNil</a></h2>\n<code>func (v *InterfaceValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil interface value.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Method!\">Method</a></h2>\n<code>func (v *InterfaceValue) Method(i int) *FuncValue</code>\n<p>\nMethod returns a FuncValue corresponding to v&#39;s i&#39;th method.\nThe arguments to a Call on the returned FuncValue\nshould not include a receiver; the FuncValue will use v\nas the receiver.\n</p>\n\n",name:"Method"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.Set!\">Set</a></h2>\n<code>func (v *InterfaceValue) Set(x Value)</code>\n<p>\nSet assigns x to v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:InterfaceValue\">func (*InterfaceValue)</a> <a href=\"?m:InterfaceValue.SetValue!\">SetValue</a></h2>\n<code>func (v *InterfaceValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Kind!\">Kind</a></h2>\n<pre>type Kind uint8</pre>\n<p>\nA Kind represents the specific kind of type that a Type represents.\nFor numeric types, the Kind gives more information than the Type&#39;s\ndynamic type.  For example, the Type of a float32 is FloatType, but\nthe Kind is Float32.\n</p>\n<p>\nThe zero Kind is not a valid kind.\n</p>\n\n",name:"Kind","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Kind\">func (Kind)</a> <a href=\"?m:Kind.String!\">String</a></h2>\n<code>func (k Kind) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapType!\">MapType</a></h2>\n<pre>type MapType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nMapType represents a map type.\n</p>\n\n",name:"MapType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.Elem!\">Elem</a></h2>\n<code>func (t *MapType) Elem() Type</code>\n<p>\nElem returns the map element type.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:MapType\">func (*MapType)</a> <a href=\"?m:MapType.Key!\">Key</a></h2>\n<code>func (t *MapType) Key() Type</code>\n<p>\nKey returns the map key type.\n</p>\n\n",name:"Key"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MapValue!\">MapValue</a></h2>\n<pre>type MapValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA MapValue represents a map value.\n</p>\n\n",name:"MapValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Elem!\">Elem</a></h2>\n<code>func (v *MapValue) Elem(key Value) Value</code>\n<p>\nElem returns the value associated with key in the map v.\nIt returns nil if key is not found in the map.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Get!\">Get</a></h2>\n<code>func (v *MapValue) Get() uintptr</code>\n<p>\nGet returns the uintptr value of v.\nIt is mainly useful for printing.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.IsNil!\">IsNil</a></h2>\n<code>func (v *MapValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil map value.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Keys!\">Keys</a></h2>\n<code>func (v *MapValue) Keys() []Value</code>\n<p>\nKeys returns a slice containing all the keys present in the map,\nin unspecified order.\n</p>\n\n",name:"Keys"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Len!\">Len</a></h2>\n<code>func (v *MapValue) Len() int</code>\n<p>\nLen returns the number of keys in the map v.\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.Set!\">Set</a></h2>\n<code>func (v *MapValue) Set(x *MapValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.SetElem!\">SetElem</a></h2>\n<code>func (v *MapValue) SetElem(key, val Value)</code>\n<p>\nSetElem sets the value associated with key in the map v to val.\nIf val is nil, Put deletes the key from map.\n</p>\n\n",name:"SetElem"},{html:"\n<h2><a class=\"black\" href=\"?m:MapValue\">func (*MapValue)</a> <a href=\"?m:MapValue.SetValue!\">SetValue</a></h2>\n<code>func (v *MapValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Method!\">Method</a></h2>\n<pre>type Method struct {\n\tPkgPath string // empty for uppercase Name\n\tName    string\n\tType    *FuncType\n\tFunc    *FuncValue\n}</pre>\n<p>\nMethod represents a single method.\n</p>\n\n",name:"Method","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrType!\">PtrType</a></h2>\n<pre>type PtrType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nPtrType represents a pointer type.\n</p>\n\n",name:"PtrType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PtrType\">func (*PtrType)</a> <a href=\"?m:PtrType.Elem!\">Elem</a></h2>\n<code>func (t *PtrType) Elem() Type</code>\n<p>\nElem returns the pointer element type.\n</p>\n\n",name:"Elem"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PtrValue!\">PtrValue</a></h2>\n<pre>type PtrValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA PtrValue represents a pointer.\n</p>\n\n",name:"PtrValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Elem!\">Elem</a></h2>\n<code>func (v *PtrValue) Elem() Value</code>\n<p>\nElem returns the value that v points to.\nIf v is a nil pointer, Elem returns a nil Value.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Get!\">Get</a></h2>\n<code>func (v *PtrValue) Get() uintptr</code>\n<p>\nGet returns the uintptr value of v.\nIt is mainly useful for printing.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.IsNil!\">IsNil</a></h2>\n<code>func (v *PtrValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil pointer.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.PointTo!\">PointTo</a></h2>\n<code>func (v *PtrValue) PointTo(x Value)</code>\n<p>\nPointTo changes v to point to x.\nIf x is a nil Value, PointTo sets v to nil.\n</p>\n\n",name:"PointTo"},{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.Set!\">Set</a></h2>\n<code>func (v *PtrValue) Set(x *PtrValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:PtrValue\">func (*PtrValue)</a> <a href=\"?m:PtrValue.SetValue!\">SetValue</a></h2>\n<code>func (v *PtrValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceHeader!\">SliceHeader</a></h2>\n<pre>type SliceHeader struct {\n\tData uintptr\n\tLen  int\n\tCap  int\n}</pre>\n<p>\nruntime representation of slice\n</p>\n\n",name:"SliceHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceType!\">SliceType</a></h2>\n<pre>type SliceType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nSliceType represents a slice type.\n</p>\n\n",name:"SliceType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SliceType\">func (*SliceType)</a> <a href=\"?m:SliceType.Elem!\">Elem</a></h2>\n<code>func (t *SliceType) Elem() Type</code>\n<p>\nElem returns the type of the slice&#39;s elements.\n</p>\n\n",name:"Elem"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SliceValue!\">SliceValue</a></h2>\n<pre>type SliceValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA SliceValue represents a slice.\n</p>\n\n",name:"SliceValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Cap!\">Cap</a></h2>\n<code>func (v *SliceValue) Cap() int</code>\n<p>\nCap returns the capacity of the slice.\n</p>\n\n",name:"Cap"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Elem!\">Elem</a></h2>\n<code>func (v *SliceValue) Elem(i int) Value</code>\n<p>\nElem returns the i&#39;th element of v.\n</p>\n\n",name:"Elem"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Get!\">Get</a></h2>\n<code>func (v *SliceValue) Get() uintptr</code>\n<p>\nGet returns the uintptr address of the v.Cap()&#39;th element.  This gives\nthe same result for all slices of the same array.\nIt is mainly useful for printing.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.IsNil!\">IsNil</a></h2>\n<code>func (v *SliceValue) IsNil() bool</code>\n<p>\nIsNil returns whether v is a nil slice.\n</p>\n\n",name:"IsNil"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Len!\">Len</a></h2>\n<code>func (v *SliceValue) Len() int</code>\n<p>\nLen returns the length of the slice.\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Set!\">Set</a></h2>\n<code>func (v *SliceValue) Set(x *SliceValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.SetLen!\">SetLen</a></h2>\n<code>func (v *SliceValue) SetLen(n int)</code>\n<p>\nSetLen changes the length of v.\nThe new length n must be between 0 and the capacity, inclusive.\n</p>\n\n",name:"SetLen"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.SetValue!\">SetValue</a></h2>\n<code>func (v *SliceValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"},{html:"\n<h2><a class=\"black\" href=\"?m:SliceValue\">func (*SliceValue)</a> <a href=\"?m:SliceValue.Slice!\">Slice</a></h2>\n<code>func (v *SliceValue) Slice(beg, end int) *SliceValue</code>\n<p>\nSlice returns a sub-slice of the slice v.\n</p>\n\n",name:"Slice"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringHeader!\">StringHeader</a></h2>\n<pre>type StringHeader struct {\n\tData uintptr\n\tLen  int\n}</pre>\n<p>\nStringHeader is the runtime representation of a string.\n</p>\n\n",name:"StringHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringType!\">StringType</a></h2>\n<pre>type StringType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nStringType represents a string type.\n</p>\n\n",name:"StringType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StringValue!\">StringValue</a></h2>\n<pre>type StringValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nStringValue represents a string value.\n</p>\n\n",name:"StringValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.Get!\">Get</a></h2>\n<code>func (v *StringValue) Get() string</code>\n<p>\nGet returns the underlying string value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.Set!\">Set</a></h2>\n<code>func (v *StringValue) Set(x string)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:StringValue\">func (*StringValue)</a> <a href=\"?m:StringValue.SetValue!\">SetValue</a></h2>\n<code>func (v *StringValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructField!\">StructField</a></h2>\n<pre>type StructField struct {\n\tPkgPath   string // empty for uppercase Name\n\tName      string\n\tType      Type\n\tTag       string\n\tOffset    uintptr\n\tIndex     []int\n\tAnonymous bool\n}</pre>\n\n",name:"StructField","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructType!\">StructType</a></h2>\n<pre>type StructType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nStructType represents a struct type.\n</p>\n\n",name:"StructType","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.Field!\">Field</a></h2>\n<code>func (t *StructType) Field(i int) (f StructField)</code>\n<p>\nField returns the i&#39;th struct field.\n</p>\n\n",name:"Field"},{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByIndex!\">FieldByIndex</a></h2>\n<code>func (t *StructType) FieldByIndex(index []int) (f StructField)</code>\n<p>\nFieldByIndex returns the nested field corresponding to index.\n</p>\n\n",name:"FieldByIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByName!\">FieldByName</a></h2>\n<code>func (t *StructType) FieldByName(name string) (f StructField, present bool)</code>\n<p>\nFieldByName returns the struct field with the given name\nand a boolean to indicate if the field was found.\n</p>\n\n",name:"FieldByName"},{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.FieldByNameFunc!\">FieldByNameFunc</a></h2>\n<code>func (t *StructType) FieldByNameFunc(match func(string) bool) (f StructField, present bool)</code>\n<p>\nFieldByNameFunc returns the struct field with a name that satisfies the\nmatch function and a boolean to indicate if the field was found.\n</p>\n\n",name:"FieldByNameFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:StructType\">func (*StructType)</a> <a href=\"?m:StructType.NumField!\">NumField</a></h2>\n<code>func (t *StructType) NumField() int</code>\n<p>\nNumField returns the number of struct fields.\n</p>\n\n",name:"NumField"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructValue!\">StructValue</a></h2>\n<pre>type StructValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA StructValue represents a struct value.\n</p>\n\n",name:"StructValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.Field!\">Field</a></h2>\n<code>func (v *StructValue) Field(i int) Value</code>\n<p>\nField returns the i&#39;th field of the struct.\n</p>\n\n",name:"Field"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByIndex!\">FieldByIndex</a></h2>\n<code>func (t *StructValue) FieldByIndex(index []int) (v Value)</code>\n<p>\nFieldByIndex returns the nested field corresponding to index.\n</p>\n\n",name:"FieldByIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByName!\">FieldByName</a></h2>\n<code>func (t *StructValue) FieldByName(name string) Value</code>\n<p>\nFieldByName returns the struct field with the given name.\nThe result is nil if no field was found.\n</p>\n\n",name:"FieldByName"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.FieldByNameFunc!\">FieldByNameFunc</a></h2>\n<code>func (t *StructValue) FieldByNameFunc(match func(string) bool) Value</code>\n<p>\nFieldByNameFunc returns the struct field with a name that satisfies the\nmatch function.\nThe result is nil if no field was found.\n</p>\n\n",name:"FieldByNameFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.NumField!\">NumField</a></h2>\n<code>func (v *StructValue) NumField() int</code>\n<p>\nNumField returns the number of fields in the struct.\n</p>\n\n",name:"NumField"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.Set!\">Set</a></h2>\n<code>func (v *StructValue) Set(x *StructValue)</code>\n<p>\nSet assigns x to v.\nThe new value x must have the same type as v.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:StructValue\">func (*StructValue)</a> <a href=\"?m:StructValue.SetValue!\">SetValue</a></h2>\n<code>func (v *StructValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type interface {\n\t// PkgPath returns the type&#39;s package path.\n\t// The package path is a full package import path like &#34;container/vector&#34;.\n\t// PkgPath returns an empty string for unnamed types.\n\tPkgPath() string\n\n\t// Name returns the type&#39;s name within its package.\n\t// Name returns an empty string for unnamed types.\n\tName() string\n\n\t// String returns a string representation of the type.\n\t// The string representation may use shortened package names\n\t// (e.g., vector instead of &#34;container/vector&#34;) and is not\n\t// guaranteed to be unique among types.  To test for equality,\n\t// compare the Types directly.\n\tString() string\n\n\t// Size returns the number of bytes needed to store\n\t// a value of the given type; it is analogous to unsafe.Sizeof.\n\tSize() uintptr\n\n\t// Bits returns the size of the type in bits.\n\t// It is intended for use with numeric types and may overflow\n\t// when used for composite types.\n\tBits() int\n\n\t// Align returns the alignment of a value of this type\n\t// when allocated in memory.\n\tAlign() int\n\n\t// FieldAlign returns the alignment of a value of this type\n\t// when used as a field in a struct.\n\tFieldAlign() int\n\n\t// Kind returns the specific kind of this type.\n\tKind() Kind\n\n\t// For non-interface types, Method returns the i&#39;th method with receiver T.\n\t// For interface types, Method returns the i&#39;th method in the interface.\n\t// NumMethod returns the number of such methods.\n\tMethod(int) Method\n\tNumMethod() int\n\t// contains unexported methods\n}</pre>\n<p>\nType is the runtime representation of a Go type.\nEvery type implements the methods listed here.\nSome types implement additional interfaces;\nuse a type switch to find out what kind of type a Type is.\nEach type in a program has a unique Type, so == on Types\ncorresponds to Go&#39;s type equality.\n</p>\n\n",name:"Type","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintType!\">UintType</a></h2>\n<pre>type UintType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUintType represents a uint type.\n</p>\n\n",name:"UintType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UintValue!\">UintValue</a></h2>\n<pre>type UintValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUintValue represents a uint value.\n</p>\n\n",name:"UintValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Get!\">Get</a></h2>\n<code>func (v *UintValue) Get() uint64</code>\n<p>\nGet returns the underlying uuint value.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Overflow!\">Overflow</a></h2>\n<code>func (v *UintValue) Overflow(x uint64) bool</code>\n<p>\nOverflow returns true if x cannot be represented by the type of v.\n</p>\n\n",name:"Overflow"},{html:"\n<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.Set!\">Set</a></h2>\n<code>func (v *UintValue) Set(x uint64)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:UintValue\">func (*UintValue)</a> <a href=\"?m:UintValue.SetValue!\">SetValue</a></h2>\n<code>func (v *UintValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerType!\">UnsafePointerType</a></h2>\n<pre>type UnsafePointerType struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUnsafePointerType represents an unsafe.Pointer type.\n</p>\n\n",name:"UnsafePointerType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsafePointerValue!\">UnsafePointerValue</a></h2>\n<pre>type UnsafePointerValue struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUnsafePointerValue represents an unsafe.Pointer value.\n</p>\n\n",name:"UnsafePointerValue","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.Get!\">Get</a></h2>\n<code>func (v *UnsafePointerValue) Get() uintptr</code>\n<p>\nGet returns the underlying uintptr value.\nGet returns uintptr, not unsafe.Pointer, so that\nprograms that do not import &#34;unsafe&#34; cannot\nobtain a value of unsafe.Pointer type from &#34;reflect&#34;.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.Set!\">Set</a></h2>\n<code>func (v *UnsafePointerValue) Set(x unsafe.Pointer)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"Set"},{html:"\n<h2><a class=\"black\" href=\"?m:UnsafePointerValue\">func (*UnsafePointerValue)</a> <a href=\"?m:UnsafePointerValue.SetValue!\">SetValue</a></h2>\n<code>func (v *UnsafePointerValue) SetValue(x Value)</code>\n<p>\nSet sets v to the value x.\n</p>\n\n",name:"SetValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Value!\">Value</a></h2>\n<pre>type Value interface {\n\t// Type returns the value&#39;s type.\n\tType() Type\n\n\t// Interface returns the value as an interface{}.\n\tInterface() interface{}\n\n\t// CanSet returns whether the value can be changed.\n\t// Values obtained by the use of non-exported struct fields\n\t// can be used in Get but not Set.\n\t// If CanSet() returns false, calling the type-specific Set\n\t// will cause a crash.\n\tCanSet() bool\n\n\t// SetValue assigns v to the value; v must have the same type as the value.\n\tSetValue(v Value)\n\n\t// Addr returns a pointer to the underlying data.\n\t// It is for advanced clients that also\n\t// import the &#34;unsafe&#34; package.\n\tAddr() uintptr\n\n\t// Method returns a FuncValue corresponding to the value&#39;s i&#39;th method.\n\t// The arguments to a Call on the returned FuncValue\n\t// should not include a receiver; the FuncValue will use\n\t// the value as the receiver.\n\tMethod(i int) *FuncValue\n\t// contains unexported methods\n}</pre>\n<p>\nValue is the common interface to reflection values.\nThe implementations of Value (e.g., ArrayValue, StructValue)\nhave additional type-specific methods.\n</p>\n\n",name:"Value","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ArrayCopy!\">ArrayCopy</a></h2>\n<code>func ArrayCopy(dst, src ArrayOrSliceValue) int</code>\n<p>\nArrayCopy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nThe arrays dst and src must have the same element type.\n</p>\n\n",name:"ArrayCopy"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DeepEqual!\">DeepEqual</a></h2>\n<code>func DeepEqual(a1, a2 interface{}) bool</code>\n<p>\nDeepEqual tests for deep equality. It uses normal == equality where possible\nbut will scan members of arrays, slices, and fields of structs. It correctly\nhandles recursive types.\n</p>\n\n",name:"DeepEqual"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Indirect!\">Indirect</a></h2>\n<code>func Indirect(v Value) Value</code>\n<p>\nIndirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a nil Value.\nIf v is not a pointer, Indirect returns v.\n</p>\n\n",name:"Indirect"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeChan!\">MakeChan</a></h2>\n<code>func MakeChan(typ *ChanType, buffer int) *ChanValue</code>\n<p>\nMakeChan creates a new channel with the specified type and buffer size.\n</p>\n\n",name:"MakeChan"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeMap!\">MakeMap</a></h2>\n<code>func MakeMap(typ *MapType) *MapValue</code>\n<p>\nMakeMap creates a new map of the specified type.\n</p>\n\n",name:"MakeMap"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeSlice!\">MakeSlice</a></h2>\n<code>func MakeSlice(typ *SliceType, len, cap int) *SliceValue</code>\n<p>\nMakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n</p>\n\n",name:"MakeSlice"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeZero!\">MakeZero</a></h2>\n<code>func MakeZero(typ Type) Value</code>\n<p>\nMakeZero returns a zero Value for the specified Type.\n</p>\n\n",name:"MakeZero"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewValue!\">NewValue</a></h2>\n<code>func NewValue(i interface{}) Value</code>\n<p>\nNewValue returns a new Value initialized to the concrete value\nstored in the interface i.  NewValue(nil) returns nil.\n</p>\n\n",name:"NewValue"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Typeof!\">Typeof</a></h2>\n<code>func Typeof(i interface{}) Type</code>\n<p>\nTypeof returns the reflection Type of the value in the interface{}.\n</p>\n\n",name:"Typeof"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ChanDir!\">ChanDir</a></h2>\n<pre>const (\n\tRecvDir ChanDir = 1 &lt;&lt; iota\n\tSendDir\n\tBothDir = RecvDir | SendDir\n)</pre>\n\n",names:["RecvDir","SendDir","BothDir"],type:"ChanDir"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Kind!\">Kind</a></h2>\n<pre>const (\n\tBool Kind = 1 + iota\n\tInt\n\tInt8\n\tInt16\n\tInt32\n\tInt64\n\tUint\n\tUint8\n\tUint16\n\tUint32\n\tUint64\n\tUintptr\n\tFloat\n\tFloat32\n\tFloat64\n\tComplex\n\tComplex64\n\tComplex128\n\tArray\n\tChan\n\tFunc\n\tInterface\n\tMap\n\tPtr\n\tSlice\n\tString\n\tStruct\n\tUnsafePointer\n)</pre>\n\n",names:["Bool","Int","Int8","Int16","Int32","Int64","Uint","Uint8","Uint16","Uint32","Uint64","Uintptr","Float","Float32","Float64","Complex","Complex64","Complex128","Array","Chan","Func","Interface","Map","Ptr","Slice","String","Struct","UnsafePointer"],type:"Kind"}],vars:[]}