var gortfmData = {index:"index.html",html:"<p>\nPackage netchan implements type-safe networked channels:\nit allows the two ends of a channel to appear on different\ncomputers connected by a network.  It does this by transporting\ndata sent to a channel on one machine so it can be recovered\nby a receive of a channel of the same type on the other.\n</p>\n<p>\nAn exporter publishes a set of channels by name.  An importer\nconnects to the exporting machine and imports the channels\nby name. After importing the channels, the two machines can\nuse the channels in the usual way.\n</p>\n<p>\nNetworked channels are not synchronized; they always behave\nas if they are buffered channels of at least one element.\n</p>\n",name:"netchan",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Dir!\">Dir</a></h2>\n<pre>type Dir int</pre>\n<p>\nThe direction of a connection from the client&#39;s perspective.\n</p>\n\n",name:"Dir","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Dir\">func (Dir)</a> <a href=\"?m:Dir.String!\">String</a></h2>\n<code>func (dir Dir) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Exporter!\">Exporter</a></h2>\n<pre>type Exporter struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn Exporter allows a set of channels to be published on a single\nnetwork port.  A single machine may have multiple Exporters\nbut they must use different ports.\n</p>\n\n",name:"Exporter","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Drain!\">Drain</a></h2>\n<code>func (exp *Exporter) Drain(timeout int64) os.Error</code>\n<p>\nDrain waits until all messages sent from this exporter/importer, including\nthose not yet sent to any client and possibly including those sent while\nDrain was executing, have been received by the importer.  In short, it\nwaits until all the exporter&#39;s messages have been received by a client.\nIf the timeout (measured in nanoseconds) is positive and Drain takes\nlonger than that to complete, an error is returned.\n</p>\n\n",name:"Drain"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Export!\">Export</a></h2>\n<code>func (exp *Exporter) Export(name string, chT interface{}, dir Dir) os.Error</code>\n<p>\nExport exports a channel of a given type and specified direction.  The\nchannel to be exported is provided in the call and may be of arbitrary\nchannel type.\nDespite the literal signature, the effective signature is\n</p>\n<pre>Export(name string, chT chan T, dir Dir)\n</pre>\n\n",name:"Export"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Hangup!\">Hangup</a></h2>\n<code>func (exp *Exporter) Hangup(name string) os.Error</code>\n<p>\nHangup disassociates the named channel from the Exporter and closes\nthe channel.  Messages in flight for the channel may be dropped.\n</p>\n\n",name:"Hangup"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.ListenAndServe!\">ListenAndServe</a></h2>\n<code>func (exp *Exporter) ListenAndServe(network, localaddr string) os.Error</code>\n<p>\nListenAndServe exports the exporter&#39;s channels through the\ngiven network and local address defined as in net.Listen.\n</p>\n\n",name:"ListenAndServe"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Serve!\">Serve</a></h2>\n<code>func (exp *Exporter) Serve(listener net.Listener)</code>\n<p>\nServe waits for incoming connections on the listener\nand serves the Exporter&#39;s channels on each.\nIt blocks until the listener is closed.\n</p>\n\n",name:"Serve"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.ServeConn!\">ServeConn</a></h2>\n<code>func (exp *Exporter) ServeConn(conn io.ReadWriter)</code>\n<p>\nServeConn exports the Exporter&#39;s channels on conn.\nIt blocks until the connection is terminated.\n</p>\n\n",name:"ServeConn"},{html:"\n<h2><a class=\"black\" href=\"?m:Exporter\">func (*Exporter)</a> <a href=\"?m:Exporter.Sync!\">Sync</a></h2>\n<code>func (exp *Exporter) Sync(timeout int64) os.Error</code>\n<p>\nSync waits until all clients of the exporter have received the messages\nthat were sent at the time Sync was invoked.  Unlike Drain, it does not\nwait for messages sent while it is running or messages that have not been\ndispatched to any client.  If the timeout (measured in nanoseconds) is\npositive and Sync takes longer than that to complete, an error is\nreturned.\n</p>\n\n",name:"Sync"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Importer!\">Importer</a></h2>\n<pre>type Importer struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn Importer allows a set of channels to be imported from a single\nremote machine/network port.  A machine may have multiple\nimporters, even from the same machine/network port.\n</p>\n\n",name:"Importer","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Errors!\">Errors</a></h2>\n<code>func (imp *Importer) Errors() chan os.Error</code>\n<p>\nErrors returns a channel from which transmission and protocol errors\ncan be read. Clients of the importer are not required to read the error\nchannel for correct execution. However, if too many errors occur\nwithout being read from the error channel, the importer will shut down.\n</p>\n\n",name:"Errors"},{html:"\n<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Hangup!\">Hangup</a></h2>\n<code>func (imp *Importer) Hangup(name string) os.Error</code>\n<p>\nHangup disassociates the named channel from the Importer and closes\nthe channel.  Messages in flight for the channel may be dropped.\n</p>\n\n",name:"Hangup"},{html:"\n<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.Import!\">Import</a></h2>\n<code>func (imp *Importer) Import(name string, chT interface{}, dir Dir, size int) os.Error</code>\n<p>\nImport imports a channel of the given type, size and specified direction.\nIt is equivalent to ImportNValues with a count of -1, meaning unbounded.\n</p>\n\n",name:"Import"},{html:"\n<h2><a class=\"black\" href=\"?m:Importer\">func (*Importer)</a> <a href=\"?m:Importer.ImportNValues!\">ImportNValues</a></h2>\n<code>func (imp *Importer) ImportNValues(name string, chT interface{}, dir Dir, size, n int) os.Error</code>\n<p>\nImportNValues imports a channel of the given type and specified\ndirection and then receives or transmits up to n values on that\nchannel.  A value of n==-1 implies an unbounded number of values.  The\nchannel will have buffer space for size values, or 1 value if size &lt; 1.\nThe channel to be bound to the remote site&#39;s channel is provided\nin the call and may be of arbitrary channel type.\nDespite the literal signature, the effective signature is\n</p>\n<pre>ImportNValues(name string, chT chan T, dir Dir, size, n int) os.Error\n</pre>\n<p>\nExample usage:\n</p>\n<pre>imp, err := NewImporter(&#34;tcp&#34;, &#34;netchanserver.mydomain.com:1234&#34;)\nif err != nil { log.Fatal(err) }\nch := make(chan myType)\nerr = imp.ImportNValues(&#34;name&#34;, ch, Recv, 1, 1)\nif err != nil { log.Fatal(err) }\nfmt.Printf(&#34;%+v\\n&#34;, &lt;-ch)\n</pre>\n\n",name:"ImportNValues"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Import!\">Import</a></h2>\n<code>func Import(network, remoteaddr string) (*Importer, os.Error)</code>\n<p>\nImport imports a set of channels from the given network and address.\n</p>\n\n",name:"Import"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewExporter!\">NewExporter</a></h2>\n<code>func NewExporter() *Exporter</code>\n<p>\nNewExporter creates a new Exporter that exports a set of channels.\n</p>\n\n",name:"NewExporter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewImporter!\">NewImporter</a></h2>\n<code>func NewImporter(conn io.ReadWriter) *Importer</code>\n<p>\nNewImporter creates a new Importer object to import a set of channels\nfrom the given connection. The Exporter must be available and serving when\nthe Importer is created.\n</p>\n\n",name:"NewImporter"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Dir!\">Dir</a></h2>\n<pre>const (\n\tRecv Dir = iota\n\tSend\n)</pre>\n\n",names:["Recv","Send"],type:"Dir"}],vars:[]}