var gortfmData = {index:"index.html",html:"<p>\nThis package implements utility functions to help with black box testing.\n</p>\n",name:"quick",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CheckEqualError!\">CheckEqualError</a></h2>\n<pre>type CheckEqualError struct {\n\tCheckError\n\tOut1 []interface{}\n\tOut2 []interface{}\n}</pre>\n<p>\nA CheckEqualError is the result CheckEqual finding an error.\n</p>\n\n",name:"CheckEqualError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CheckEqualError\">func (*CheckEqualError)</a> <a href=\"?m:CheckEqualError.String!\">String</a></h2>\n<code>func (s *CheckEqualError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CheckError!\">CheckError</a></h2>\n<pre>type CheckError struct {\n\tCount int\n\tIn    []interface{}\n}</pre>\n<p>\nA CheckError is the result of Check finding an error.\n</p>\n\n",name:"CheckError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CheckError\">func (*CheckError)</a> <a href=\"?m:CheckError.String!\">String</a></h2>\n<code>func (s *CheckError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\n<pre>type Config struct {\n\t// MaxCount sets the maximum number of iterations. If zero,\n\t// MaxCountScale is used.\n\tMaxCount int\n\t// MaxCountScale is a non-negative scale factor applied to the default\n\t// maximum. If zero, the default is unchanged.\n\tMaxCountScale float64\n\t// If non-nil, rand is a source of random numbers. Otherwise a default\n\t// pseudo-random source will be used.\n\tRand *rand.Rand\n\t// If non-nil, Values is a function which generates a slice of arbitrary\n\t// Values that are congruent with the arguments to the function being\n\t// tested. Otherwise, Values is used to generate the values.\n\tValues func([]reflect.Value, *rand.Rand)\n}</pre>\n<p>\nA Config structure contains options for running a test.\n</p>\n\n",name:"Config","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Generator!\">Generator</a></h2>\n<pre>type Generator interface {\n\t// Generate returns a random instance of the type on which it is a\n\t// method using the size as a size hint.\n\tGenerate(rand *rand.Rand, size int) reflect.Value\n}</pre>\n<p>\nA Generator can generate random values of its own type.\n</p>\n\n",name:"Generator","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SetupError!\">SetupError</a></h2>\n<pre>type SetupError string</pre>\n<p>\nA SetupError is the result of an error in the way that check is being\nused, independent of the functions being tested.\n</p>\n\n",name:"SetupError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SetupError\">func (SetupError)</a> <a href=\"?m:SetupError.String!\">String</a></h2>\n<code>func (s SetupError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Check!\">Check</a></h2>\n<code>func Check(function interface{}, config *Config) (err os.Error)</code>\n<p>\nCheck looks for an input to f, any function that returns bool,\nsuch that f returns false.  It calls f repeatedly, with arbitrary\nvalues for each argument.  If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n</p>\n<pre>func TestOddMultipleOfThree(t *testing.T) {\n\tf := func(x int) bool {\n\t\ty := OddMultipleOfThree(x)\n\t\treturn y%2 == 1 &amp;&amp; y%3 == 0\n\t}\n\tif err := quick.Check(f, nil); err != nil {\n\t\tt.Error(err)\n\t}\n}\n</pre>\n\n",name:"Check"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckEqual!\">CheckEqual</a></h2>\n<code>func CheckEqual(f, g interface{}, config *Config) (err os.Error)</code>\n<p>\nCheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n</p>\n\n",name:"CheckEqual"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Value!\">Value</a></h2>\n<code>func Value(t reflect.Type, rand *rand.Rand) (value reflect.Value, ok bool)</code>\n<p>\nValue returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: in order to create arbitrary values for structs, all the members must be public.\n</p>\n\n",name:"Value"}],consts:[],vars:[]}