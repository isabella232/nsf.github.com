var gortfmData = {index:"index.html",html:"<p>\nThis package parses X.509-encoded keys and certificates.\n</p>\n",name:"x509",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Certificate!\">Certificate</a></h2>\n<pre>type Certificate struct {\n\tRaw                []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n\tRawTBSCertificate  []byte // Certificate part of raw ASN.1 DER content.\n\tSignature          []byte\n\tSignatureAlgorithm SignatureAlgorithm\n\n\tPublicKeyAlgorithm PublicKeyAlgorithm\n\tPublicKey          interface{}\n\n\tVersion             int\n\tSerialNumber        []byte\n\tIssuer              Name\n\tSubject             Name\n\tNotBefore, NotAfter *time.Time // Validity bounds.\n\tKeyUsage            KeyUsage\n\n\tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n\tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n\n\tBasicConstraintsValid bool // if true then the next two fields are valid.\n\tIsCA                  bool\n\tMaxPathLen            int\n\n\tSubjectKeyId   []byte\n\tAuthorityKeyId []byte\n\n\t// Subject Alternate Name values\n\tDNSNames       []string\n\tEmailAddresses []string\n\n\t// Name constraints\n\tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n\tPermittedDNSDomains         []string\n\n\tPolicyIdentifiers []asn1.ObjectIdentifier\n}</pre>\n<p>\nA Certificate represents an X.509 certificate.\n</p>\n\n",name:"Certificate","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.CheckSignatureFrom!\">CheckSignatureFrom</a></h2>\n<code>func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error)</code>\n<p>\nCheckSignatureFrom verifies that the signature on c is a valid signature\nfrom parent.\n</p>\n\n",name:"CheckSignatureFrom"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.VerifyHostname!\">VerifyHostname</a></h2>\n<code>func (c *Certificate) VerifyHostname(h string) os.Error</code>\n<p>\nVerifyHostname returns nil if c is a valid certificate for the named host.\nOtherwise it returns an os.Error describing the mismatch.\n</p>\n\n",name:"VerifyHostname"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ConstraintViolationError!\">ConstraintViolationError</a></h2>\n<pre>type ConstraintViolationError struct{}</pre>\n<p>\nConstraintViolationError results when a requested usage is not permitted by\na certificate. For example: checking a signature when the public key isn&#39;t a\ncertificate signing key.\n</p>\n\n",name:"ConstraintViolationError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ConstraintViolationError\">func (ConstraintViolationError)</a> <a href=\"?m:ConstraintViolationError.String!\">String</a></h2>\n<code>func (ConstraintViolationError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ExtKeyUsage!\">ExtKeyUsage</a></h2>\n<pre>type ExtKeyUsage int</pre>\n<p>\nExtKeyUsage represents an extended set of actions that are valid for a given key.\nEach of the ExtKeyUsage* constants define a unique action.\n</p>\n\n",name:"ExtKeyUsage","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HostnameError!\">HostnameError</a></h2>\n<pre>type HostnameError struct {\n\tCertificate *Certificate\n\tHost        string\n}</pre>\n\n",name:"HostnameError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HostnameError\">func (*HostnameError)</a> <a href=\"?m:HostnameError.String!\">String</a></h2>\n<code>func (h *HostnameError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeyUsage!\">KeyUsage</a></h2>\n<pre>type KeyUsage int</pre>\n<p>\nKeyUsage represents the set of actions that are valid for a given key. It&#39;s\na bitmap of the KeyUsage* constants.\n</p>\n\n",name:"KeyUsage","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\n<pre>type Name struct {\n\tCountry, Organization, OrganizationalUnit []string\n\tLocality, Province                        []string\n\tStreetAddress, PostalCode                 []string\n\tSerialNumber, CommonName                  string\n}</pre>\n<p>\nName represents an X.509 distinguished name. This only includes the common\nelements of a DN.  Additional elements in the name are ignored.\n</p>\n\n",name:"Name","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PublicKeyAlgorithm!\">PublicKeyAlgorithm</a></h2>\n<pre>type PublicKeyAlgorithm int</pre>\n\n",name:"PublicKeyAlgorithm","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SignatureAlgorithm!\">SignatureAlgorithm</a></h2>\n<pre>type SignatureAlgorithm int</pre>\n\n",name:"SignatureAlgorithm","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnhandledCriticalExtension!\">UnhandledCriticalExtension</a></h2>\n<pre>type UnhandledCriticalExtension struct{}</pre>\n\n",name:"UnhandledCriticalExtension","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnhandledCriticalExtension\">func (UnhandledCriticalExtension)</a> <a href=\"?m:UnhandledCriticalExtension.String!\">String</a></h2>\n<code>func (h UnhandledCriticalExtension) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsupportedAlgorithmError!\">UnsupportedAlgorithmError</a></h2>\n<pre>type UnsupportedAlgorithmError struct{}</pre>\n<p>\nUnsupportedAlgorithmError results from attempting to perform an operation\nthat involves algorithms that are not currently implemented.\n</p>\n\n",name:"UnsupportedAlgorithmError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnsupportedAlgorithmError\">func (UnsupportedAlgorithmError)</a> <a href=\"?m:UnsupportedAlgorithmError.String!\">String</a></h2>\n<code>func (UnsupportedAlgorithmError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CreateCertificate!\">CreateCertificate</a></h2>\n<code>func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err os.Error)</code>\n<p>\nCreateSelfSignedCertificate creates a new certificate based on\na template. The following members of template are used: SerialNumber,\nSubject, NotBefore, NotAfter, KeyUsage, BasicConstraintsValid, IsCA,\nMaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\nPermittedDNSDomains.\n</p>\n<p>\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n</p>\n<p>\nThe returned slice is the certificate in DER encoding.\n</p>\n\n",name:"CreateCertificate"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalPKCS1PrivateKey!\">MarshalPKCS1PrivateKey</a></h2>\n<code>func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</code>\n<p>\nMarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n</p>\n\n",name:"MarshalPKCS1PrivateKey"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseCertificate!\">ParseCertificate</a></h2>\n<code>func ParseCertificate(asn1Data []byte) (*Certificate, os.Error)</code>\n<p>\nParseCertificate parses a single certificate from the given ASN.1 DER data.\n</p>\n\n",name:"ParseCertificate"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseCertificates!\">ParseCertificates</a></h2>\n<code>func ParseCertificates(asn1Data []byte) ([]*Certificate, os.Error)</code>\n<p>\nParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n</p>\n\n",name:"ParseCertificates"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParsePKCS1PrivateKey!\">ParsePKCS1PrivateKey</a></h2>\n<code>func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error)</code>\n<p>\nParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n</p>\n\n",name:"ParsePKCS1PrivateKey"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:SignatureAlgorithm!\">SignatureAlgorithm</a></h2>\n<pre>const (\n\tUnknownSignatureAlgorithm SignatureAlgorithm = iota\n\tMD2WithRSA\n\tMD5WithRSA\n\tSHA1WithRSA\n\tSHA256WithRSA\n\tSHA384WithRSA\n\tSHA512WithRSA\n)</pre>\n\n",names:["UnknownSignatureAlgorithm","MD2WithRSA","MD5WithRSA","SHA1WithRSA","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA"],type:"SignatureAlgorithm"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:PublicKeyAlgorithm!\">PublicKeyAlgorithm</a></h2>\n<pre>const (\n\tUnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n\tRSA\n)</pre>\n\n",names:["UnknownPublicKeyAlgorithm","RSA"],type:"PublicKeyAlgorithm"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:KeyUsage!\">KeyUsage</a></h2>\n<pre>const (\n\tKeyUsageDigitalSignature KeyUsage = 1 &lt;&lt; iota\n\tKeyUsageContentCommitment\n\tKeyUsageKeyEncipherment\n\tKeyUsageDataEncipherment\n\tKeyUsageKeyAgreement\n\tKeyUsageCertSign\n\tKeyUsageCRLSign\n\tKeyUsageEncipherOnly\n\tKeyUsageDecipherOnly\n)</pre>\n\n",names:["KeyUsageDigitalSignature","KeyUsageContentCommitment","KeyUsageKeyEncipherment","KeyUsageDataEncipherment","KeyUsageKeyAgreement","KeyUsageCertSign","KeyUsageCRLSign","KeyUsageEncipherOnly","KeyUsageDecipherOnly"],type:"KeyUsage"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ExtKeyUsage!\">ExtKeyUsage</a></h2>\n<pre>const (\n\tExtKeyUsageAny ExtKeyUsage = iota\n\tExtKeyUsageServerAuth\n\tExtKeyUsageClientAuth\n\tExtKeyUsageCodeSigning\n\tExtKeyUsageEmailProtection\n\tExtKeyUsageTimeStamping\n\tExtKeyUsageOCSPSigning\n)</pre>\n\n",names:["ExtKeyUsageAny","ExtKeyUsageServerAuth","ExtKeyUsageClientAuth","ExtKeyUsageCodeSigning","ExtKeyUsageEmailProtection","ExtKeyUsageTimeStamping","ExtKeyUsageOCSPSigning"],type:"ExtKeyUsage"}],vars:[]}