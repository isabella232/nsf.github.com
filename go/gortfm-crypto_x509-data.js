var gortfmData = {index:"index.html",html:"<p>\nPackage x509 parses X.509-encoded keys and certificates.\n</p>\n",name:"x509",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CertPool!\">CertPool</a></h2>\n<pre>type CertPool struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nRoots is a set of certificates.\n</p>\n\n",name:"CertPool","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CertPool\">func (*CertPool)</a> <a href=\"?m:CertPool.AddCert!\">AddCert</a></h2>\n<code>func (s *CertPool) AddCert(cert *Certificate)</code>\n<p>\nAddCert adds a certificate to a pool.\n</p>\n\n",name:"AddCert"},{html:"\n<h2><a class=\"black\" href=\"?m:CertPool\">func (*CertPool)</a> <a href=\"?m:CertPool.AppendCertsFromPEM!\">AppendCertsFromPEM</a></h2>\n<code>func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool)</code>\n<p>\nAppendCertsFromPEM attempts to parse a series of PEM encoded root\ncertificates. It appends any certificates found to s and returns true if any\ncertificates were successfully parsed.\n</p>\n<p>\nOn many Linux systems, /etc/ssl/cert.pem will contains the system wide set\nof root CAs in a format suitable for this function.\n</p>\n\n",name:"AppendCertsFromPEM"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Certificate!\">Certificate</a></h2>\n<pre>type Certificate struct {\n\tRaw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).\n\tRawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.\n\tRawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.\n\n\tSignature          []byte\n\tSignatureAlgorithm SignatureAlgorithm\n\n\tPublicKeyAlgorithm PublicKeyAlgorithm\n\tPublicKey          interface{}\n\n\tVersion             int\n\tSerialNumber        []byte\n\tIssuer              Name\n\tSubject             Name\n\tNotBefore, NotAfter *time.Time // Validity bounds.\n\tKeyUsage            KeyUsage\n\n\tExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.\n\tUnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.\n\n\tBasicConstraintsValid bool // if true then the next two fields are valid.\n\tIsCA                  bool\n\tMaxPathLen            int\n\n\tSubjectKeyId   []byte\n\tAuthorityKeyId []byte\n\n\t// Subject Alternate Name values\n\tDNSNames       []string\n\tEmailAddresses []string\n\n\t// Name constraints\n\tPermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.\n\tPermittedDNSDomains         []string\n\n\tPolicyIdentifiers []asn1.ObjectIdentifier\n}</pre>\n<p>\nA Certificate represents an X.509 certificate.\n</p>\n\n",name:"Certificate","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.CheckCRLSignature!\">CheckCRLSignature</a></h2>\n<code>func (c *Certificate) CheckCRLSignature(crl *crl.CertificateList) (err os.Error)</code>\n<p>\nCheckCRLSignature checks that the signature in crl is from c.\n</p>\n\n",name:"CheckCRLSignature"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.CheckSignature!\">CheckSignature</a></h2>\n<code>func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err os.Error)</code>\n<p>\nCheckSignature verifies that signature is a valid signature over signed from\nc&#39;s public key.\n</p>\n\n",name:"CheckSignature"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.CheckSignatureFrom!\">CheckSignatureFrom</a></h2>\n<code>func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err os.Error)</code>\n<p>\nCheckSignatureFrom verifies that the signature on c is a valid signature\nfrom parent.\n</p>\n\n",name:"CheckSignatureFrom"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.Equal!\">Equal</a></h2>\n<code>func (c *Certificate) Equal(other *Certificate) bool</code>\n\n",name:"Equal"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.Verify!\">Verify</a></h2>\n<code>func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err os.Error)</code>\n<p>\nVerify attempts to verify c by building one or more chains from c to a\ncertificate in opts.roots, using certificates in opts.Intermediates if\nneeded. If successful, it returns one or chains where the first element of\nthe chain is c and the last element is from opts.Roots.\n</p>\n<p>\nWARNING: this doesn&#39;t do any revocation checking.\n</p>\n\n",name:"Verify"},{html:"\n<h2><a class=\"black\" href=\"?m:Certificate\">func (*Certificate)</a> <a href=\"?m:Certificate.VerifyHostname!\">VerifyHostname</a></h2>\n<code>func (c *Certificate) VerifyHostname(h string) os.Error</code>\n<p>\nVerifyHostname returns nil if c is a valid certificate for the named host.\nOtherwise it returns an os.Error describing the mismatch.\n</p>\n\n",name:"VerifyHostname"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CertificateInvalidError!\">CertificateInvalidError</a></h2>\n<pre>type CertificateInvalidError struct {\n\tCert   *Certificate\n\tReason InvalidReason\n}</pre>\n<p>\nCertificateInvalidError results when an odd error occurs. Users of this\nlibrary probably want to handle all these errors uniformly.\n</p>\n\n",name:"CertificateInvalidError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CertificateInvalidError\">func (CertificateInvalidError)</a> <a href=\"?m:CertificateInvalidError.String!\">String</a></h2>\n<code>func (e CertificateInvalidError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ConstraintViolationError!\">ConstraintViolationError</a></h2>\n<pre>type ConstraintViolationError struct{}</pre>\n<p>\nConstraintViolationError results when a requested usage is not permitted by\na certificate. For example: checking a signature when the public key isn&#39;t a\ncertificate signing key.\n</p>\n\n",name:"ConstraintViolationError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ConstraintViolationError\">func (ConstraintViolationError)</a> <a href=\"?m:ConstraintViolationError.String!\">String</a></h2>\n<code>func (ConstraintViolationError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ExtKeyUsage!\">ExtKeyUsage</a></h2>\n<pre>type ExtKeyUsage int</pre>\n<p>\nExtKeyUsage represents an extended set of actions that are valid for a given key.\nEach of the ExtKeyUsage* constants define a unique action.\n</p>\n\n",name:"ExtKeyUsage","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HostnameError!\">HostnameError</a></h2>\n<pre>type HostnameError struct {\n\tCertificate *Certificate\n\tHost        string\n}</pre>\n<p>\nHostnameError results when the set of authorized names doesn&#39;t match the\nrequested name.\n</p>\n\n",name:"HostnameError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HostnameError\">func (HostnameError)</a> <a href=\"?m:HostnameError.String!\">String</a></h2>\n<code>func (h HostnameError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidReason!\">InvalidReason</a></h2>\n<pre>type InvalidReason int</pre>\n\n",name:"InvalidReason","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeyUsage!\">KeyUsage</a></h2>\n<pre>type KeyUsage int</pre>\n<p>\nKeyUsage represents the set of actions that are valid for a given key. It&#39;s\na bitmap of the KeyUsage* constants.\n</p>\n\n",name:"KeyUsage","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\n<pre>type Name struct {\n\tCountry, Organization, OrganizationalUnit []string\n\tLocality, Province                        []string\n\tStreetAddress, PostalCode                 []string\n\tSerialNumber, CommonName                  string\n}</pre>\n<p>\nName represents an X.509 distinguished name. This only includes the common\nelements of a DN.  Additional elements in the name are ignored.\n</p>\n\n",name:"Name","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PublicKeyAlgorithm!\">PublicKeyAlgorithm</a></h2>\n<pre>type PublicKeyAlgorithm int</pre>\n\n",name:"PublicKeyAlgorithm","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SignatureAlgorithm!\">SignatureAlgorithm</a></h2>\n<pre>type SignatureAlgorithm int</pre>\n\n",name:"SignatureAlgorithm","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnhandledCriticalExtension!\">UnhandledCriticalExtension</a></h2>\n<pre>type UnhandledCriticalExtension struct{}</pre>\n\n",name:"UnhandledCriticalExtension","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnhandledCriticalExtension\">func (UnhandledCriticalExtension)</a> <a href=\"?m:UnhandledCriticalExtension.String!\">String</a></h2>\n<code>func (h UnhandledCriticalExtension) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownAuthorityError!\">UnknownAuthorityError</a></h2>\n<pre>type UnknownAuthorityError struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nUnknownAuthorityError results when the certificate issuer is unknown\n</p>\n\n",name:"UnknownAuthorityError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnknownAuthorityError\">func (UnknownAuthorityError)</a> <a href=\"?m:UnknownAuthorityError.String!\">String</a></h2>\n<code>func (e UnknownAuthorityError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsupportedAlgorithmError!\">UnsupportedAlgorithmError</a></h2>\n<pre>type UnsupportedAlgorithmError struct{}</pre>\n<p>\nUnsupportedAlgorithmError results from attempting to perform an operation\nthat involves algorithms that are not currently implemented.\n</p>\n\n",name:"UnsupportedAlgorithmError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnsupportedAlgorithmError\">func (UnsupportedAlgorithmError)</a> <a href=\"?m:UnsupportedAlgorithmError.String!\">String</a></h2>\n<code>func (UnsupportedAlgorithmError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:VerifyOptions!\">VerifyOptions</a></h2>\n<pre>type VerifyOptions struct {\n\tDNSName       string\n\tIntermediates *CertPool\n\tRoots         *CertPool\n\tCurrentTime   int64 // if 0, the current system time is used.\n}</pre>\n<p>\nVerifyOptions contains parameters for Certificate.Verify. It&#39;s a structure\nbecause other PKIX verification APIs have ended up needing many options.\n</p>\n\n",name:"VerifyOptions","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CreateCertificate!\">CreateCertificate</a></h2>\n<code>func CreateCertificate(rand io.Reader, template, parent *Certificate, pub *rsa.PublicKey, priv *rsa.PrivateKey) (cert []byte, err os.Error)</code>\n<p>\nCreateSelfSignedCertificate creates a new certificate based on\na template. The following members of template are used: SerialNumber,\nSubject, NotBefore, NotAfter, KeyUsage, BasicConstraintsValid, IsCA,\nMaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,\nPermittedDNSDomains.\n</p>\n<p>\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n</p>\n<p>\nThe returned slice is the certificate in DER encoding.\n</p>\n\n",name:"CreateCertificate"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalPKCS1PrivateKey!\">MarshalPKCS1PrivateKey</a></h2>\n<code>func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte</code>\n<p>\nMarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n</p>\n\n",name:"MarshalPKCS1PrivateKey"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCertPool!\">NewCertPool</a></h2>\n<code>func NewCertPool() *CertPool</code>\n<p>\nNewCertPool returns a new, empty CertPool.\n</p>\n\n",name:"NewCertPool"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseCertificate!\">ParseCertificate</a></h2>\n<code>func ParseCertificate(asn1Data []byte) (*Certificate, os.Error)</code>\n<p>\nParseCertificate parses a single certificate from the given ASN.1 DER data.\n</p>\n\n",name:"ParseCertificate"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseCertificates!\">ParseCertificates</a></h2>\n<code>func ParseCertificates(asn1Data []byte) ([]*Certificate, os.Error)</code>\n<p>\nParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n</p>\n\n",name:"ParseCertificates"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParsePKCS1PrivateKey!\">ParsePKCS1PrivateKey</a></h2>\n<code>func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error)</code>\n<p>\nParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n</p>\n\n",name:"ParsePKCS1PrivateKey"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:InvalidReason!\">InvalidReason</a></h2>\n<pre>const (\n\t// NotAuthorizedToSign results when a certificate is signed by another\n\t// which isn&#39;t marked as a CA certificate.\n\tNotAuthorizedToSign InvalidReason = iota\n\t// Expired results when a certificate has expired, based on the time\n\t// given in the VerifyOptions.\n\tExpired\n\t// CANotAuthorizedForThisName results when an intermediate or root\n\t// certificate has a name constraint which doesn&#39;t include the name\n\t// being checked.\n\tCANotAuthorizedForThisName\n)</pre>\n\n",names:["NotAuthorizedToSign","Expired","CANotAuthorizedForThisName"],type:"InvalidReason"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:SignatureAlgorithm!\">SignatureAlgorithm</a></h2>\n<pre>const (\n\tUnknownSignatureAlgorithm SignatureAlgorithm = iota\n\tMD2WithRSA\n\tMD5WithRSA\n\tSHA1WithRSA\n\tSHA256WithRSA\n\tSHA384WithRSA\n\tSHA512WithRSA\n\tDSAWithSHA1\n\tDSAWithSHA256\n)</pre>\n\n",names:["UnknownSignatureAlgorithm","MD2WithRSA","MD5WithRSA","SHA1WithRSA","SHA256WithRSA","SHA384WithRSA","SHA512WithRSA","DSAWithSHA1","DSAWithSHA256"],type:"SignatureAlgorithm"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:PublicKeyAlgorithm!\">PublicKeyAlgorithm</a></h2>\n<pre>const (\n\tUnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota\n\tRSA\n\tDSA\n)</pre>\n\n",names:["UnknownPublicKeyAlgorithm","RSA","DSA"],type:"PublicKeyAlgorithm"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:KeyUsage!\">KeyUsage</a></h2>\n<pre>const (\n\tKeyUsageDigitalSignature KeyUsage = 1 &lt;&lt; iota\n\tKeyUsageContentCommitment\n\tKeyUsageKeyEncipherment\n\tKeyUsageDataEncipherment\n\tKeyUsageKeyAgreement\n\tKeyUsageCertSign\n\tKeyUsageCRLSign\n\tKeyUsageEncipherOnly\n\tKeyUsageDecipherOnly\n)</pre>\n\n",names:["KeyUsageDigitalSignature","KeyUsageContentCommitment","KeyUsageKeyEncipherment","KeyUsageDataEncipherment","KeyUsageKeyAgreement","KeyUsageCertSign","KeyUsageCRLSign","KeyUsageEncipherOnly","KeyUsageDecipherOnly"],type:"KeyUsage"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ExtKeyUsage!\">ExtKeyUsage</a></h2>\n<pre>const (\n\tExtKeyUsageAny ExtKeyUsage = iota\n\tExtKeyUsageServerAuth\n\tExtKeyUsageClientAuth\n\tExtKeyUsageCodeSigning\n\tExtKeyUsageEmailProtection\n\tExtKeyUsageTimeStamping\n\tExtKeyUsageOCSPSigning\n)</pre>\n\n",names:["ExtKeyUsageAny","ExtKeyUsageServerAuth","ExtKeyUsageClientAuth","ExtKeyUsageCodeSigning","ExtKeyUsageEmailProtection","ExtKeyUsageTimeStamping","ExtKeyUsageOCSPSigning"],type:"ExtKeyUsage"}],vars:[]}