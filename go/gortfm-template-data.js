var gortfmData = {index:"index.html",html:"<p>\nData-driven templates for generating textual output such as\nHTML.\n</p>\n<p>\nTemplates are executed by applying them to a data structure.\nAnnotations in the template refer to elements of the data\nstructure (typically a field of a struct or a key in a map)\nto control execution and derive values to be displayed.\nThe template walks the structure as it executes and the\n&#34;cursor&#34; @ represents the value at the current location\nin the structure.\n</p>\n<p>\nData items may be values or pointers; the interface hides the\nindirection.\n</p>\n<p>\nIn the following, &#39;field&#39; is one of several things, according to the data.\n</p>\n<pre>- The name of a field of a struct (result = data.field),\n- The value stored in a map under that key (result = data[field]), or\n- The result of invoking a niladic single-valued method with that name\n  (result = data.field())\n</pre>\n<p>\nMajor constructs ({} are metacharacters; [] marks optional elements):\n</p>\n<pre>{# comment }\n</pre>\n<p>\nA one-line comment.\n</p>\n<pre>{.section field} XXX [ {.or} YYY ] {.end}\n</pre>\n<p>\nSet @ to the value of the field.  It may be an explicit @\nto stay at the same point in the data. If the field is nil\nor empty, execute YYY; otherwise execute XXX.\n</p>\n<pre>{.repeated section field} XXX [ {.alternates with} ZZZ ] [ {.or} YYY ] {.end}\n</pre>\n<p>\nLike .section, but field must be an array or slice.  XXX\nis executed for each element.  If the array is nil or empty,\nYYY is executed instead.  If the {.alternates with} marker\nis present, ZZZ is executed between iterations of XXX.\n</p>\n<pre>{field}\n{field1 field2 ...}\n{field|formatter}\n{field1 field2...|formatter}\n</pre>\n<p>\nInsert the value of the fields into the output. Each field is\nfirst looked for in the cursor, as in .section and .repeated.\nIf it is not found, the search continues in outer sections\nuntil the top level is reached.\n</p>\n<p>\nIf a formatter is specified, it must be named in the formatter\nmap passed to the template set up routines or in the default\nset (&#34;html&#34;,&#34;str&#34;,&#34;&#34;) and is used to process the data for\noutput.  The formatter function has signature\n</p>\n<pre>func(wr io.Writer, formatter string, data ...interface{})\n</pre>\n<p>\nwhere wr is the destination for output, data holds the field\nvalues at the instantiation, and formatter is its name at\nthe invocation site.  The default formatter just concatenates\nthe string representations of the fields.\n</p>\n",name:"template",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\n<pre>type Error struct {\n\tLine int\n\tMsg  string\n}</pre>\n<p>\nErrors returned during parsing and execution.  Users may extract the information and reformat\nif they desire.\n</p>\n\n",name:"Error","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Error\">func (*Error)</a> <a href=\"?m:Error.String!\">String</a></h2>\n<code>func (e *Error) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatterMap!\">FormatterMap</a></h2>\n<pre>type FormatterMap map[string]func(io.Writer, string, ...interface{})</pre>\n<p>\nFormatterMap is the type describing the mapping from formatter\nnames to the functions that implement them.\n</p>\n\n",name:"FormatterMap","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Template!\">Template</a></h2>\n<pre>type Template struct {\n\t// contains unexported fields\n}</pre>\n<p>\nTemplate is the type that represents a template definition.\nIt is unchanged after parsing.\n</p>\n\n",name:"Template","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Template\">func (*Template)</a> <a href=\"?m:Template.Execute!\">Execute</a></h2>\n<code>func (t *Template) Execute(data interface{}, wr io.Writer) (err os.Error)</code>\n<p>\nExecute applies a parsed template to the specified data object,\ngenerating output to wr.\n</p>\n\n",name:"Execute"},{html:"\n<h2><a class=\"black\" href=\"?m:Template\">func (*Template)</a> <a href=\"?m:Template.Parse!\">Parse</a></h2>\n<code>func (t *Template) Parse(s string) (err os.Error)</code>\n<p>\nParse initializes a Template by parsing its definition.  The string\ns contains the template text.  If any errors occur, Parse returns\nthe error.\n</p>\n\n",name:"Parse"},{html:"\n<h2><a class=\"black\" href=\"?m:Template\">func (*Template)</a> <a href=\"?m:Template.ParseFile!\">ParseFile</a></h2>\n<code>func (t *Template) ParseFile(filename string) (err os.Error)</code>\n<p>\nParseFile is like Parse but reads the template definition from the\nnamed file.\n</p>\n\n",name:"ParseFile"},{html:"\n<h2><a class=\"black\" href=\"?m:Template\">func (*Template)</a> <a href=\"?m:Template.SetDelims!\">SetDelims</a></h2>\n<code>func (t *Template) SetDelims(left, right string)</code>\n<p>\nSetDelims sets the left and right delimiters for operations in the\ntemplate.  They are validated during parsing.  They could be\nvalidated here but it&#39;s better to keep the routine simple.  The\ndelimiters are very rarely invalid and Parse has the necessary\nerror-handling interface already.\n</p>\n\n",name:"SetDelims"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HTMLEscape!\">HTMLEscape</a></h2>\n<code>func HTMLEscape(w io.Writer, s []byte)</code>\n<p>\nHTMLEscape writes to w the properly escaped HTML equivalent\nof the plain text data s.\n</p>\n\n",name:"HTMLEscape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HTMLFormatter!\">HTMLFormatter</a></h2>\n<code>func HTMLFormatter(w io.Writer, format string, value ...interface{})</code>\n<p>\nHTMLFormatter formats arbitrary values for HTML\n</p>\n\n",name:"HTMLFormatter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MustParse!\">MustParse</a></h2>\n<code>func MustParse(s string, fmap FormatterMap) *Template</code>\n<p>\nMustParse is like Parse but panics if the template cannot be parsed.\n</p>\n\n",name:"MustParse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MustParseFile!\">MustParseFile</a></h2>\n<code>func MustParseFile(filename string, fmap FormatterMap) *Template</code>\n<p>\nMustParseFile is like ParseFile but panics if the file cannot be read\nor the template cannot be parsed.\n</p>\n\n",name:"MustParseFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:New!\">New</a></h2>\n<code>func New(fmap FormatterMap) *Template</code>\n<p>\nNew creates a new template with the specified formatter map (which\nmay be nil) to define auxiliary functions for formatting variables.\n</p>\n\n",name:"New"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\n<code>func Parse(s string, fmap FormatterMap) (t *Template, err os.Error)</code>\n<p>\nParse creates a Template with default parameters (such as {} for\nmetacharacters).  The string s contains the template text while\nthe formatter map fmap, which may be nil, defines auxiliary functions\nfor formatting variables.  The template is returned. If any errors\noccur, err will be non-nil.\n</p>\n\n",name:"Parse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseFile!\">ParseFile</a></h2>\n<code>func ParseFile(filename string, fmap FormatterMap) (t *Template, err os.Error)</code>\n<p>\nParseFile is a wrapper function that creates a Template with default\nparameters (such as {} for metacharacters).  The filename identifies\na file containing the template text, while the formatter map fmap, which\nmay be nil, defines auxiliary functions for formatting variables.\nThe template is returned. If any errors occur, err will be non-nil.\n</p>\n\n",name:"ParseFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:StringFormatter!\">StringFormatter</a></h2>\n<code>func StringFormatter(w io.Writer, format string, value ...interface{})</code>\n<p>\nStringFormatter formats into the default string representation.\nIt is stored under the name &#34;str&#34; and is the default formatter.\nYou can override the default formatter by storing your default\nunder the name &#34;&#34; in your custom formatter map.\n</p>\n\n",name:"StringFormatter"}],consts:[],vars:[]}