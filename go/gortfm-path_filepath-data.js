var gortfmData = {index:"index.html",html:"<p>\nThe filepath package implements utility routines for manipulating\nfilename paths in a way compatible with the target operating\nsystem-defined file paths.\n</p>\n",name:"filepath",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Visitor!\">Visitor</a></h2>\n<pre>type Visitor interface {\n\tVisitDir(path string, f *os.FileInfo) bool\n\tVisitFile(path string, f *os.FileInfo)\n}</pre>\n<p>\nVisitor methods are invoked for corresponding file tree entries\nvisited by Walk. The parameter path is the full path of f relative\nto root.\n</p>\n\n",name:"Visitor","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Base!\">Base</a></h2>\n<code>func Base(path string) string</code>\n<p>\nBase returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns &#34;.&#34;.\nIf the path consists entirely of separators, Base returns a single separator.\n</p>\n\n",name:"Base"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Clean!\">Clean</a></h2>\n<code>func Clean(path string) string</code>\n<p>\nClean returns the shortest path name equivalent to path\nby purely lexical processing.  It applies the following rules\niteratively until no further processing can be done:\n</p>\n<pre>\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace &#34;/..&#34; by &#34;/&#34; at the beginning of a path,\n        assuming Separator is &#39;/&#39;.\n</pre>\n<p>\nIf the result of this process is an empty string, Clean\nreturns the string &#34;.&#34;.\n</p>\n<p>\nSee also Rob Pike, &ldquo;Lexical File Names in Plan 9 or\nGetting Dot-Dot right,&rdquo;\n<a href=\"http://plan9.bell-labs.com/sys/doc/lexnames.html\">http://plan9.bell-labs.com/sys/doc/lexnames.html</a>\n</p>\n\n",name:"Clean"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ext!\">Ext</a></h2>\n<code>func Ext(path string) string</code>\n<p>\nExt returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n</p>\n\n",name:"Ext"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FromSlash!\">FromSlash</a></h2>\n<code>func FromSlash(path string) string</code>\n<p>\nFromSlash returns the result of replacing each slash (&#39;/&#39;) character\nin path with a separator character.\n</p>\n\n",name:"FromSlash"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Glob!\">Glob</a></h2>\n<code>func Glob(pattern string) (matches []string)</code>\n<p>\nGlob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is &#39;/&#39;).\n</p>\n\n",name:"Glob"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IsAbs!\">IsAbs</a></h2>\n<code>func IsAbs(path string) bool</code>\n<p>\nIsAbs returns true if the path is absolute.\n</p>\n\n",name:"IsAbs"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Join!\">Join</a></h2>\n<code>func Join(elem ...string) string</code>\n<p>\nJoin joins any number of path elements into a single path, adding\na Separator if necessary.  All empty strings are ignored.\n</p>\n\n",name:"Join"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Match!\">Match</a></h2>\n<code>func Match(pattern, name string) (matched bool, err os.Error)</code>\n<p>\nMatch returns true if name matches the shell file name pattern.\nThe pattern syntax is:\n</p>\n<pre>pattern:\n\t{ term }\nterm:\n\t&#39;*&#39;         matches any sequence of non-Separator characters\n\t&#39;?&#39;         matches any single non-Separator character\n\t&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;\n\t            character class (must be non-empty)\n\tc           matches character c (c != &#39;*&#39;, &#39;?&#39;, &#39;\\\\&#39;, &#39;[&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\ncharacter-range:\n\tc           matches character c (c != &#39;\\\\&#39;, &#39;-&#39;, &#39;]&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\tlo &#39;-&#39; hi   matches character c for lo &lt;= c &lt;= hi\n</pre>\n<p>\nMatch requires pattern to match all of name, not just a substring.\nThe only possible error return is when pattern is malformed.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Split!\">Split</a></h2>\n<code>func Split(path string) (dir, file string)</code>\n<p>\nSplit splits path immediately following the final Separator,\npartitioning it into a directory and a file name components.\nIf there are no separators in path, Split returns an empty base\nand file set to path.\n</p>\n\n",name:"Split"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SplitList!\">SplitList</a></h2>\n<code>func SplitList(path string) []string</code>\n<p>\nSplitList splits a list of paths joined by the OS-specific ListSeparator.\n</p>\n\n",name:"SplitList"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToSlash!\">ToSlash</a></h2>\n<code>func ToSlash(path string) string</code>\n<p>\nToSlash returns the result of replacing each separator character\nin path with a slash (&#39;/&#39;) character.\n</p>\n\n",name:"ToSlash"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Walk!\">Walk</a></h2>\n<code>func Walk(root string, v Visitor, errors chan&lt;- os.Error)</code>\n<p>\nWalk walks the file tree rooted at root, calling v.VisitDir or\nv.VisitFile for each directory or file in the tree, including root.\nIf v.VisitDir returns false, Walk skips the directory&#39;s entries;\notherwise it invokes itself for each directory entry in sorted order.\nAn error reading a directory does not abort the Walk.\nIf errors != nil, Walk sends each directory read error\nto the channel.  Otherwise Walk discards the error.\n</p>\n\n",name:"Walk"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Separator!\"><em>group</em></a></h2>\n<pre>const (\n\tSeparator     = &#39;/&#39; // OS-specific path separator\n\tListSeparator = &#39;:&#39; // OS-specific path list separator\n)</pre>\n\n",names:["Separator","ListSeparator"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrBadPattern!\">ErrBadPattern</a></h2>\n<pre>var ErrBadPattern = os.NewError(&#34;syntax error in pattern&#34;)</pre>\n\n",names:["ErrBadPattern"],type:""}]}