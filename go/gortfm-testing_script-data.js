var gortfmData = {index:"index.html",html:"<p>\nPackage script aids in the testing of code that uses channels.\n</p>\n",name:"script",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Close!\">Close</a></h2>\n<pre>type Close struct {\n\tChannel interface{}\n}</pre>\n<p>\nA Close action closes the given channel.\n</p>\n\n",name:"Close","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Closed!\">Closed</a></h2>\n<pre>type Closed struct {\n\tChannel interface{}\n}</pre>\n<p>\nA Closed action matches if the given channel is closed. The closing is\ntreated as an event, not a state, thus Closed will only match once for a\ngiven channel.\n</p>\n\n",name:"Closed","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Event!\">Event</a></h2>\n<pre>type Event struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nAn Event is an element in a partially ordered set that either sends a value\nto a channel or expects a value from a channel.\n</p>\n\n",name:"Event","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReceivedUnexpected!\">ReceivedUnexpected</a></h2>\n<pre>type ReceivedUnexpected struct {\n\tValue interface{}\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA ReceivedUnexpected error results if no active Events match a value\nreceived from a channel.\n</p>\n\n",name:"ReceivedUnexpected","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReceivedUnexpected\">func (ReceivedUnexpected)</a> <a href=\"?m:ReceivedUnexpected.String!\">String</a></h2>\n<code>func (r ReceivedUnexpected) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Recv!\">Recv</a></h2>\n<pre>type Recv struct {\n\tChannel  interface{}\n\tExpected interface{}\n}</pre>\n<p>\nA Recv action reads a value from a channel and uses reflect.DeepMatch to\ncompare it with an expected value.\n</p>\n\n",name:"Recv","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RecvMatch!\">RecvMatch</a></h2>\n<pre>type RecvMatch struct {\n\tChannel interface{}\n\tMatch   func(interface{}) bool\n}</pre>\n<p>\nA RecvMatch action reads a value from a channel and calls a function to\ndetermine if the value matches.\n</p>\n\n",name:"RecvMatch","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Send!\">Send</a></h2>\n<pre>type Send struct {\n\tChannel interface{}\n\tValue   interface{}\n}</pre>\n<p>\nA Send action sends a value to a channel. The value must match the\ntype of the channel exactly unless the channel if of type chan interface{}.\n</p>\n\n",name:"Send","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SetupError!\">SetupError</a></h2>\n<pre>type SetupError string</pre>\n<p>\nA SetupError results if there is a error with the configuration of a set of\nEvents.\n</p>\n\n",name:"SetupError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SetupError\">func (SetupError)</a> <a href=\"?m:SetupError.String!\">String</a></h2>\n<code>func (s SetupError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEvent!\">NewEvent</a></h2>\n<code>func NewEvent(name string, predecessors []*Event, action action) *Event</code>\n\n",name:"NewEvent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Perform!\">Perform</a></h2>\n<code>func Perform(seed int64, events []*Event) (err os.Error)</code>\n<p>\nGiven a set of Events, Perform repeatedly iterates over the set and finds the\nsubset of ready Events (that is, all of their predecessors have\noccurred). From that subset, it pseudo-randomly selects an Event to perform.\nIf the Event is a send event, the send occurs and Perform recalculates the ready\nset. If the event is a receive event, Perform waits for a value from any of the\nchannels that are contained in any of the events. That value is then matched\nagainst the ready events. The first event that matches is considered to\nhave occurred and Perform recalculates the ready set.\n</p>\n<p>\nPerform continues this until all Events have occurred.\n</p>\n<p>\nNote that uncollected goroutines may still be reading from any of the\nchannels read from after Perform returns.\n</p>\n<p>\nFor example, consider the problem of testing a function that reads values on\none channel and echos them to two output channels. To test this we would\ncreate three events: a send event and two receive events. Each of the\nreceive events must list the send event as a predecessor but there is no\nordering between the receive events.\n</p>\n<pre>send := NewEvent(&#34;send&#34;, nil, Send{c, 1})\nrecv1 := NewEvent(&#34;recv 1&#34;, []*Event{send}, Recv{c, 1})\nrecv2 := NewEvent(&#34;recv 2&#34;, []*Event{send}, Recv{c, 1})\nPerform(0, []*Event{send, recv1, recv2})\n</pre>\n<p>\nAt first, only the send event would be in the ready set and thus Perform will\nsend a value to the input channel. Now the two receive events are ready and\nPerform will match each of them against the values read from the output channels.\n</p>\n<p>\nIt would be invalid to list one of the receive events as a predecessor of\nthe other. At each receive step, all the receive channels are considered,\nthus Perform may see a value from a channel that is not in the current ready\nset and fail.\n</p>\n\n",name:"Perform"}],consts:[],vars:[]}