var gortfmData = {index:"index.html",html:"<p>\nPackage image implements a basic 2-D image library.\n</p>\n",name:"image",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha!\">Alpha</a></h2>\n<pre>type Alpha struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []AlphaColor\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn Alpha is an in-memory image of AlphaColor values.\n</p>\n\n",name:"Alpha","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.At!\">At</a></h2>\n<code>func (p *Alpha) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Bounds!\">Bounds</a></h2>\n<code>func (p *Alpha) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.ColorModel!\">ColorModel</a></h2>\n<code>func (p *Alpha) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Opaque!\">Opaque</a></h2>\n<code>func (p *Alpha) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha\">func (*Alpha)</a> <a href=\"?m:Alpha.Set!\">Set</a></h2>\n<code>func (p *Alpha) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha16!\">Alpha16</a></h2>\n<pre>type Alpha16 struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []Alpha16Color\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn Alpha16 is an in-memory image of Alpha16Color values.\n</p>\n\n",name:"Alpha16","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.At!\">At</a></h2>\n<code>func (p *Alpha16) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Bounds!\">Bounds</a></h2>\n<code>func (p *Alpha16) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.ColorModel!\">ColorModel</a></h2>\n<code>func (p *Alpha16) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Opaque!\">Opaque</a></h2>\n<code>func (p *Alpha16) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16\">func (*Alpha16)</a> <a href=\"?m:Alpha16.Set!\">Set</a></h2>\n<code>func (p *Alpha16) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alpha16Color!\">Alpha16Color</a></h2>\n<pre>type Alpha16Color struct {\n\tA uint16\n}</pre>\n<p>\nAn Alpha16Color represents a 16-bit alpha.\n</p>\n\n",name:"Alpha16Color","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Alpha16Color\">func (Alpha16Color)</a> <a href=\"?m:Alpha16Color.RGBA!\">RGBA</a></h2>\n<code>func (c Alpha16Color) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AlphaColor!\">AlphaColor</a></h2>\n<pre>type AlphaColor struct {\n\tA uint8\n}</pre>\n<p>\nAn AlphaColor represents an 8-bit alpha.\n</p>\n\n",name:"AlphaColor","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:AlphaColor\">func (AlphaColor)</a> <a href=\"?m:AlphaColor.RGBA!\">RGBA</a></h2>\n<code>func (c AlphaColor) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Color!\">Color</a></h2>\n<pre>type Color interface {\n\tRGBA() (r, g, b, a uint32)\n}</pre>\n<p>\nAll Colors can convert themselves, with a possible loss of precision,\nto 64-bit alpha-premultiplied RGBA. Each channel value ranges within\n[0, 0xFFFF].\n</p>\n\n",name:"Color","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorImage!\">ColorImage</a></h2>\n<pre>type ColorImage struct {\n\tC Color\n}</pre>\n<p>\nA ColorImage is an infinite-sized Image of uniform Color.\nIt implements both the Color and Image interfaces.\n</p>\n\n",name:"ColorImage","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.At!\">At</a></h2>\n<code>func (c *ColorImage) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.Bounds!\">Bounds</a></h2>\n<code>func (c *ColorImage) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.ColorModel!\">ColorModel</a></h2>\n<code>func (c *ColorImage) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.Opaque!\">Opaque</a></h2>\n<code>func (c *ColorImage) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:ColorImage\">func (*ColorImage)</a> <a href=\"?m:ColorImage.RGBA!\">RGBA</a></h2>\n<code>func (c *ColorImage) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorModel!\">ColorModel</a></h2>\n<pre>type ColorModel interface {\n\tConvert(c Color) Color\n}</pre>\n<p>\nA ColorModel can convert foreign Colors, with a possible loss of precision,\nto a Color from its own color model.\n</p>\n\n",name:"ColorModel","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ColorModelFunc!\">ColorModelFunc</a></h2>\n<pre>type ColorModelFunc func(Color) Color</pre>\n<p>\nThe ColorModelFunc type is an adapter to allow the use of an ordinary\ncolor conversion function as a ColorModel.  If f is such a function,\nColorModelFunc(f) is a ColorModel object that invokes f to implement\nthe conversion.\n</p>\n\n",name:"ColorModelFunc","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ColorModelFunc\">func (ColorModelFunc)</a> <a href=\"?m:ColorModelFunc.Convert!\">Convert</a></h2>\n<code>func (f ColorModelFunc) Convert(c Color) Color</code>\n\n",name:"Convert"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Config!\">Config</a></h2>\n<pre>type Config struct {\n\tColorModel    ColorModel\n\tWidth, Height int\n}</pre>\n<p>\nA Config consists of an image&#39;s color model and dimensions.\n</p>\n\n",name:"Config","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray!\">Gray</a></h2>\n<pre>type Gray struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []GrayColor\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nA Gray is an in-memory image of GrayColor values.\n</p>\n\n",name:"Gray","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.At!\">At</a></h2>\n<code>func (p *Gray) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Bounds!\">Bounds</a></h2>\n<code>func (p *Gray) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.ColorModel!\">ColorModel</a></h2>\n<code>func (p *Gray) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Opaque!\">Opaque</a></h2>\n<code>func (p *Gray) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray\">func (*Gray)</a> <a href=\"?m:Gray.Set!\">Set</a></h2>\n<code>func (p *Gray) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray16!\">Gray16</a></h2>\n<pre>type Gray16 struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []Gray16Color\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nA Gray16 is an in-memory image of Gray16Color values.\n</p>\n\n",name:"Gray16","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.At!\">At</a></h2>\n<code>func (p *Gray16) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Bounds!\">Bounds</a></h2>\n<code>func (p *Gray16) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.ColorModel!\">ColorModel</a></h2>\n<code>func (p *Gray16) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Opaque!\">Opaque</a></h2>\n<code>func (p *Gray16) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:Gray16\">func (*Gray16)</a> <a href=\"?m:Gray16.Set!\">Set</a></h2>\n<code>func (p *Gray16) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Gray16Color!\">Gray16Color</a></h2>\n<pre>type Gray16Color struct {\n\tY uint16\n}</pre>\n<p>\nA Gray16Color represents a 16-bit grayscale color.\n</p>\n\n",name:"Gray16Color","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Gray16Color\">func (Gray16Color)</a> <a href=\"?m:Gray16Color.RGBA!\">RGBA</a></h2>\n<code>func (c Gray16Color) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GrayColor!\">GrayColor</a></h2>\n<pre>type GrayColor struct {\n\tY uint8\n}</pre>\n<p>\nA GrayColor represents an 8-bit grayscale color.\n</p>\n\n",name:"GrayColor","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:GrayColor\">func (GrayColor)</a> <a href=\"?m:GrayColor.RGBA!\">RGBA</a></h2>\n<code>func (c GrayColor) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Image!\">Image</a></h2>\n<pre>type Image interface {\n\t// ColorModel returns the Image&#39;s ColorModel.\n\tColorModel() ColorModel\n\t// Bounds returns the domain for which At can return non-zero color.\n\t// The bounds do not necessarily contain the point (0, 0).\n\tBounds() Rectangle\n\t// At returns the color of the pixel at (x, y).\n\t// At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.\n\t// At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.\n\tAt(x, y int) Color\n}</pre>\n<p>\nAn Image is a finite rectangular grid of Colors drawn from a ColorModel.\n</p>\n\n",name:"Image","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA!\">NRGBA</a></h2>\n<pre>type NRGBA struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []NRGBAColor\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn NRGBA is an in-memory image of NRGBAColor values.\n</p>\n\n",name:"NRGBA","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.At!\">At</a></h2>\n<code>func (p *NRGBA) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Bounds!\">Bounds</a></h2>\n<code>func (p *NRGBA) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.ColorModel!\">ColorModel</a></h2>\n<code>func (p *NRGBA) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Opaque!\">Opaque</a></h2>\n<code>func (p *NRGBA) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA\">func (*NRGBA)</a> <a href=\"?m:NRGBA.Set!\">Set</a></h2>\n<code>func (p *NRGBA) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA64!\">NRGBA64</a></h2>\n<pre>type NRGBA64 struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []NRGBA64Color\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn NRGBA64 is an in-memory image of NRGBA64Color values.\n</p>\n\n",name:"NRGBA64","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.At!\">At</a></h2>\n<code>func (p *NRGBA64) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Bounds!\">Bounds</a></h2>\n<code>func (p *NRGBA64) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.ColorModel!\">ColorModel</a></h2>\n<code>func (p *NRGBA64) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Opaque!\">Opaque</a></h2>\n<code>func (p *NRGBA64) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64\">func (*NRGBA64)</a> <a href=\"?m:NRGBA64.Set!\">Set</a></h2>\n<code>func (p *NRGBA64) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBA64Color!\">NRGBA64Color</a></h2>\n<pre>type NRGBA64Color struct {\n\tR, G, B, A uint16\n}</pre>\n<p>\nAn NRGBA64Color represents a non-alpha-premultiplied 64-bit color,\nhaving 16 bits for each of red, green, blue and alpha.\n</p>\n\n",name:"NRGBA64Color","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NRGBA64Color\">func (NRGBA64Color)</a> <a href=\"?m:NRGBA64Color.RGBA!\">RGBA</a></h2>\n<code>func (c NRGBA64Color) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NRGBAColor!\">NRGBAColor</a></h2>\n<pre>type NRGBAColor struct {\n\tR, G, B, A uint8\n}</pre>\n<p>\nAn NRGBAColor represents a non-alpha-premultiplied 32-bit color.\n</p>\n\n",name:"NRGBAColor","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NRGBAColor\">func (NRGBAColor)</a> <a href=\"?m:NRGBAColor.RGBA!\">RGBA</a></h2>\n<code>func (c NRGBAColor) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Paletted!\">Paletted</a></h2>\n<pre>type Paletted struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []uint8\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n\t// Palette is the image&#39;s palette.\n\tPalette PalettedColorModel\n}</pre>\n<p>\nA Paletted is an in-memory image backed by a 2-D slice of uint8 values and a PalettedColorModel.\n</p>\n\n",name:"Paletted","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.At!\">At</a></h2>\n<code>func (p *Paletted) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.Bounds!\">Bounds</a></h2>\n<code>func (p *Paletted) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.ColorIndexAt!\">ColorIndexAt</a></h2>\n<code>func (p *Paletted) ColorIndexAt(x, y int) uint8</code>\n\n",name:"ColorIndexAt"},{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.ColorModel!\">ColorModel</a></h2>\n<code>func (p *Paletted) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.Opaque!\">Opaque</a></h2>\n<code>func (p *Paletted) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:Paletted\">func (*Paletted)</a> <a href=\"?m:Paletted.SetColorIndex!\">SetColorIndex</a></h2>\n<code>func (p *Paletted) SetColorIndex(x, y int, index uint8)</code>\n\n",name:"SetColorIndex"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PalettedColorModel!\">PalettedColorModel</a></h2>\n<pre>type PalettedColorModel []Color</pre>\n<p>\nA PalettedColorModel represents a fixed palette of colors.\n</p>\n\n",name:"PalettedColorModel","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PalettedColorModel\">func (PalettedColorModel)</a> <a href=\"?m:PalettedColorModel.Convert!\">Convert</a></h2>\n<code>func (p PalettedColorModel) Convert(c Color) Color</code>\n<p>\nConvert returns the palette color closest to c in Euclidean R,G,B space.\n</p>\n\n",name:"Convert"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Point!\">Point</a></h2>\n<pre>type Point struct {\n\tX, Y int\n}</pre>\n<p>\nA Point is an X, Y coordinate pair. The axes increase right and down.\n</p>\n\n",name:"Point","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Add!\">Add</a></h2>\n<code>func (p Point) Add(q Point) Point</code>\n<p>\nAdd returns the vector p+q.\n</p>\n\n",name:"Add"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Div!\">Div</a></h2>\n<code>func (p Point) Div(k int) Point</code>\n<p>\nDiv returns the vector p/k.\n</p>\n\n",name:"Div"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Eq!\">Eq</a></h2>\n<code>func (p Point) Eq(q Point) bool</code>\n<p>\nEq returns whether p and q are equal.\n</p>\n\n",name:"Eq"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Mod!\">Mod</a></h2>\n<code>func (p Point) Mod(r Rectangle) Point</code>\n<p>\nMod returns the point q in r such that p.X-q.X is a multiple of r&#39;s width\nand p.Y-q.Y is a multiple of r&#39;s height.\n</p>\n\n",name:"Mod"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Mul!\">Mul</a></h2>\n<code>func (p Point) Mul(k int) Point</code>\n<p>\nMul returns the vector p*k.\n</p>\n\n",name:"Mul"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.String!\">String</a></h2>\n<code>func (p Point) String() string</code>\n<p>\nString returns a string representation of p like &#34;(3,4)&#34;.\n</p>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:Point\">func (Point)</a> <a href=\"?m:Point.Sub!\">Sub</a></h2>\n<code>func (p Point) Sub(q Point) Point</code>\n<p>\nSub returns the vector p-q.\n</p>\n\n",name:"Sub"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA!\">RGBA</a></h2>\n<pre>type RGBA struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []RGBAColor\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn RGBA is an in-memory image of RGBAColor values.\n</p>\n\n",name:"RGBA","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.At!\">At</a></h2>\n<code>func (p *RGBA) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Bounds!\">Bounds</a></h2>\n<code>func (p *RGBA) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.ColorModel!\">ColorModel</a></h2>\n<code>func (p *RGBA) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Opaque!\">Opaque</a></h2>\n<code>func (p *RGBA) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA\">func (*RGBA)</a> <a href=\"?m:RGBA.Set!\">Set</a></h2>\n<code>func (p *RGBA) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA64!\">RGBA64</a></h2>\n<pre>type RGBA64 struct {\n\t// Pix holds the image&#39;s pixels. The pixel at (x, y) is Pix[y*Stride+x].\n\tPix    []RGBA64Color\n\tStride int\n\t// Rect is the image&#39;s bounds.\n\tRect Rectangle\n}</pre>\n<p>\nAn RGBA64 is an in-memory image of RGBA64Color values.\n</p>\n\n",name:"RGBA64","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.At!\">At</a></h2>\n<code>func (p *RGBA64) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Bounds!\">Bounds</a></h2>\n<code>func (p *RGBA64) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.ColorModel!\">ColorModel</a></h2>\n<code>func (p *RGBA64) ColorModel() ColorModel</code>\n\n",name:"ColorModel"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Opaque!\">Opaque</a></h2>\n<code>func (p *RGBA64) Opaque() bool</code>\n<p>\nOpaque scans the entire image and returns whether or not it is fully opaque.\n</p>\n\n",name:"Opaque"},{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64\">func (*RGBA64)</a> <a href=\"?m:RGBA64.Set!\">Set</a></h2>\n<code>func (p *RGBA64) Set(x, y int, c Color)</code>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBA64Color!\">RGBA64Color</a></h2>\n<pre>type RGBA64Color struct {\n\tR, G, B, A uint16\n}</pre>\n<p>\nAn RGBA64Color represents a 64-bit alpha-premultiplied color,\nhaving 16 bits for each of red, green, blue and alpha.\n</p>\n\n",name:"RGBA64Color","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RGBA64Color\">func (RGBA64Color)</a> <a href=\"?m:RGBA64Color.RGBA!\">RGBA</a></h2>\n<code>func (c RGBA64Color) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RGBAColor!\">RGBAColor</a></h2>\n<pre>type RGBAColor struct {\n\tR, G, B, A uint8\n}</pre>\n<p>\nAn RGBAColor represents a traditional 32-bit alpha-premultiplied color,\nhaving 8 bits for each of red, green, blue and alpha.\n</p>\n\n",name:"RGBAColor","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RGBAColor\">func (RGBAColor)</a> <a href=\"?m:RGBAColor.RGBA!\">RGBA</a></h2>\n<code>func (c RGBAColor) RGBA() (r, g, b, a uint32)</code>\n\n",name:"RGBA"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Rectangle!\">Rectangle</a></h2>\n<pre>type Rectangle struct {\n\tMin, Max Point\n}</pre>\n<p>\nA Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y.\nIt is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always\nwell-formed. A rectangle&#39;s methods always return well-formed outputs for\nwell-formed inputs.\n</p>\n\n",name:"Rectangle","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Add!\">Add</a></h2>\n<code>func (r Rectangle) Add(p Point) Rectangle</code>\n<p>\nAdd returns the rectangle r translated by p.\n</p>\n\n",name:"Add"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Canon!\">Canon</a></h2>\n<code>func (r Rectangle) Canon() Rectangle</code>\n<p>\nCanon returns the canonical version of r. The returned rectangle has minimum\nand maximum coordinates swapped if necessary so that it is well-formed.\n</p>\n\n",name:"Canon"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Contains!\">Contains</a></h2>\n<code>func (r Rectangle) Contains(p Point) bool</code>\n<p>\nContains returns whether r contains p.\n</p>\n\n",name:"Contains"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Dx!\">Dx</a></h2>\n<code>func (r Rectangle) Dx() int</code>\n<p>\nDx returns r&#39;s width.\n</p>\n\n",name:"Dx"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Dy!\">Dy</a></h2>\n<code>func (r Rectangle) Dy() int</code>\n<p>\nDy returns r&#39;s height.\n</p>\n\n",name:"Dy"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Empty!\">Empty</a></h2>\n<code>func (r Rectangle) Empty() bool</code>\n<p>\nEmpty returns whether the rectangle contains no points.\n</p>\n\n",name:"Empty"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Eq!\">Eq</a></h2>\n<code>func (r Rectangle) Eq(s Rectangle) bool</code>\n<p>\nEq returns whether r and s are equal.\n</p>\n\n",name:"Eq"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Inset!\">Inset</a></h2>\n<code>func (r Rectangle) Inset(n int) Rectangle</code>\n<p>\nInset returns the rectangle r inset by n, which may be negative. If either\nof r&#39;s dimensions is less than 2*n then an empty rectangle near the center\nof r will be returned.\n</p>\n\n",name:"Inset"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Intersect!\">Intersect</a></h2>\n<code>func (r Rectangle) Intersect(s Rectangle) Rectangle</code>\n<p>\nIntersect returns the largest rectangle contained by both r and s. If the\ntwo rectangles do not overlap then the zero rectangle will be returned.\n</p>\n\n",name:"Intersect"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Overlaps!\">Overlaps</a></h2>\n<code>func (r Rectangle) Overlaps(s Rectangle) bool</code>\n<p>\nOverlaps returns whether r and s have a non-empty intersection.\n</p>\n\n",name:"Overlaps"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Size!\">Size</a></h2>\n<code>func (r Rectangle) Size() Point</code>\n<p>\nSize returns r&#39;s width and height.\n</p>\n\n",name:"Size"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.String!\">String</a></h2>\n<code>func (r Rectangle) String() string</code>\n<p>\nString returns a string representation of r like &#34;(3,4)-(6,5)&#34;.\n</p>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Sub!\">Sub</a></h2>\n<code>func (r Rectangle) Sub(p Point) Rectangle</code>\n<p>\nAdd returns the rectangle r translated by -p.\n</p>\n\n",name:"Sub"},{html:"\n<h2><a class=\"black\" href=\"?m:Rectangle\">func (Rectangle)</a> <a href=\"?m:Rectangle.Union!\">Union</a></h2>\n<code>func (r Rectangle) Union(s Rectangle) Rectangle</code>\n<p>\nUnion returns the smallest rectangle that contains both r and s.\n</p>\n\n",name:"Union"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Tiled!\">Tiled</a></h2>\n<pre>type Tiled struct {\n\tI      Image\n\tOffset Point\n}</pre>\n<p>\nA Tiled is an infinite-sized Image that repeats another Image in both\ndirections. Tiled{i, p}.At(x, y) will equal i.At(x+p.X, y+p.Y) for all\npoints {x+p.X, y+p.Y} within i&#39;s Bounds.\n</p>\n\n",name:"Tiled","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.At!\">At</a></h2>\n<code>func (t *Tiled) At(x, y int) Color</code>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.Bounds!\">Bounds</a></h2>\n<code>func (t *Tiled) Bounds() Rectangle</code>\n\n",name:"Bounds"},{html:"\n<h2><a class=\"black\" href=\"?m:Tiled\">func (*Tiled)</a> <a href=\"?m:Tiled.ColorModel!\">ColorModel</a></h2>\n<code>func (t *Tiled) ColorModel() ColorModel</code>\n\n",name:"ColorModel"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Decode!\">Decode</a></h2>\n<code>func Decode(r io.Reader) (Image, string, os.Error)</code>\n<p>\nDecode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by the init method of the codec-\nspecific package.\n</p>\n\n",name:"Decode"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DecodeConfig!\">DecodeConfig</a></h2>\n<code>func DecodeConfig(r io.Reader) (Config, string, os.Error)</code>\n<p>\nDecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nthe init method of the codec-specific package.\n</p>\n\n",name:"DecodeConfig"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewAlpha!\">NewAlpha</a></h2>\n<code>func NewAlpha(w, h int) *Alpha</code>\n<p>\nNewAlpha returns a new Alpha with the given width and height.\n</p>\n\n",name:"NewAlpha"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewAlpha16!\">NewAlpha16</a></h2>\n<code>func NewAlpha16(w, h int) *Alpha16</code>\n<p>\nNewAlpha16 returns a new Alpha16 with the given width and height.\n</p>\n\n",name:"NewAlpha16"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewColorImage!\">NewColorImage</a></h2>\n<code>func NewColorImage(c Color) *ColorImage</code>\n\n",name:"NewColorImage"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewGray!\">NewGray</a></h2>\n<code>func NewGray(w, h int) *Gray</code>\n<p>\nNewGray returns a new Gray with the given width and height.\n</p>\n\n",name:"NewGray"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewGray16!\">NewGray16</a></h2>\n<code>func NewGray16(w, h int) *Gray16</code>\n<p>\nNewGray16 returns a new Gray16 with the given width and height.\n</p>\n\n",name:"NewGray16"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewNRGBA!\">NewNRGBA</a></h2>\n<code>func NewNRGBA(w, h int) *NRGBA</code>\n<p>\nNewNRGBA returns a new NRGBA with the given width and height.\n</p>\n\n",name:"NewNRGBA"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewNRGBA64!\">NewNRGBA64</a></h2>\n<code>func NewNRGBA64(w, h int) *NRGBA64</code>\n<p>\nNewNRGBA64 returns a new NRGBA64 with the given width and height.\n</p>\n\n",name:"NewNRGBA64"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewPaletted!\">NewPaletted</a></h2>\n<code>func NewPaletted(w, h int, m PalettedColorModel) *Paletted</code>\n<p>\nNewPaletted returns a new Paletted with the given width, height and palette.\n</p>\n\n",name:"NewPaletted"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRGBA!\">NewRGBA</a></h2>\n<code>func NewRGBA(w, h int) *RGBA</code>\n<p>\nNewRGBA returns a new RGBA with the given width and height.\n</p>\n\n",name:"NewRGBA"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRGBA64!\">NewRGBA64</a></h2>\n<code>func NewRGBA64(w, h int) *RGBA64</code>\n<p>\nNewRGBA64 returns a new RGBA64 with the given width and height.\n</p>\n\n",name:"NewRGBA64"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewTiled!\">NewTiled</a></h2>\n<code>func NewTiled(i Image, offset Point) *Tiled</code>\n\n",name:"NewTiled"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pt!\">Pt</a></h2>\n<code>func Pt(X, Y int) Point</code>\n<p>\nPt is shorthand for Point{X, Y}.\n</p>\n\n",name:"Pt"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Rect!\">Rect</a></h2>\n<code>func Rect(x0, y0, x1, y1 int) Rectangle</code>\n<p>\nRect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}.\n</p>\n\n",name:"Rect"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RegisterFormat!\">RegisterFormat</a></h2>\n<code>func RegisterFormat(name, magic string, decode func(io.Reader) (Image, os.Error), decodeConfig func(io.Reader) (Config, os.Error))</code>\n<p>\nRegisterFormat registers an image format for use by Decode.\nName is the name of the format, like &#34;jpeg&#34; or &#34;png&#34;.\nMagic is the magic prefix that identifies the format&#39;s encoding. The magic\nstring can contain &#34;?&#34; wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n</p>\n\n",name:"RegisterFormat"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:RGBAColorModel!\">RGBAColorModel</a></h2>\n<pre>var RGBAColorModel ColorModel = ColorModelFunc(toRGBAColor)</pre>\n<p>\nThe ColorModel associated with RGBAColor.\n</p>\n\n",names:["RGBAColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:RGBA64ColorModel!\">RGBA64ColorModel</a></h2>\n<pre>var RGBA64ColorModel ColorModel = ColorModelFunc(toRGBA64Color)</pre>\n<p>\nThe ColorModel associated with RGBA64Color.\n</p>\n\n",names:["RGBA64ColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:NRGBAColorModel!\">NRGBAColorModel</a></h2>\n<pre>var NRGBAColorModel ColorModel = ColorModelFunc(toNRGBAColor)</pre>\n<p>\nThe ColorModel associated with NRGBAColor.\n</p>\n\n",names:["NRGBAColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:NRGBA64ColorModel!\">NRGBA64ColorModel</a></h2>\n<pre>var NRGBA64ColorModel ColorModel = ColorModelFunc(toNRGBA64Color)</pre>\n<p>\nThe ColorModel associated with NRGBA64Color.\n</p>\n\n",names:["NRGBA64ColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:AlphaColorModel!\">AlphaColorModel</a></h2>\n<pre>var AlphaColorModel ColorModel = ColorModelFunc(toAlphaColor)</pre>\n<p>\nThe ColorModel associated with AlphaColor.\n</p>\n\n",names:["AlphaColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Alpha16ColorModel!\">Alpha16ColorModel</a></h2>\n<pre>var Alpha16ColorModel ColorModel = ColorModelFunc(toAlpha16Color)</pre>\n<p>\nThe ColorModel associated with Alpha16Color.\n</p>\n\n",names:["Alpha16ColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:GrayColorModel!\">GrayColorModel</a></h2>\n<pre>var GrayColorModel ColorModel = ColorModelFunc(toGrayColor)</pre>\n<p>\nThe ColorModel associated with GrayColor.\n</p>\n\n",names:["GrayColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Gray16ColorModel!\">Gray16ColorModel</a></h2>\n<pre>var Gray16ColorModel ColorModel = ColorModelFunc(toGray16Color)</pre>\n<p>\nThe ColorModel associated with Gray16Color.\n</p>\n\n",names:["Gray16ColorModel"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:UnknownFormatErr!\">UnknownFormatErr</a></h2>\n<pre>var UnknownFormatErr = os.NewError(&#34;image: unknown format&#34;)</pre>\n<p>\nAn UnknownFormatErr indicates that decoding encountered an unknown format.\n</p>\n\n",names:["UnknownFormatErr"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Black!\"><em>group</em></a></h2>\n<pre>var (\n\t// Black is an opaque black ColorImage.\n\tBlack = NewColorImage(Gray16Color{0})\n\t// White is an opaque white ColorImage.\n\tWhite = NewColorImage(Gray16Color{0xffff})\n\t// Transparent is a fully transparent ColorImage.\n\tTransparent = NewColorImage(Alpha16Color{0})\n\t// Opaque is a fully opaque ColorImage.\n\tOpaque = NewColorImage(Alpha16Color{0xffff})\n)</pre>\n\n",names:["Black","White","Transparent","Opaque"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ZP!\">ZP</a></h2>\n<pre>var ZP Point</pre>\n<p>\nZP is the zero Point.\n</p>\n\n",names:["ZP"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ZR!\">ZR</a></h2>\n<pre>var ZR Rectangle</pre>\n<p>\nZR is the zero Rectangle.\n</p>\n\n",names:["ZR"],type:""}]}