var gortfmData = {index:"index.html",html:"<p>\nPackage regexp implements a simple regular expression library.\n</p>\n<p>\nThe syntax of the regular expressions accepted is:\n</p>\n<pre>regexp:\n\tconcatenation { &#39;|&#39; concatenation }\nconcatenation:\n\t{ closure }\nclosure:\n\tterm [ &#39;*&#39; | &#39;+&#39; | &#39;?&#39; ]\nterm:\n\t&#39;^&#39;\n\t&#39;$&#39;\n\t&#39;.&#39;\n\tcharacter\n\t&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;\n\t&#39;(&#39; regexp &#39;)&#39;\ncharacter-range:\n\tcharacter [ &#39;-&#39; character ]\n</pre>\n<p>\nAll characters are UTF-8-encoded code points.  Backslashes escape special\ncharacters, including inside character classes.  The standard Go character\nescapes are also recognized: \\a \\b \\f \\n \\r \\t \\v.\n</p>\n<p>\nThere are 16 methods of Regexp that match a regular expression and identify\nthe matched text.  Their names are matched by this regular expression:\n</p>\n<pre>Find(All)?(String)?(Submatch)?(Index)?\n</pre>\n<p>\nIf &#39;All&#39; is present, the routine matches successive non-overlapping\nmatches of the entire expression.  Empty matches abutting a preceding\nmatch are ignored.  The return value is a slice containing the successive\nreturn values of the corresponding non-&#39;All&#39; routine.  These routines take\nan extra integer argument, n; if n &gt;= 0, the function returns at most n\nmatches/submatches.\n</p>\n<p>\nIf &#39;String&#39; is present, the argument is a string; otherwise it is a slice\nof bytes; return values are adjusted as appropriate.\n</p>\n<p>\nIf &#39;Submatch&#39; is present, the return value is a slice identifying the\nsuccessive submatches of the expression.  Submatches are matches of\nparenthesized subexpressions within the regular expression, numbered from\nleft to right in order of opening parenthesis.  Submatch 0 is the match of\nthe entire expression, submatch 1 the match of the first parenthesized\nsubexpression, and so on.\n</p>\n<p>\nIf &#39;Index&#39; is present, matches and submatches are identified by byte index\npairs within the input string: result[2*n:2*n+1] identifies the indexes of\nthe nth submatch.  The pair for n==0 identifies the match of the entire\nexpression.  If &#39;Index&#39; is not present, the match is identified by the\ntext of the match/submatch.  If an index is negative, it means that\nsubexpression did not match any string in the input.\n</p>\n<p>\nThere is also a subset of the methods that can be applied to text read\nfrom a RuneReader:\n</p>\n<pre>MatchReader, FindReaderIndex, FindReaderSubmatchIndex\n</pre>\n<p>\nThis set may grow.  Note that regular expression matches may need to\nexamine text beyond the text returned by a match, so the methods that\nmatch text from a RuneReader may read arbitrarily far into the input\nbefore returning.\n</p>\n<p>\n(There are a few other methods that do not match this pattern.)\n</p>\n",name:"regexp",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\n<pre>type Error string</pre>\n<p>\nError is the local type for a parsing error.\n</p>\n\n",name:"Error","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Error\">func (Error)</a> <a href=\"?m:Error.String!\">String</a></h2>\n<code>func (e Error) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Regexp!\">Regexp</a></h2>\n<pre>type Regexp struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nRegexp is the representation of a compiled regular expression.\nThe public interface is entirely through methods.\n</p>\n\n",name:"Regexp","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.Find!\">Find</a></h2>\n<code>func (re *Regexp) Find(b []byte) []byte</code>\n<p>\nFind returns a slice holding the text of the leftmost match in b of the regular expression.\nA return value of nil indicates no match.\n</p>\n\n",name:"Find"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAll!\">FindAll</a></h2>\n<code>func (re *Regexp) FindAll(b []byte, n int) [][]byte</code>\n<p>\nFindAll is the &#39;All&#39; version of Find; it returns a slice of all successive\nmatches of the expression, as defined by the &#39;All&#39; description in the\npackage comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAll"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllIndex!\">FindAllIndex</a></h2>\n<code>func (re *Regexp) FindAllIndex(b []byte, n int) [][]int</code>\n<p>\nFindAllIndex is the &#39;All&#39; version of FindIndex; it returns a slice of all\nsuccessive matches of the expression, as defined by the &#39;All&#39; description\nin the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllString!\">FindAllString</a></h2>\n<code>func (re *Regexp) FindAllString(s string, n int) []string</code>\n<p>\nFindAllString is the &#39;All&#39; version of FindString; it returns a slice of all\nsuccessive matches of the expression, as defined by the &#39;All&#39; description\nin the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllString"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringIndex!\">FindAllStringIndex</a></h2>\n<code>func (re *Regexp) FindAllStringIndex(s string, n int) [][]int</code>\n<p>\nFindAllStringIndex is the &#39;All&#39; version of FindStringIndex; it returns a\nslice of all successive matches of the expression, as defined by the &#39;All&#39;\ndescription in the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllStringIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringSubmatch!\">FindAllStringSubmatch</a></h2>\n<code>func (re *Regexp) FindAllStringSubmatch(s string, n int) [][]string</code>\n<p>\nFindAllStringSubmatch is the &#39;All&#39; version of FindStringSubmatch; it\nreturns a slice of all successive matches of the expression, as defined by\nthe &#39;All&#39; description in the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllStringSubmatch"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllStringSubmatchIndex!\">FindAllStringSubmatchIndex</a></h2>\n<code>func (re *Regexp) FindAllStringSubmatchIndex(s string, n int) [][]int</code>\n<p>\nFindAllStringSubmatchIndex is the &#39;All&#39; version of\nFindStringSubmatchIndex; it returns a slice of all successive matches of\nthe expression, as defined by the &#39;All&#39; description in the package\ncomment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllStringSubmatchIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllSubmatch!\">FindAllSubmatch</a></h2>\n<code>func (re *Regexp) FindAllSubmatch(b []byte, n int) [][][]byte</code>\n<p>\nFindAllSubmatch is the &#39;All&#39; version of FindSubmatch; it returns a slice\nof all successive matches of the expression, as defined by the &#39;All&#39;\ndescription in the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllSubmatch"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindAllSubmatchIndex!\">FindAllSubmatchIndex</a></h2>\n<code>func (re *Regexp) FindAllSubmatchIndex(b []byte, n int) [][]int</code>\n<p>\nFindAllSubmatchIndex is the &#39;All&#39; version of FindSubmatchIndex; it returns\na slice of all successive matches of the expression, as defined by the\n&#39;All&#39; description in the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindAllSubmatchIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindIndex!\">FindIndex</a></h2>\n<code>func (re *Regexp) FindIndex(b []byte) (loc []int)</code>\n<p>\nFindIndex returns a two-element slice of integers defining the location of\nthe leftmost match in b of the regular expression.  The match itself is at\nb[loc[0]:loc[1]].\nA return value of nil indicates no match.\n</p>\n\n",name:"FindIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindReaderIndex!\">FindReaderIndex</a></h2>\n<code>func (re *Regexp) FindReaderIndex(r io.RuneReader) []int</code>\n<p>\nFindReaderIndex returns a two-element slice of integers defining the\nlocation of the leftmost match of the regular expression in text read from\nthe RuneReader.  The match itself is at s[loc[0]:loc[1]].  A return\nvalue of nil indicates no match.\n</p>\n\n",name:"FindReaderIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindReaderSubmatchIndex!\">FindReaderSubmatchIndex</a></h2>\n<code>func (re *Regexp) FindReaderSubmatchIndex(r io.RuneReader) []int</code>\n<p>\nFindReaderSubmatchIndex returns a slice holding the index pairs\nidentifying the leftmost match of the regular expression of text read by\nthe RuneReader, and the matches, if any, of its subexpressions, as defined\nby the &#39;Submatch&#39; and &#39;Index&#39; descriptions in the package comment.  A\nreturn value of nil indicates no match.\n</p>\n\n",name:"FindReaderSubmatchIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindString!\">FindString</a></h2>\n<code>func (re *Regexp) FindString(s string) string</code>\n<p>\nFindString returns a string holding the text of the leftmost match in s of the regular\nexpression.  If there is no match, the return value is an empty string,\nbut it will also be empty if the regular expression successfully matches\nan empty string.  Use FindStringIndex or FindStringSubmatch if it is\nnecessary to distinguish these cases.\n</p>\n\n",name:"FindString"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringIndex!\">FindStringIndex</a></h2>\n<code>func (re *Regexp) FindStringIndex(s string) []int</code>\n<p>\nFindStringIndex returns a two-element slice of integers defining the\nlocation of the leftmost match in s of the regular expression.  The match\nitself is at s[loc[0]:loc[1]].\nA return value of nil indicates no match.\n</p>\n\n",name:"FindStringIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringSubmatch!\">FindStringSubmatch</a></h2>\n<code>func (re *Regexp) FindStringSubmatch(s string) []string</code>\n<p>\nFindStringSubmatch returns a slice of strings holding the text of the\nleftmost match of the regular expression in s and the matches, if any, of\nits subexpressions, as defined by the &#39;Submatch&#39; description in the\npackage comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindStringSubmatch"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindStringSubmatchIndex!\">FindStringSubmatchIndex</a></h2>\n<code>func (re *Regexp) FindStringSubmatchIndex(s string) []int</code>\n<p>\nFindStringSubmatchIndex returns a slice holding the index pairs\nidentifying the leftmost match of the regular expression in s and the\nmatches, if any, of its subexpressions, as defined by the &#39;Submatch&#39; and\n&#39;Index&#39; descriptions in the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindStringSubmatchIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindSubmatch!\">FindSubmatch</a></h2>\n<code>func (re *Regexp) FindSubmatch(b []byte) [][]byte</code>\n<p>\nFindSubmatch returns a slice of slices holding the text of the leftmost\nmatch of the regular expression in b and the matches, if any, of its\nsubexpressions, as defined by the &#39;Submatch&#39; descriptions in the package\ncomment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindSubmatch"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.FindSubmatchIndex!\">FindSubmatchIndex</a></h2>\n<code>func (re *Regexp) FindSubmatchIndex(b []byte) []int</code>\n<p>\nFindSubmatchIndex returns a slice holding the index pairs identifying the\nleftmost match of the regular expression in b and the matches, if any, of\nits subexpressions, as defined by the &#39;Submatch&#39; and &#39;Index&#39; descriptions\nin the package comment.\nA return value of nil indicates no match.\n</p>\n\n",name:"FindSubmatchIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.LiteralPrefix!\">LiteralPrefix</a></h2>\n<code>func (re *Regexp) LiteralPrefix() (prefix string, complete bool)</code>\n<p>\nLiteralPrefix returns a literal string that must begin any match\nof the regular expression re.  It returns the boolean true if the\nliteral string comprises the entire regular expression.\n</p>\n\n",name:"LiteralPrefix"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.Match!\">Match</a></h2>\n<code>func (re *Regexp) Match(b []byte) bool</code>\n<p>\nMatch returns whether the Regexp matches the byte slice b.\nThe return value is a boolean: true for match, false for no match.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.MatchReader!\">MatchReader</a></h2>\n<code>func (re *Regexp) MatchReader(r io.RuneReader) bool</code>\n<p>\nMatchReader returns whether the Regexp matches the text read by the\nRuneReader.  The return value is a boolean: true for match, false for no\nmatch.\n</p>\n\n",name:"MatchReader"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.MatchString!\">MatchString</a></h2>\n<code>func (re *Regexp) MatchString(s string) bool</code>\n<p>\nMatchString returns whether the Regexp matches the string s.\nThe return value is a boolean: true for match, false for no match.\n</p>\n\n",name:"MatchString"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.NumSubexp!\">NumSubexp</a></h2>\n<code>func (re *Regexp) NumSubexp() int</code>\n<p>\nNumSubexp returns the number of parenthesized subexpressions in this Regexp.\n</p>\n\n",name:"NumSubexp"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAll!\">ReplaceAll</a></h2>\n<code>func (re *Regexp) ReplaceAll(src, repl []byte) []byte</code>\n<p>\nReplaceAll returns a copy of src in which all matches for the Regexp\nhave been replaced by repl.  No support is provided for expressions\n(e.g. \\1 or $1) in the replacement text.\n</p>\n\n",name:"ReplaceAll"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllFunc!\">ReplaceAllFunc</a></h2>\n<code>func (re *Regexp) ReplaceAllFunc(src []byte, repl func([]byte) []byte) []byte</code>\n<p>\nReplaceAllFunc returns a copy of src in which all matches for the\nRegexp have been replaced by the return value of of function repl (whose\nfirst argument is the matched []byte).  No support is provided for\nexpressions (e.g. \\1 or $1) in the replacement string.\n</p>\n\n",name:"ReplaceAllFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllString!\">ReplaceAllString</a></h2>\n<code>func (re *Regexp) ReplaceAllString(src, repl string) string</code>\n<p>\nReplaceAllString returns a copy of src in which all matches for the Regexp\nhave been replaced by repl.  No support is provided for expressions\n(e.g. \\1 or $1) in the replacement string.\n</p>\n\n",name:"ReplaceAllString"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.ReplaceAllStringFunc!\">ReplaceAllStringFunc</a></h2>\n<code>func (re *Regexp) ReplaceAllStringFunc(src string, repl func(string) string) string</code>\n<p>\nReplaceAllStringFunc returns a copy of src in which all matches for the\nRegexp have been replaced by the return value of of function repl (whose\nfirst argument is the matched string).  No support is provided for\nexpressions (e.g. \\1 or $1) in the replacement string.\n</p>\n\n",name:"ReplaceAllStringFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:Regexp\">func (*Regexp)</a> <a href=\"?m:Regexp.String!\">String</a></h2>\n<code>func (re *Regexp) String() string</code>\n<p>\nString returns the source text used to compile the regular expression.\n</p>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Compile!\">Compile</a></h2>\n<code>func Compile(str string) (regexp *Regexp, error os.Error)</code>\n<p>\nCompile parses a regular expression and returns, if successful, a Regexp\nobject that can be used to match against text.\n</p>\n\n",name:"Compile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Match!\">Match</a></h2>\n<code>func Match(pattern string, b []byte) (matched bool, error os.Error)</code>\n<p>\nMatch checks whether a textual regular expression\nmatches a byte slice.  More complicated queries need\nto use Compile and the full Regexp interface.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MatchReader!\">MatchReader</a></h2>\n<code>func MatchReader(pattern string, r io.RuneReader) (matched bool, error os.Error)</code>\n<p>\nMatchReader checks whether a textual regular expression matches the text\nread by the RuneReader.  More complicated queries need to use Compile and\nthe full Regexp interface.\n</p>\n\n",name:"MatchReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MatchString!\">MatchString</a></h2>\n<code>func MatchString(pattern string, s string) (matched bool, error os.Error)</code>\n<p>\nMatchString checks whether a textual regular expression\nmatches a string.  More complicated queries need\nto use Compile and the full Regexp interface.\n</p>\n\n",name:"MatchString"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MustCompile!\">MustCompile</a></h2>\n<code>func MustCompile(str string) *Regexp</code>\n<p>\nMustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n</p>\n\n",name:"MustCompile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:QuoteMeta!\">QuoteMeta</a></h2>\n<code>func QuoteMeta(s string) string</code>\n<p>\nQuoteMeta returns a string that quotes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.  For example, QuoteMeta(`[foo]`) returns `\\[foo\\]`.\n</p>\n\n",name:"QuoteMeta"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrInternal!\"><em>group</em></a></h2>\n<pre>var (\n\tErrInternal            = Error(&#34;internal error&#34;)\n\tErrUnmatchedLpar       = Error(&#34;unmatched &#39;(&#39;&#34;)\n\tErrUnmatchedRpar       = Error(&#34;unmatched &#39;)&#39;&#34;)\n\tErrUnmatchedLbkt       = Error(&#34;unmatched &#39;[&#39;&#34;)\n\tErrUnmatchedRbkt       = Error(&#34;unmatched &#39;]&#39;&#34;)\n\tErrBadRange            = Error(&#34;bad range in character class&#34;)\n\tErrExtraneousBackslash = Error(&#34;extraneous backslash&#34;)\n\tErrBadClosure          = Error(&#34;repeated closure (**, ++, etc.)&#34;)\n\tErrBareClosure         = Error(&#34;closure applies to nothing&#34;)\n\tErrBadBackslash        = Error(&#34;illegal backslash escape&#34;)\n)</pre>\n<p>\nError codes returned by failures to parse an expression.\n</p>\n\n",names:["ErrInternal","ErrUnmatchedLpar","ErrUnmatchedRpar","ErrUnmatchedLbkt","ErrUnmatchedRbkt","ErrBadRange","ErrExtraneousBackslash","ErrBadClosure","ErrBareClosure","ErrBadBackslash"],type:""}]}