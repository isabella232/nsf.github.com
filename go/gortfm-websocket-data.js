var gortfmData = {index:"index.html",html:"<p>\nPackage websocket implements a client and server for the Web Socket protocol.\nThe protocol is defined at <a href=\"http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol\">http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol</a>\n</p>\n",name:"websocket",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\n<pre>type Conn struct {\n\t// The origin URI for the Web Socket.\n\tOrigin string\n\t// The location URI for the Web Socket.\n\tLocation string\n\t// The subprotocol for the Web Socket.\n\tProtocol string\n\t// The initial http Request (for the Server side only).\n\tRequest *http.Request\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nConn is a channel to communicate to a Web Socket.\nIt implements the net.Conn interface.\n</p>\n\n",name:"Conn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Close!\">Close</a></h2>\n<code>func (ws *Conn) Close() os.Error</code>\n<p>\nClose implements the io.Closer interface for a Conn.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (ws *Conn) LocalAddr() net.Addr</code>\n<p>\nLocalAddr returns the WebSocket Origin for the connection.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Read!\">Read</a></h2>\n<code>func (ws *Conn) Read(msg []byte) (n int, err os.Error)</code>\n<p>\nRead implements the io.Reader interface for a Conn.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (ws *Conn) RemoteAddr() net.Addr</code>\n<p>\nRemoteAddr returns the WebSocket locations for the connection.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (ws *Conn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout sets the connection&#39;s network read timeout in nanoseconds.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (ws *Conn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout sets the connection&#39;s network timeout in nanoseconds.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (ws *Conn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWritetTimeout sets the connection&#39;s network write timeout in nanoseconds.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:Conn\">func (*Conn)</a> <a href=\"?m:Conn.Write!\">Write</a></h2>\n<code>func (ws *Conn) Write(msg []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the io.Writer interface for a Conn.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DialError!\">DialError</a></h2>\n<pre>type DialError struct {\n\tURL      string\n\tProtocol string\n\tOrigin   string\n\tError    os.Error\n}</pre>\n\n",name:"DialError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:DialError\">func (*DialError)</a> <a href=\"?m:DialError.String!\">String</a></h2>\n<code>func (e *DialError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Draft75Handler!\">Draft75Handler</a></h2>\n<pre>type Draft75Handler func(*Conn)</pre>\n<p>\nDraft75Handler is an interface to a WebSocket based on the\n(soon obsolete) draft-hixie-thewebsocketprotocol-75.\n</p>\n\n",name:"Draft75Handler","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Draft75Handler\">func (Draft75Handler)</a> <a href=\"?m:Draft75Handler.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (f Draft75Handler) ServeHTTP(w http.ResponseWriter, req *http.Request)</code>\n<p>\nServeHTTP implements the http.Handler interface for a Web Socket.\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Handler!\">Handler</a></h2>\n<pre>type Handler func(*Conn)</pre>\n<p>\nHandler is an interface to a WebSocket.\n</p>\n<p>\nA trivial example server:\n</p>\n<pre>package main\n\nimport (\n\t&#34;http&#34;\n\t&#34;io&#34;\n\t&#34;websocket&#34;\n)\n\n// Echo the data received on the Web Socket.\nfunc EchoServer(ws *websocket.Conn) {\n\tio.Copy(ws, ws);\n}\n\nfunc main() {\n\thttp.Handle(&#34;/echo&#34;, websocket.Handler(EchoServer));\n\terr := http.ListenAndServe(&#34;:12345&#34;, nil);\n\tif err != nil {\n\t\tpanic(&#34;ListenAndServe: &#34; + err.String())\n\t}\n}\n</pre>\n\n",name:"Handler","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Handler\">func (Handler)</a> <a href=\"?m:Handler.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (f Handler) ServeHTTP(w http.ResponseWriter, req *http.Request)</code>\n<p>\nServeHTTP implements the http.Handler interface for a Web Socket\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProtocolError!\">ProtocolError</a></h2>\n<pre>type ProtocolError struct {\n\tos.ErrorString\n}</pre>\n\n",name:"ProtocolError","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WebSocketAddr!\">WebSocketAddr</a></h2>\n<pre>type WebSocketAddr string</pre>\n<p>\nWebSocketAddr is an implementation of net.Addr for Web Sockets.\n</p>\n\n",name:"WebSocketAddr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WebSocketAddr\">func (WebSocketAddr)</a> <a href=\"?m:WebSocketAddr.Network!\">Network</a></h2>\n<code>func (addr WebSocketAddr) Network() string</code>\n<p>\nNetwork returns the network type for a Web Socket, &#34;websocket&#34;.\n</p>\n\n",name:"Network"},{html:"\n<h2><a class=\"black\" href=\"?m:WebSocketAddr\">func (WebSocketAddr)</a> <a href=\"?m:WebSocketAddr.String!\">String</a></h2>\n<code>func (addr WebSocketAddr) String() string</code>\n<p>\nString returns the network address for a Web Socket.\n</p>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\n<code>func Dial(url, protocol, origin string) (ws *Conn, err os.Error)</code>\n<p>\nDial opens a new client connection to a Web Socket.\n</p>\n<p>\nA trivial example client:\n</p>\n<pre>package main\n\nimport (\n\t&#34;websocket&#34;\n\t&#34;strings&#34;\n)\n\nfunc main() {\n \tws, err := websocket.Dial(&#34;ws://localhost/ws&#34;, &#34;&#34;, &#34;<a href=\"http://localhost/\">http://localhost/</a>&#34;);\n \tif err != nil {\n\t\tpanic(&#34;Dial: &#34; + err.String())\n\t}\n\tif _, err := ws.Write([]byte(&#34;hello, world!\\n&#34;)); err != nil {\n\t\tpanic(&#34;Write: &#34; + err.String())\n\t}\n\tvar msg = make([]byte, 512);\n\tif n, err := ws.Read(msg); err != nil {\n\t\tpanic(&#34;Read: &#34; + err.String())\n\t}\n\t// use msg[0:n]\n}\n</pre>\n\n",name:"Dial"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrBadScheme!\"><em>group</em></a></h2>\n<pre>var (\n\tErrBadScheme            = os.ErrorString(&#34;bad scheme&#34;)\n\tErrBadStatus            = &amp;ProtocolError{&#34;bad status&#34;}\n\tErrBadUpgrade           = &amp;ProtocolError{&#34;missing or bad upgrade&#34;}\n\tErrBadWebSocketOrigin   = &amp;ProtocolError{&#34;missing or bad WebSocket-Origin&#34;}\n\tErrBadWebSocketLocation = &amp;ProtocolError{&#34;missing or bad WebSocket-Location&#34;}\n\tErrBadWebSocketProtocol = &amp;ProtocolError{&#34;missing or bad WebSocket-Protocol&#34;}\n\tErrChallengeResponse    = &amp;ProtocolError{&#34;mismatch challange/response&#34;}\n)</pre>\n\n",names:["ErrBadScheme","ErrBadStatus","ErrBadUpgrade","ErrBadWebSocketOrigin","ErrBadWebSocketLocation","ErrBadWebSocketProtocol","ErrChallengeResponse"],type:""}]}