var gortfmData = {index:"index.html",html:"<p>\nPackage ebnf is a library for EBNF grammars. The input is text ([]byte)\nsatisfying the following grammar (represented itself in EBNF):\n</p>\n<pre>Production  = name &#34;=&#34; [ Expression ] &#34;.&#34; .\nExpression  = Alternative { &#34;|&#34; Alternative } .\nAlternative = Term { Term } .\nTerm        = name | token [ &#34;...&#34; token ] | Group | Option | Repetition .\nGroup       = &#34;(&#34; Expression &#34;)&#34; .\nOption      = &#34;[&#34; Expression &#34;]&#34; .\nRepetition  = &#34;{&#34; Expression &#34;}&#34; .\n</pre>\n<p>\nA name is a Go identifier, a token is a Go string, and comments\nand white space follow the same rules as for the Go language.\nProduction names starting with an uppercase Unicode letter denote\nnon-terminal productions (i.e., productions which allow white-space\nand comments between tokens); all other production names denote\nlexical productions.\n</p>\n",name:"ebnf",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Alternative!\">Alternative</a></h2>\n<pre>type Alternative []Expression // x | y | z\n</pre>\n<p>\nAn Alternative node represents a non-empty list of alternative expressions.\n</p>\n\n",name:"Alternative","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Alternative\">func (Alternative)</a> <a href=\"?m:Alternative.Pos!\">Pos</a></h2>\n<code>func (x Alternative) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Expression!\">Expression</a></h2>\n<pre>type Expression interface {\n\t// Pos is the position of the first character of the syntactic construct\n\tPos() token.Pos\n}</pre>\n<p>\nAn Expression node represents a production expression.\n</p>\n\n",name:"Expression","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Grammar!\">Grammar</a></h2>\n<pre>type Grammar map[string]*Production</pre>\n<p>\nA Grammar is a set of EBNF productions. The map\nis indexed by production name.\n</p>\n\n",name:"Grammar","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Group!\">Group</a></h2>\n<pre>type Group struct {\n\tLparen token.Pos\n\tBody   Expression // (body)\n}</pre>\n<p>\nA Group node represents a grouped expression.\n</p>\n\n",name:"Group","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Group\">func (*Group)</a> <a href=\"?m:Group.Pos!\">Pos</a></h2>\n<code>func (x *Group) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\n<pre>type Name struct {\n\tStringPos token.Pos\n\tString    string\n}</pre>\n<p>\nA Name node represents a production name.\n</p>\n\n",name:"Name","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Name\">func (*Name)</a> <a href=\"?m:Name.Pos!\">Pos</a></h2>\n<code>func (x *Name) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Option!\">Option</a></h2>\n<pre>type Option struct {\n\tLbrack token.Pos\n\tBody   Expression // [body]\n}</pre>\n<p>\nAn Option node represents an optional expression.\n</p>\n\n",name:"Option","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Option\">func (*Option)</a> <a href=\"?m:Option.Pos!\">Pos</a></h2>\n<code>func (x *Option) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Production!\">Production</a></h2>\n<pre>type Production struct {\n\tName *Name\n\tExpr Expression\n}</pre>\n<p>\nA Production node represents an EBNF production.\n</p>\n\n",name:"Production","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Production\">func (*Production)</a> <a href=\"?m:Production.Pos!\">Pos</a></h2>\n<code>func (x *Production) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Range!\">Range</a></h2>\n<pre>type Range struct {\n\tBegin, End *Token // begin ... end\n}</pre>\n<p>\nA List node represents a range of characters.\n</p>\n\n",name:"Range","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Range\">func (*Range)</a> <a href=\"?m:Range.Pos!\">Pos</a></h2>\n<code>func (x *Range) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Repetition!\">Repetition</a></h2>\n<pre>type Repetition struct {\n\tLbrace token.Pos\n\tBody   Expression // {body}\n}</pre>\n<p>\nA Repetition node represents a repeated expression.\n</p>\n\n",name:"Repetition","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Repetition\">func (*Repetition)</a> <a href=\"?m:Repetition.Pos!\">Pos</a></h2>\n<code>func (x *Repetition) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Sequence!\">Sequence</a></h2>\n<pre>type Sequence []Expression // x y z\n</pre>\n<p>\nA Sequence node represents a non-empty list of sequential expressions.\n</p>\n\n",name:"Sequence","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Sequence\">func (Sequence)</a> <a href=\"?m:Sequence.Pos!\">Pos</a></h2>\n<code>func (x Sequence) Pos() token.Pos</code>\n\n",name:"Pos"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Token!\">Token</a></h2>\n<pre>type Token struct {\n\tStringPos token.Pos\n\tString    string\n}</pre>\n<p>\nA Token node represents a literal.\n</p>\n\n",name:"Token","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (*Token)</a> <a href=\"?m:Token.Pos!\">Pos</a></h2>\n<code>func (x *Token) Pos() token.Pos</code>\n\n",name:"Pos"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\n<code>func Parse(fset *token.FileSet, filename string, src []byte) (Grammar, os.Error)</code>\n<p>\nParse parses a set of EBNF productions from source src.\nIt returns a set of productions. Errors are reported\nfor incorrect syntax and if a production is declared\nmore than once. Position information is recorded relative\nto the file set fset.\n</p>\n\n",name:"Parse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Verify!\">Verify</a></h2>\n<code>func Verify(fset *token.FileSet, grammar Grammar, start string) os.Error</code>\n<p>\nVerify checks that:\n</p>\n<pre>- all productions used are defined\n- all productions defined are used when beginning at start\n- lexical productions refer only to other lexical productions\n</pre>\n<p>\nPosition information is interpreted relative to the file set fset.\n</p>\n\n",name:"Verify"}],consts:[],vars:[]}