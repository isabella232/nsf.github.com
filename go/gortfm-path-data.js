var gortfmData = {index:"index.html",html:"<p>\nThe path package implements utility routines for manipulating\nslash-separated filename paths.\n</p>\n",name:"path",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Visitor!\">Visitor</a></h2>\n<pre>type Visitor interface {\n\tVisitDir(path string, f *os.FileInfo) bool\n\tVisitFile(path string, f *os.FileInfo)\n}</pre>\n<p>\nVisitor methods are invoked for corresponding file tree entries\nvisited by Walk. The parameter path is the full path of f relative\nto root.\n</p>\n\n",name:"Visitor","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Base!\">Base</a></h2>\n<code>func Base(name string) string</code>\n<p>\nBase returns the last path element of the slash-separated name.\nTrailing slashes are removed before extracting the last element.  If the name is\nempty, &#34;.&#34; is returned.  If it consists entirely of slashes, &#34;/&#34; is returned.\n</p>\n\n",name:"Base"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Clean!\">Clean</a></h2>\n<code>func Clean(path string) string</code>\n<p>\nClean returns the shortest path name equivalent to path\nby purely lexical processing.  It applies the following rules\niteratively until no further processing can be done:\n</p>\n<pre>1. Replace multiple slashes with a single slash.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\n   along with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\n   that is, replace &#34;/..&#34; by &#34;/&#34; at the beginning of a path.\n</pre>\n<p>\nIf the result of this process is an empty string, Clean\nreturns the string &#34;.&#34;.\n</p>\n<p>\nSee also Rob Pike, &ldquo;Lexical File Names in Plan 9 or\nGetting Dot-Dot right,&rdquo;\n<a href=\"http://plan9.bell-labs.com/sys/doc/lexnames.html\">http://plan9.bell-labs.com/sys/doc/lexnames.html</a>\n</p>\n\n",name:"Clean"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ext!\">Ext</a></h2>\n<code>func Ext(path string) string</code>\n<p>\nExt returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n</p>\n\n",name:"Ext"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Glob!\">Glob</a></h2>\n<code>func Glob(pattern string) (matches []string)</code>\n<p>\nGlob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed.\n</p>\n\n",name:"Glob"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IsAbs!\">IsAbs</a></h2>\n<code>func IsAbs(path string) bool</code>\n<p>\nIsAbs returns true if the path is absolute.\n</p>\n\n",name:"IsAbs"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Join!\">Join</a></h2>\n<code>func Join(elem ...string) string</code>\n<p>\nJoin joins any number of path elements into a single path, adding a\nseparating slash if necessary.  All empty strings are ignored.\n</p>\n\n",name:"Join"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Match!\">Match</a></h2>\n<code>func Match(pattern, name string) (matched bool, err os.Error)</code>\n<p>\nMatch returns true if name matches the shell file name pattern.\nThe syntax used by pattern is:\n</p>\n<pre>pattern:\n\t{ term }\nterm:\n\t&#39;*&#39;         matches any sequence of non-/ characters\n\t&#39;?&#39;         matches any single non-/ character\n\t&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;\n\t            character class (must be non-empty)\n\tc           matches character c (c != &#39;*&#39;, &#39;?&#39;, &#39;\\\\&#39;, &#39;[&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\ncharacter-range:\n\tc           matches character c (c != &#39;\\\\&#39;, &#39;-&#39;, &#39;]&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\tlo &#39;-&#39; hi   matches character c for lo &lt;= c &lt;= hi\n</pre>\n<p>\nMatch requires pattern to match all of name, not just a substring.\nThe only possible error return is when pattern is malformed.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Split!\">Split</a></h2>\n<code>func Split(path string) (dir, file string)</code>\n<p>\nSplit splits path immediately following the final path separator,\nseparating it into a directory and file name component.\nIf there is no separator in path, Split returns an empty dir and\nfile set to path.\n</p>\n\n",name:"Split"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Walk!\">Walk</a></h2>\n<code>func Walk(root string, v Visitor, errors chan&lt;- os.Error)</code>\n<p>\nWalk walks the file tree rooted at root, calling v.VisitDir or\nv.VisitFile for each directory or file in the tree, including root.\nIf v.VisitDir returns false, Walk skips the directory&#39;s entries;\notherwise it invokes itself for each directory entry in sorted order.\nAn error reading a directory does not abort the Walk.\nIf errors != nil, Walk sends each directory read error\nto the channel.  Otherwise Walk discards the error.\n</p>\n\n",name:"Walk"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DirSeps!\"><em>group</em></a></h2>\n<pre>const (\n\tDirSeps    = `/`                  // directory separators\n\tVolumeSeps = ``                   // volume separators\n\tPathSeps   = DirSeps + VolumeSeps // all path separators\n)</pre>\n\n",names:["DirSeps","VolumeSeps","PathSeps"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrBadPattern!\">ErrBadPattern</a></h2>\n<pre>var ErrBadPattern = os.NewError(&#34;syntax error in pattern&#34;)</pre>\n\n",names:["ErrBadPattern"],type:""}]}