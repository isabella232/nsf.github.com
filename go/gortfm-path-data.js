var gortfmData = {index:"index.html",html:"<p>\nPackage path implements utility routines for manipulating slash-separated\nfilename paths.\n</p>\n",name:"path",types:[],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Base!\">Base</a></h2>\n<code>func Base(path string) string</code>\n<p>\nBase returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns &#34;.&#34;.\nIf the path consists entirely of slashes, Base returns &#34;/&#34;.\n</p>\n\n",name:"Base"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Clean!\">Clean</a></h2>\n<code>func Clean(path string) string</code>\n<p>\nClean returns the shortest path name equivalent to path\nby purely lexical processing.  It applies the following rules\niteratively until no further processing can be done:\n</p>\n<pre>1. Replace multiple slashes with a single slash.\n2. Eliminate each . path name element (the current directory).\n3. Eliminate each inner .. path name element (the parent directory)\n   along with the non-.. element that precedes it.\n4. Eliminate .. elements that begin a rooted path:\n   that is, replace &#34;/..&#34; by &#34;/&#34; at the beginning of a path.\n</pre>\n<p>\nIf the result of this process is an empty string, Clean\nreturns the string &#34;.&#34;.\n</p>\n<p>\nSee also Rob Pike, &ldquo;Lexical File Names in Plan 9 or\nGetting Dot-Dot right,&rdquo;\n<a href=\"http://plan9.bell-labs.com/sys/doc/lexnames.html\">http://plan9.bell-labs.com/sys/doc/lexnames.html</a>\n</p>\n\n",name:"Clean"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Ext!\">Ext</a></h2>\n<code>func Ext(path string) string</code>\n<p>\nExt returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n</p>\n\n",name:"Ext"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IsAbs!\">IsAbs</a></h2>\n<code>func IsAbs(path string) bool</code>\n<p>\nIsAbs returns true if the path is absolute.\n</p>\n\n",name:"IsAbs"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Join!\">Join</a></h2>\n<code>func Join(elem ...string) string</code>\n<p>\nJoin joins any number of path elements into a single path, adding a\nseparating slash if necessary.  All empty strings are ignored.\n</p>\n\n",name:"Join"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Match!\">Match</a></h2>\n<code>func Match(pattern, name string) (matched bool, err os.Error)</code>\n<p>\nMatch returns true if name matches the shell file name pattern.\nThe pattern syntax is:\n</p>\n<pre>pattern:\n\t{ term }\nterm:\n\t&#39;*&#39;         matches any sequence of non-/ characters\n\t&#39;?&#39;         matches any single non-/ character\n\t&#39;[&#39; [ &#39;^&#39; ] { character-range } &#39;]&#39;\n\t            character class (must be non-empty)\n\tc           matches character c (c != &#39;*&#39;, &#39;?&#39;, &#39;\\\\&#39;, &#39;[&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\ncharacter-range:\n\tc           matches character c (c != &#39;\\\\&#39;, &#39;-&#39;, &#39;]&#39;)\n\t&#39;\\\\&#39; c      matches character c\n\tlo &#39;-&#39; hi   matches character c for lo &lt;= c &lt;= hi\n</pre>\n<p>\nMatch requires pattern to match all of name, not just a substring.\nThe only possible error return is when pattern is malformed.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Split!\">Split</a></h2>\n<code>func Split(path string) (dir, file string)</code>\n<p>\nSplit splits path immediately following the final path separator,\nseparating it into a directory and file name component.\nIf there is no separator in path, Split returns an empty dir and\nfile set to path.\n</p>\n\n",name:"Split"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrBadPattern!\">ErrBadPattern</a></h2>\n<pre>var ErrBadPattern = os.NewError(&#34;syntax error in pattern&#34;)</pre>\n\n",names:["ErrBadPattern"],type:""}]}