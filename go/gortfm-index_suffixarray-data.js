var gortfmData = {index:"index.html",html:"<p>\nThe suffixarray package implements substring search in logarithmic time\nusing an in-memory suffix array.\n</p>\n<p>\nExample use:\n</p>\n<pre>// create index for some data\nindex := suffixarray.New(data)\n\n// lookup byte slice s\noffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\noffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n</pre>\n",name:"suffixarray",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Index!\">Index</a></h2>\n<pre>type Index struct {\n\t// contains unexported fields\n}</pre>\n<p>\nIndex implements a suffix array for fast substring search.\n</p>\n\n",name:"Index","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Index\">func (*Index)</a> <a href=\"?m:Index.Lookup!\">Lookup</a></h2>\n<code>func (x *Index) Lookup(s []byte, n int) []int</code>\n<p>\nLookup returns an unsorted list of at most n indices where the byte string s\noccurs in the indexed data. If n &lt; 0, all occurrences are returned.\nThe result is nil if s is empty, s is not found, or n == 0.\nLookup time is O((log(N) + len(result))*len(s)) where N is the\nsize of the indexed data.\n</p>\n\n",name:"Lookup"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:New!\">New</a></h2>\n<code>func New(data []byte) *Index</code>\n<p>\nNew creates a new Index for data.\nIndex creation time is approximately O(N*log(N)) for N = len(data).\n</p>\n\n",name:"New"}],consts:[],vars:[]}