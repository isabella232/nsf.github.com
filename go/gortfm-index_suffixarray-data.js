var gortfmData = {index:"index.html",html:"<p>\nThe suffixarray package implements substring search in logarithmic time\nusing an in-memory suffix array.\n</p>\n<p>\nExample use:\n</p>\n<pre>// create index for some data\nindex := suffixarray.New(data)\n\n// lookup byte slice s\noffsets1 := index.Lookup(s, -1) // the list of all indices where s occurs in data\noffsets2 := index.Lookup(s, 3)  // the list of at most 3 indices where s occurs in data\n</pre>\n",name:"suffixarray",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Index!\">Index</a></h2>\n<pre>type Index struct {\n\t// contains unexported fields\n}</pre>\n<p>\nIndex implements a suffix array for fast substring search.\n</p>\n\n",name:"Index","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Index\">func (*Index)</a> <a href=\"?m:Index.Bytes!\">Bytes</a></h2>\n<code>func (x *Index) Bytes() []byte</code>\n<p>\nBytes returns the data over which the index was created.\nIt must not be modified.\n</p>\n\n",name:"Bytes"},{html:"\n<h2><a class=\"black\" href=\"?m:Index\">func (*Index)</a> <a href=\"?m:Index.FindAllIndex!\">FindAllIndex</a></h2>\n<code>func (x *Index) FindAllIndex(r *regexp.Regexp, n int) (result [][]int)</code>\n<p>\nFindAllIndex returns a sorted list of non-overlapping matches of the\nregular expression r, where a match is a pair of indices specifying\nthe matched slice of x.Bytes(). If n &lt; 0, all matches are returned\nin successive order. Otherwise, at most n matches are returned and\nthey may not be successive. The result is nil if there are no matches,\nor if n == 0.\n</p>\n\n",name:"FindAllIndex"},{html:"\n<h2><a class=\"black\" href=\"?m:Index\">func (*Index)</a> <a href=\"?m:Index.Lookup!\">Lookup</a></h2>\n<code>func (x *Index) Lookup(s []byte, n int) (result []int)</code>\n<p>\nLookup returns an unsorted list of at most n indices where the byte string s\noccurs in the indexed data. If n &lt; 0, all occurrences are returned.\nThe result is nil if s is empty, s is not found, or n == 0.\nLookup time is O((log(N) + len(result))*len(s)) where N is the\nsize of the indexed data.\n</p>\n\n",name:"Lookup"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:New!\">New</a></h2>\n<code>func New(data []byte) *Index</code>\n<p>\nNew creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n</p>\n\n",name:"New"}],consts:[],vars:[]}