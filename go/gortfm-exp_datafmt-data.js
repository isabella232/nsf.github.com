var gortfmData = {index:"index.html",html:"<p>\nPackage datafmt implements syntax-directed, type-driven formatting\nof arbitrary data structures. Formatting a data structure consists of\ntwo phases: first, a parser reads a format specification and builds a\n&#34;compiled&#34; format. Then, the format can be applied repeatedly to\narbitrary values. Applying a format to a value evaluates to a []byte\ncontaining the formatted value bytes, or nil.\n</p>\n<p>\nA format specification is a set of package declarations and format rules:\n</p>\n<pre>Format      = [ Entry { &#34;;&#34; Entry } [ &#34;;&#34; ] ] .\nEntry       = PackageDecl | FormatRule .\n</pre>\n<p>\n(The syntax of a format specification is presented in the same EBNF\nnotation as used in the Go language specification. The syntax of white\nspace, comments, identifiers, and string literals is the same as in Go.)\n</p>\n<p>\nA package declaration binds a package name (such as &#39;ast&#39;) to a\npackage import path (such as &#39;&#34;go/ast&#34;&#39;). Each package used (in\na type name, see below) must be declared once before use.\n</p>\n<pre>PackageDecl = PackageName ImportPath .\nPackageName = identifier .\nImportPath  = string .\n</pre>\n<p>\nA format rule binds a rule name to a format expression. A rule name\nmay be a type name or one of the special names &#39;default&#39; or &#39;/&#39;.\nA type name may be the name of a predeclared type (for example, &#39;int&#39;,\n&#39;float32&#39;, etc.), the package-qualified name of a user-defined type\n(for example, &#39;ast.MapType&#39;), or an identifier indicating the structure\nof unnamed composite types (&#39;array&#39;, &#39;chan&#39;, &#39;func&#39;, &#39;interface&#39;, &#39;map&#39;,\nor &#39;ptr&#39;). Each rule must have a unique name; rules can be declared in\nany order.\n</p>\n<pre>FormatRule  = RuleName &#34;=&#34; Expression .\nRuleName    = TypeName | &#34;default&#34; | &#34;/&#34; .\nTypeName    = [ PackageName &#34;.&#34; ] identifier .\n</pre>\n<p>\nTo format a value, the value&#39;s type name is used to select the format rule\n(there is an override mechanism, see below). The format expression of the\nselected rule specifies how the value is formatted. Each format expression,\nwhen applied to a value, evaluates to a byte sequence or nil.\n</p>\n<p>\nIn its most general form, a format expression is a list of alternatives,\neach of which is a sequence of operands:\n</p>\n<pre>Expression  = [ Sequence ] { &#34;|&#34; [ Sequence ] } .\nSequence    = Operand { Operand } .\n</pre>\n<p>\nThe formatted result produced by an expression is the result of the first\nalternative sequence that evaluates to a non-nil result; if there is no\nsuch alternative, the expression evaluates to nil. The result produced by\nan operand sequence is the concatenation of the results of its operands.\nIf any operand in the sequence evaluates to nil, the entire sequence\nevaluates to nil.\n</p>\n<p>\nThere are five kinds of operands:\n</p>\n<pre>Operand     = Literal | Field | Group | Option | Repetition .\n</pre>\n<p>\nLiterals evaluate to themselves, with two substitutions. First,\n%-formats expand in the manner of fmt.Printf, with the current value\npassed as the parameter. Second, the current indentation (see below)\nis inserted after every newline or form feed character.\n</p>\n<pre>Literal     = string .\n</pre>\n<p>\nThis table shows string literals applied to the value 42 and the\ncorresponding formatted result:\n</p>\n<pre>&#34;foo&#34;       foo\n&#34;%x&#34;        2a\n&#34;x = %d&#34;    x = 42\n&#34;%#x = %d&#34;  0x2a = 42\n</pre>\n<p>\nA field operand is a field name optionally followed by an alternate\nrule name. The field name may be an identifier or one of the special\nnames @ or *.\n</p>\n<pre>Field       = FieldName [ &#34;:&#34; RuleName ] .\nFieldName   = identifier | &#34;@&#34; | &#34;*&#34; .\n</pre>\n<p>\nIf the field name is an identifier, the current value must be a struct,\nand there must be a field with that name in the struct. The same lookup\nrules apply as in the Go language (for instance, the name of an anonymous\nfield is the unqualified type name). The field name denotes the field\nvalue in the struct. If the field is not found, formatting is aborted\nand an error message is returned. (TODO consider changing the semantics\nsuch that if a field is not found, it evaluates to nil).\n</p>\n<p>\nThe special name &#39;@&#39; denotes the current value.\n</p>\n<p>\nThe meaning of the special name &#39;*&#39; depends on the type of the current\nvalue:\n</p>\n<pre>array, slice types   array, slice element (inside {} only, see below)\ninterfaces           value stored in interface\npointers             value pointed to by pointer\n</pre>\n<p>\n(Implementation restriction: channel, function and map types are not\nsupported due to missing reflection support).\n</p>\n<p>\nFields are evaluated as follows: If the field value is nil, or an array\nor slice element does not exist, the result is nil (see below for details\non array/slice elements). If the value is not nil the field value is\nformatted (recursively) using the rule corresponding to its type name,\nor the alternate rule name, if given.\n</p>\n<p>\nThe following example shows a complete format specification for a\nstruct &#39;myPackage.Point&#39;. Assume the package\n</p>\n<pre>package myPackage  // in directory myDir/myPackage\ntype Point struct {\n\tname string;\n\tx, y int;\n}\n</pre>\n<p>\nApplying the format specification\n</p>\n<pre>myPackage &#34;myDir/myPackage&#34;;\nint = &#34;%d&#34;;\nhexInt = &#34;0x%x&#34;;\nstring = &#34;---%s---&#34;;\nmyPackage.Point = name &#34;{&#34; x &#34;, &#34; y:hexInt &#34;}&#34;;\n</pre>\n<p>\nto the value myPackage.Point{&#34;foo&#34;, 3, 15} results in\n</p>\n<pre>---foo---{3, 0xf}\n</pre>\n<p>\nFinally, an operand may be a grouped, optional, or repeated expression.\nA grouped expression (&#34;group&#34;) groups a more complex expression (body)\nso that it can be used in place of a single operand:\n</p>\n<pre>Group       = &#34;(&#34; [ Indentation &#34;&gt;&gt;&#34; ] Body &#34;)&#34; .\nIndentation = Expression .\nBody        = Expression .\n</pre>\n<p>\nA group body may be prefixed by an indentation expression followed by &#39;&gt;&gt;&#39;.\nThe indentation expression is applied to the current value like any other\nexpression and the result, if not nil, is appended to the current indentation\nduring the evaluation of the body (see also formatting state, below).\n</p>\n<p>\nAn optional expression (&#34;option&#34;) is enclosed in &#39;[]&#39; brackets.\n</p>\n<pre>Option      = &#34;[&#34; Body &#34;]&#34; .\n</pre>\n<p>\nAn option evaluates to its body, except that if the body evaluates to nil,\nthe option expression evaluates to an empty []byte. Thus an option&#39;s purpose\nis to protect the expression containing the option from a nil operand.\n</p>\n<p>\nA repeated expression (&#34;repetition&#34;) is enclosed in &#39;{}&#39; braces.\n</p>\n<pre>Repetition  = &#34;{&#34; Body [ &#34;/&#34; Separator ] &#34;}&#34; .\nSeparator   = Expression .\n</pre>\n<p>\nA repeated expression is evaluated as follows: The body is evaluated\nrepeatedly and its results are concatenated until the body evaluates\nto nil. The result of the repetition is the (possibly empty) concatenation,\nbut it is never nil. An implicit index is supplied for the evaluation of\nthe body: that index is used to address elements of arrays or slices. If\nthe corresponding elements do not exist, the field denoting the element\nevaluates to nil (which in turn may terminate the repetition).\n</p>\n<p>\nThe body of a repetition may be followed by a &#39;/&#39; and a &#34;separator&#34;\nexpression. If the separator is present, it is invoked between repetitions\nof the body.\n</p>\n<p>\nThe following example shows a complete format specification for formatting\na slice of unnamed type. Applying the specification\n</p>\n<pre>int = &#34;%b&#34;;\narray = { * / &#34;, &#34; };  // array is the type name for an unnamed slice\n</pre>\n<p>\nto the value &#39;[]int{2, 3, 5, 7}&#39; results in\n</p>\n<pre>10, 11, 101, 111\n</pre>\n<p>\nDefault rule: If a format rule named &#39;default&#39; is present, it is used for\nformatting a value if no other rule was found. A common default rule is\n</p>\n<pre>default = &#34;%v&#34;\n</pre>\n<p>\nto provide default formatting for basic types without having to specify\na specific rule for each basic type.\n</p>\n<p>\nGlobal separator rule: If a format rule named &#39;/&#39; is present, it is\ninvoked with the current value between literals. If the separator\nexpression evaluates to nil, it is ignored.\n</p>\n<p>\nFor instance, a global separator rule may be used to punctuate a sequence\nof values with commas. The rules:\n</p>\n<pre>default = &#34;%v&#34;;\n/ = &#34;, &#34;;\n</pre>\n<p>\nwill format an argument list by printing each one in its default format,\nseparated by a comma and a space.\n</p>\n",name:"datafmt",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Environment!\">Environment</a></h2>\n<pre>type Environment interface {\n\tCopy() Environment\n}</pre>\n<p>\nAn application-specific environment may be provided to Format.Apply;\nthe environment is available inside custom formatters via State.Env().\nEnvironments must implement copying; the Copy method must return an\ncomplete copy of the receiver. This is necessary so that the formatter\ncan save and restore an environment (in case of an absent expression).\n</p>\n<p>\nIf the Environment doesn&#39;t change during formatting (this is under\ncontrol of the custom formatters), the Copy function can simply return\nthe receiver, and thus can be very light-weight.\n</p>\n\n",name:"Environment","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Format!\">Format</a></h2>\n<pre>type Format map[string]expr</pre>\n<p>\nA Format is the result of parsing a format specification.\nThe format may be applied repeatedly to format values.\n</p>\n\n",name:"Format","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Format\">func (Format)</a> <a href=\"?m:Format.Eval!\">Eval</a></h2>\n<code>func (f Format) Eval(env Environment, args ...interface{}) ([]byte, os.Error)</code>\n<p>\nEval formats each argument according to the format\nf and returns the resulting []byte and os.Error. If\nan error occurred, the []byte contains the partially\nformatted result. An environment env may be passed\nin which is available in custom formatters through\nthe state parameter.\n</p>\n\n",name:"Eval"},{html:"\n<h2><a class=\"black\" href=\"?m:Format\">func (Format)</a> <a href=\"?m:Format.Fprint!\">Fprint</a></h2>\n<code>func (f Format) Fprint(w io.Writer, env Environment, args ...interface{}) (int, os.Error)</code>\n<p>\nFprint formats each argument according to the format f\nand writes to w. The result is the total number of bytes\nwritten and an os.Error, if any.\n</p>\n\n",name:"Fprint"},{html:"\n<h2><a class=\"black\" href=\"?m:Format\">func (Format)</a> <a href=\"?m:Format.Print!\">Print</a></h2>\n<code>func (f Format) Print(args ...interface{}) (int, os.Error)</code>\n<p>\nPrint formats each argument according to the format f\nand writes to standard output. The result is the total\nnumber of bytes written and an os.Error, if any.\n</p>\n\n",name:"Print"},{html:"\n<h2><a class=\"black\" href=\"?m:Format\">func (Format)</a> <a href=\"?m:Format.Sprint!\">Sprint</a></h2>\n<code>func (f Format) Sprint(args ...interface{}) string</code>\n<p>\nSprint formats each argument according to the format f\nand returns the resulting string. If an error occurs\nduring formatting, the result string contains the\npartially formatted result followed by an error message.\n</p>\n\n",name:"Sprint"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Formatter!\">Formatter</a></h2>\n<pre>type Formatter func(state *State, value interface{}, ruleName string) bool</pre>\n<p>\nCustom formatters implement the Formatter function type.\nA formatter is invoked with the current formatting state, the\nvalue to format, and the rule name under which the formatter\nwas installed (the same formatter function may be installed\nunder different names). The formatter may access the current state\nto guide formatting and use State.Write to append to the state&#39;s\noutput.\n</p>\n<p>\nA formatter must return a boolean value indicating if it evaluated\nto a non-nil value (true), or a nil value (false).\n</p>\n\n",name:"Formatter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatterMap!\">FormatterMap</a></h2>\n<pre>type FormatterMap map[string]Formatter</pre>\n<p>\nA FormatterMap is a set of custom formatters.\nIt maps a rule name to a formatter function.\n</p>\n\n",name:"FormatterMap","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:State!\">State</a></h2>\n<pre>type State struct {\n\t// contains unexported fields\n}</pre>\n<p>\nState represents the current formatting state.\nIt is provided as argument to custom formatters.\n</p>\n\n",name:"State","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:State\">func (*State)</a> <a href=\"?m:State.Env!\">Env</a></h2>\n<code>func (s *State) Env() interface{}</code>\n<p>\nEnv returns the environment passed to Format.Apply.\n</p>\n\n",name:"Env"},{html:"\n<h2><a class=\"black\" href=\"?m:State\">func (*State)</a> <a href=\"?m:State.LinePos!\">LinePos</a></h2>\n<code>func (s *State) LinePos() token.Position</code>\n<p>\nLinePos returns the position of the current line beginning\nin the state&#39;s output buffer. Line numbers start at 1.\n</p>\n\n",name:"LinePos"},{html:"\n<h2><a class=\"black\" href=\"?m:State\">func (*State)</a> <a href=\"?m:State.Pos!\">Pos</a></h2>\n<code>func (s *State) Pos() token.Position</code>\n<p>\nPos returns the position of the next byte to be written to the\noutput buffer. Line numbers start at 1.\n</p>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:State\">func (*State)</a> <a href=\"?m:State.Write!\">Write</a></h2>\n<code>func (s *State) Write(data []byte) (int, os.Error)</code>\n<p>\nWrite writes data to the output buffer, inserting the indentation\nstring after each newline or form feed character. It cannot return an error.\n</p>\n\n",name:"Write"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\n<code>func Parse(fset *token.FileSet, filename string, src []byte, fmap FormatterMap) (Format, os.Error)</code>\n<p>\nParse parses a set of format productions from source src. Custom\nformatters may be provided via a map of formatter functions. If\nthere are no errors, the result is a Format and the error is nil.\nOtherwise the format is nil and a non-empty ErrorList is returned.\n</p>\n\n",name:"Parse"}],consts:[],vars:[]}