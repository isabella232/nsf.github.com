var gortfmData = {index:"index.html",html:"<p>\nThe sync package provides basic synchronization primitives\nsuch as mutual exclusion locks.  Other than the Once and\nWaitGroup types, most are intended for use by low-level\nlibrary routines.  Higher-level synchronization is better\ndone via channels and communication.\n</p>\n",name:"sync",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cond!\">Cond</a></h2>\n<pre>type Cond struct {\n\tL Locker // held while observing or changing the condition\n\t// contains unexported fields\n}</pre>\n<p>\nCond implements a condition variable, a rendezvous point\nfor goroutines waiting for or announcing the occurrence\nof an event.\n</p>\n<p>\nEach Cond has an associated Locker L (often a *Mutex or *RWMutex),\nwhich must be held when changing the condition and\nwhen calling the Wait method.\n</p>\n\n",name:"Cond","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Cond\">func (*Cond)</a> <a href=\"?m:Cond.Broadcast!\">Broadcast</a></h2>\n<code>func (c *Cond) Broadcast()</code>\n<p>\nBroadcast wakes all goroutines waiting on c.\n</p>\n<p>\nIt is allowed but not required for the caller to hold c.L\nduring the call.\n</p>\n\n",name:"Broadcast"},{html:"\n<h2><a class=\"black\" href=\"?m:Cond\">func (*Cond)</a> <a href=\"?m:Cond.Signal!\">Signal</a></h2>\n<code>func (c *Cond) Signal()</code>\n<p>\nSignal wakes one goroutine waiting on c, if there is any.\n</p>\n<p>\nIt is allowed but not required for the caller to hold c.L\nduring the call.\n</p>\n\n",name:"Signal"},{html:"\n<h2><a class=\"black\" href=\"?m:Cond\">func (*Cond)</a> <a href=\"?m:Cond.Wait!\">Wait</a></h2>\n<code>func (c *Cond) Wait()</code>\n<p>\nWait atomically unlocks c.L and suspends execution\nof the calling goroutine.  After later resuming execution,\nWait locks c.L before returning.\n</p>\n<p>\nBecause L is not locked when Wait first resumes, the caller\ntypically cannot assume that the condition is true when\nWait returns.  Instead, the caller should Wait in a loop:\n</p>\n<pre>c.L.Lock()\nfor !condition() {\n    c.Wait()\n}\n... make use of condition ...\nc.L.Unlock()\n</pre>\n\n",name:"Wait"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Locker!\">Locker</a></h2>\n<pre>type Locker interface {\n\tLock()\n\tUnlock()\n}</pre>\n<p>\nA Locker represents an object that can be locked and unlocked.\n</p>\n\n",name:"Locker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Mutex!\">Mutex</a></h2>\n<pre>type Mutex struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Mutex is a mutual exclusion lock.\nMutexes can be created as part of other structures;\nthe zero value for a Mutex is an unlocked mutex.\n</p>\n\n",name:"Mutex","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Mutex\">func (*Mutex)</a> <a href=\"?m:Mutex.Lock!\">Lock</a></h2>\n<code>func (m *Mutex) Lock()</code>\n<p>\nLock locks m.\nIf the lock is already in use, the calling goroutine\nblocks until the mutex is available.\n</p>\n\n",name:"Lock"},{html:"\n<h2><a class=\"black\" href=\"?m:Mutex\">func (*Mutex)</a> <a href=\"?m:Mutex.Unlock!\">Unlock</a></h2>\n<code>func (m *Mutex) Unlock()</code>\n<p>\nUnlock unlocks m.\nIt is a run-time error if m is not locked on entry to Unlock.\n</p>\n<p>\nA locked Mutex is not associated with a particular goroutine.\nIt is allowed for one goroutine to lock a Mutex and then\narrange for another goroutine to unlock it.\n</p>\n\n",name:"Unlock"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Once!\">Once</a></h2>\n<pre>type Once struct {\n\t// contains unexported fields\n}</pre>\n<p>\nOnce is an object that will perform exactly one action.\n</p>\n\n",name:"Once","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Once\">func (*Once)</a> <a href=\"?m:Once.Do!\">Do</a></h2>\n<code>func (o *Once) Do(f func())</code>\n<p>\nDo calls the function f if and only if the method is being called for the\nfirst time with this receiver.  In other words, given\n</p>\n<pre>var once Once\n</pre>\n<p>\nif once.Do(f) is called multiple times, only the first call will invoke f,\neven if f has a different value in each invocation.  A new instance of\nOnce is required for each function to execute.\n</p>\n<p>\nDo is intended for initialization that must be run exactly once.  Since f\nis niladic, it may be necessary to use a function literal to capture the\narguments to a function to be invoked by Do:\n</p>\n<pre>config.once.Do(func() { config.init(filename) })\n</pre>\n<p>\nBecause no call to Do returns until the one call to f returns, if f causes\nDo to be called, it will deadlock.\n</p>\n\n",name:"Do"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RWMutex!\">RWMutex</a></h2>\n<pre>type RWMutex struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn RWMutex is a reader/writer mutual exclusion lock.\nThe lock can be held by an arbitrary number of readers\nor a single writer.\nRWMutexes can be created as part of other\nstructures; the zero value for a RWMutex is\nan unlocked mutex.\n</p>\n<p>\nWriters take priority over Readers: no new RLocks\nare granted while a blocked Lock call is waiting.\n</p>\n\n",name:"RWMutex","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RWMutex\">func (*RWMutex)</a> <a href=\"?m:RWMutex.Lock!\">Lock</a></h2>\n<code>func (rw *RWMutex) Lock()</code>\n<p>\nLock locks rw for writing.\nIf the lock is already locked for reading or writing,\nLock blocks until the lock is available.\nTo ensure that the lock eventually becomes available,\na blocked Lock call excludes new readers from acquiring\nthe lock.\n</p>\n\n",name:"Lock"},{html:"\n<h2><a class=\"black\" href=\"?m:RWMutex\">func (*RWMutex)</a> <a href=\"?m:RWMutex.RLock!\">RLock</a></h2>\n<code>func (rw *RWMutex) RLock()</code>\n<p>\nRLock locks rw for reading.\nIf the lock is already locked for writing or there is a writer already waiting\nto release the lock, RLock blocks until the writer has released the lock.\n</p>\n\n",name:"RLock"},{html:"\n<h2><a class=\"black\" href=\"?m:RWMutex\">func (*RWMutex)</a> <a href=\"?m:RWMutex.RLocker!\">RLocker</a></h2>\n<code>func (rw *RWMutex) RLocker() Locker</code>\n<p>\nRLocker returns a Locker interface that implements\nthe Lock and Unlock methods by calling rw.RLock and rw.RUnlock.\n</p>\n\n",name:"RLocker"},{html:"\n<h2><a class=\"black\" href=\"?m:RWMutex\">func (*RWMutex)</a> <a href=\"?m:RWMutex.RUnlock!\">RUnlock</a></h2>\n<code>func (rw *RWMutex) RUnlock()</code>\n<p>\nRUnlock undoes a single RLock call;\nit does not affect other simultaneous readers.\nIt is a run-time error if rw is not locked for reading\non entry to RUnlock.\n</p>\n\n",name:"RUnlock"},{html:"\n<h2><a class=\"black\" href=\"?m:RWMutex\">func (*RWMutex)</a> <a href=\"?m:RWMutex.Unlock!\">Unlock</a></h2>\n<code>func (rw *RWMutex) Unlock()</code>\n<p>\nUnlock unlocks rw for writing.  It is a run-time error if rw is\nnot locked for writing on entry to Unlock.\n</p>\n<p>\nAs with Mutexes, a locked RWMutex is not associated with a particular\ngoroutine.  One goroutine may RLock (Lock) an RWMutex and then\narrange for another goroutine to RUnlock (Unlock) it.\n</p>\n\n",name:"Unlock"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WaitGroup!\">WaitGroup</a></h2>\n<pre>type WaitGroup struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA WaitGroup waits for a collection of goroutines to finish.\nThe main goroutine calls Add to set the number of\ngoroutines to wait for.  Then each of the goroutines\nruns and calls Done when finished.  At the same time,\nWait can be used to block until all goroutines have finished.\n</p>\n<p>\nFor example:\n</p>\n<pre>for i := 0; i &lt; n; i++ {\n    if !condition(i) {\n        continue\n    }\n    wg.Add(1)\n    go func() {\n        // Do something.\n        wg.Done()\n    }()\n}\nwg.Wait()\n</pre>\n\n",name:"WaitGroup","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WaitGroup\">func (*WaitGroup)</a> <a href=\"?m:WaitGroup.Add!\">Add</a></h2>\n<code>func (wg *WaitGroup) Add(delta int)</code>\n<p>\nAdd adds delta, which may be negative, to the WaitGroup counter.\nIf the counter becomes zero, all goroutines blocked on Wait() are released.\n</p>\n\n",name:"Add"},{html:"\n<h2><a class=\"black\" href=\"?m:WaitGroup\">func (*WaitGroup)</a> <a href=\"?m:WaitGroup.Done!\">Done</a></h2>\n<code>func (wg *WaitGroup) Done()</code>\n<p>\nDone decrements the WaitGroup counter.\n</p>\n\n",name:"Done"},{html:"\n<h2><a class=\"black\" href=\"?m:WaitGroup\">func (*WaitGroup)</a> <a href=\"?m:WaitGroup.Wait!\">Wait</a></h2>\n<code>func (wg *WaitGroup) Wait()</code>\n<p>\nWait blocks until the WaitGroup counter is zero.\n</p>\n\n",name:"Wait"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCond!\">NewCond</a></h2>\n<code>func NewCond(l Locker) *Cond</code>\n<p>\nNewCond returns a new Cond with Locker l.\n</p>\n\n",name:"NewCond"}],consts:[],vars:[]}