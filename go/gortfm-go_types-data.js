var gortfmData = {index:"index.html",html:"<p>\nPACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\nThe types package declares the types used to represent Go types.\n</p>\n",name:"types",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Array!\">Array</a></h2>\n<pre>type Array struct {\n\tImplementsType\n\tLen uint64\n\tElt Type\n}</pre>\n<p>\nAn Array represents an array type [Len]Elt.\n</p>\n\n",name:"Array","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Basic!\">Basic</a></h2>\n<pre>type Basic struct {\n\tImplementsType\n}</pre>\n<p>\nA Basic represents a (unnamed) basic type.\n</p>\n\n",name:"Basic","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Chan!\">Chan</a></h2>\n<pre>type Chan struct {\n\tImplementsType\n\tDir ast.ChanDir\n\tElt Type\n}</pre>\n<p>\nA Chan represents a channel type chan Elt, &lt;-chan Elt, or chan&lt;-Elt.\n</p>\n\n",name:"Chan","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Const!\">Const</a></h2>\n<pre>type Const struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Const implements an ideal constant Value.\nThe zero value z for a Const is not a valid constant value.\n</p>\n\n",name:"Const","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.BinaryOp!\">BinaryOp</a></h2>\n<code>func (x Const) BinaryOp(op token.Token, y Const) Const</code>\n\n",name:"BinaryOp"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.Convert!\">Convert</a></h2>\n<code>func (x Const) Convert(typ *Type) Const</code>\n<p>\nConvert attempts to convert the constant x to a given type.\nIf the attempt is successful, the result is the new constant;\notherwise the result is invalid.\n</p>\n\n",name:"Convert"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.Match!\">Match</a></h2>\n<code>func (x Const) Match(y Const) (u, v Const)</code>\n<p>\nMatch attempts to match the internal constant representations of x and y.\nIf the attempt is successful, the result is the values of x and y,\nif necessary converted to have the same internal representation; otherwise\nthe results are invalid.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.String!\">String</a></h2>\n<code>func (x Const) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.UnaryOp!\">UnaryOp</a></h2>\n<code>func (x Const) UnaryOp(op token.Token) Const</code>\n\n",name:"UnaryOp"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Func!\">Func</a></h2>\n<pre>type Func struct {\n\tImplementsType\n\tIsVariadic bool\n}</pre>\n<p>\nA Func represents a function type func(...) (...).\n</p>\n\n",name:"Func","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ImplementsType!\">ImplementsType</a></h2>\n<pre>type ImplementsType struct{}</pre>\n<p>\nAll concrete types embed ImplementsType which\nensures that all types implement the Type interface.\n</p>\n\n",name:"ImplementsType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Interface!\">Interface</a></h2>\n<pre>type Interface struct {\n\tImplementsType\n}</pre>\n<p>\nAn Interface represents an interface type interface{...}.\n</p>\n\n",name:"Interface","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Map!\">Map</a></h2>\n<pre>type Map struct {\n\tImplementsType\n\tKey, Elt Type\n}</pre>\n<p>\nA Map represents a map type map[Key]Elt.\n</p>\n\n",name:"Map","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\n<pre>type Name struct {\n\tImplementsType\n\tUnderlying Type        // nil if not fully declared\n\tObj        *ast.Object // corresponding declared object\n\t// TODO(gri) need to remember fields and methods.\n}</pre>\n<p>\nA Name represents a named type as declared in a type declaration.\n</p>\n\n",name:"Name","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Pointer!\">Pointer</a></h2>\n<pre>type Pointer struct {\n\tImplementsType\n\tBase Type\n}</pre>\n<p>\nA Pointer represents a pointer type *Base.\n</p>\n\n",name:"Pointer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Slice!\">Slice</a></h2>\n<pre>type Slice struct {\n\tImplementsType\n\tElt Type\n}</pre>\n<p>\nA Slice represents a slice type []Elt.\n</p>\n\n",name:"Slice","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Struct!\">Struct</a></h2>\n<pre>type Struct struct {\n\tImplementsType\n}</pre>\n<p>\nA Struct represents a struct type struct{...}.\n</p>\n\n",name:"Struct","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type interface {\n\t// contains unexported methods\n}</pre>\n<p>\nAll types implement the Type interface.\n</p>\n\n",name:"Type","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Deref!\">Deref</a></h2>\n<code>func Deref(typ Type) Type</code>\n<p>\nIf typ is a pointer type, Deref returns the pointer&#39;s base type;\notherwise it returns typ.\n</p>\n\n",name:"Deref"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ExportData!\">ExportData</a></h2>\n<code>func ExportData(filename string) (rc io.ReadCloser, err os.Error)</code>\n<p>\nExportData returns a readCloser positioned at the beginning of the\nexport data section of the given object/archive file, or an error.\nIt is the caller&#39;s responsibility to close the readCloser.\n</p>\n\n",name:"ExportData"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GcImporter!\">GcImporter</a></h2>\n<code>func GcImporter(path string) (name string, scope *ast.Scope, err os.Error)</code>\n<p>\nGcImporter implements the ast.Importer signature.\n</p>\n\n",name:"GcImporter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeConst!\">MakeConst</a></h2>\n<code>func MakeConst(tok token.Token, lit string) Const</code>\n<p>\nMakeConst makes an ideal constant from a literal\ntoken and the corresponding literal string.\n</p>\n\n",name:"MakeConst"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeZero!\">MakeZero</a></h2>\n<code>func MakeZero(typ *Type) Const</code>\n<p>\nMakeZero returns the zero constant for the given type.\n</p>\n\n",name:"MakeZero"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Underlying!\">Underlying</a></h2>\n<code>func Underlying(typ Type) Type</code>\n<p>\nUnderlying returns the underlying type of a type.\n</p>\n\n",name:"Underlying"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Universe!\"><em>group</em></a></h2>\n<pre>var (\n\tUniverse,\n\tUnsafe *ast.Scope\n)</pre>\n\n",names:["Universe","Unsafe"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Bool!\"><em>group</em></a></h2>\n<pre>var (\n\tBool,\n\tInt,\n\tFloat64,\n\tComplex128,\n\tString *Name\n)</pre>\n\n",names:["Bool","Int","Float64","Complex128","String"],type:""}]}