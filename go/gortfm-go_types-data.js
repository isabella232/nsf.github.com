var gortfmData = {index:"index.html",html:"<p>\nPACKAGE UNDER CONSTRUCTION. ANY AND ALL PARTS MAY CHANGE.\nPackage types declares the types used to represent Go types.\n</p>\n",name:"types",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Array!\">Array</a></h2>\n<pre>type Array struct {\n\tImplementsType\n\tLen uint64\n\tElt Type\n}</pre>\n<p>\nAn Array represents an array type [Len]Elt.\n</p>\n\n",name:"Array","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Bad!\">Bad</a></h2>\n<pre>type Bad struct {\n\tImplementsType\n\tMsg string // for better error reporting/debugging\n}</pre>\n<p>\nA Bad type is a non-nil placeholder type when we don&#39;t know a type.\n</p>\n\n",name:"Bad","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Basic!\">Basic</a></h2>\n<pre>type Basic struct {\n\tImplementsType\n}</pre>\n<p>\nA Basic represents a (unnamed) basic type.\n</p>\n\n",name:"Basic","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Chan!\">Chan</a></h2>\n<pre>type Chan struct {\n\tImplementsType\n\tDir ast.ChanDir\n\tElt Type\n}</pre>\n<p>\nA Chan represents a channel type chan Elt, &lt;-chan Elt, or chan&lt;-Elt.\n</p>\n\n",name:"Chan","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Const!\">Const</a></h2>\n<pre>type Const struct {\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA Const implements an ideal constant Value.\nThe zero value z for a Const is not a valid constant value.\n</p>\n\n",name:"Const","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.BinaryOp!\">BinaryOp</a></h2>\n<code>func (x Const) BinaryOp(op token.Token, y Const) Const</code>\n\n",name:"BinaryOp"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.Convert!\">Convert</a></h2>\n<code>func (x Const) Convert(typ *Type) Const</code>\n<p>\nConvert attempts to convert the constant x to a given type.\nIf the attempt is successful, the result is the new constant;\notherwise the result is invalid.\n</p>\n\n",name:"Convert"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.Match!\">Match</a></h2>\n<code>func (x Const) Match(y Const) (u, v Const)</code>\n<p>\nMatch attempts to match the internal constant representations of x and y.\nIf the attempt is successful, the result is the values of x and y,\nif necessary converted to have the same internal representation; otherwise\nthe results are invalid.\n</p>\n\n",name:"Match"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.String!\">String</a></h2>\n<code>func (x Const) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:Const\">func (Const)</a> <a href=\"?m:Const.UnaryOp!\">UnaryOp</a></h2>\n<code>func (x Const) UnaryOp(op token.Token) Const</code>\n\n",name:"UnaryOp"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Func!\">Func</a></h2>\n<pre>type Func struct {\n\tImplementsType\n\tRecv       *ast.Object // nil if not a method\n\tParams     ObjList     // (incoming) parameters from left to right; or nil\n\tResults    ObjList     // (outgoing) results from left to right; or nil\n\tIsVariadic bool        // true if the last parameter&#39;s type is of the form ...T\n}</pre>\n<p>\nA Func represents a function type func(...) (...).\nUnnamed parameters are represented by objects with empty names.\n</p>\n\n",name:"Func","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ImplementsType!\">ImplementsType</a></h2>\n<pre>type ImplementsType struct{}</pre>\n<p>\nAll concrete types embed ImplementsType which\nensures that all types implement the Type interface.\n</p>\n\n",name:"ImplementsType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Interface!\">Interface</a></h2>\n<pre>type Interface struct {\n\tImplementsType\n\tMethods ObjList // interface methods sorted by name; or nil\n}</pre>\n<p>\nAn Interface represents an interface type interface{...}.\n</p>\n\n",name:"Interface","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Map!\">Map</a></h2>\n<pre>type Map struct {\n\tImplementsType\n\tKey, Elt Type\n}</pre>\n<p>\nA Map represents a map type map[Key]Elt.\n</p>\n\n",name:"Map","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Name!\">Name</a></h2>\n<pre>type Name struct {\n\tImplementsType\n\tUnderlying Type        // nil if not fully declared\n\tObj        *ast.Object // corresponding declared object\n\t// TODO(gri) need to remember fields and methods.\n}</pre>\n<p>\nA Name represents a named type as declared in a type declaration.\n</p>\n\n",name:"Name","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ObjList!\">ObjList</a></h2>\n<pre>type ObjList []*ast.Object</pre>\n<p>\nAn ObjList represents an ordered (in some fashion) list of objects.\n</p>\n\n",name:"ObjList","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ObjList\">func (ObjList)</a> <a href=\"?m:ObjList.Len!\">Len</a></h2>\n<code>func (list ObjList) Len() int</code>\n<p>\nObjList implements sort.Interface.\n</p>\n\n",name:"Len"},{html:"\n<h2><a class=\"black\" href=\"?m:ObjList\">func (ObjList)</a> <a href=\"?m:ObjList.Less!\">Less</a></h2>\n<code>func (list ObjList) Less(i, j int) bool</code>\n\n",name:"Less"},{html:"\n<h2><a class=\"black\" href=\"?m:ObjList\">func (ObjList)</a> <a href=\"?m:ObjList.Sort!\">Sort</a></h2>\n<code>func (list ObjList) Sort()</code>\n<p>\nSort sorts an object list by object name.\n</p>\n\n",name:"Sort"},{html:"\n<h2><a class=\"black\" href=\"?m:ObjList\">func (ObjList)</a> <a href=\"?m:ObjList.Swap!\">Swap</a></h2>\n<code>func (list ObjList) Swap(i, j int)</code>\n\n",name:"Swap"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Pointer!\">Pointer</a></h2>\n<pre>type Pointer struct {\n\tImplementsType\n\tBase Type\n}</pre>\n<p>\nA Pointer represents a pointer type *Base.\n</p>\n\n",name:"Pointer","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Slice!\">Slice</a></h2>\n<pre>type Slice struct {\n\tImplementsType\n\tElt Type\n}</pre>\n<p>\nA Slice represents a slice type []Elt.\n</p>\n\n",name:"Slice","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Struct!\">Struct</a></h2>\n<pre>type Struct struct {\n\tImplementsType\n\tFields ObjList  // struct fields; or nil\n\tTags   []string // corresponding tags; or nil\n\t// TODO(gri) This type needs some rethinking:\n\t// - at the moment anonymous fields are marked with &#34;&#34; object names,\n\t//   and their names have to be reconstructed\n\t// - there is no scope for fast lookup (but the parser creates one)\n}</pre>\n<p>\nA Struct represents a struct type struct{...}.\nAnonymous fields are represented by objects with empty names.\n</p>\n\n",name:"Struct","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type interface {\n\t// contains filtered or unexported methods\n}</pre>\n<p>\nAll types implement the Type interface.\n</p>\n\n",name:"Type","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Check!\">Check</a></h2>\n<code>func Check(fset *token.FileSet, pkg *ast.Package) (types map[ast.Expr]Type, err os.Error)</code>\n<p>\nCheck typechecks a package.\nIt augments the AST by assigning types to all ast.Objects and returns a map\nof types for all expression nodes in statements, and a scanner.ErrorList if\nthere are errors.\n</p>\n\n",name:"Check"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Deref!\">Deref</a></h2>\n<code>func Deref(typ Type) Type</code>\n<p>\nIf typ is a pointer type, Deref returns the pointer&#39;s base type;\notherwise it returns typ.\n</p>\n\n",name:"Deref"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ExportData!\">ExportData</a></h2>\n<code>func ExportData(filename string) (rc io.ReadCloser, err os.Error)</code>\n<p>\nExportData returns a readCloser positioned at the beginning of the\nexport data section of the given object/archive file, or an error.\nIt is the caller&#39;s responsibility to close the readCloser.\n</p>\n\n",name:"ExportData"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:GcImporter!\">GcImporter</a></h2>\n<code>func GcImporter(imports map[string]*ast.Object, path string) (pkg *ast.Object, err os.Error)</code>\n<p>\nGcImporter implements the ast.Importer signature.\n</p>\n\n",name:"GcImporter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Identical!\">Identical</a></h2>\n<code>func Identical(x, y Type) bool</code>\n<p>\nIdentical returns true if two types are identical.\n</p>\n\n",name:"Identical"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeConst!\">MakeConst</a></h2>\n<code>func MakeConst(tok token.Token, lit string) Const</code>\n<p>\nMakeConst makes an ideal constant from a literal\ntoken and the corresponding literal string.\n</p>\n\n",name:"MakeConst"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MakeZero!\">MakeZero</a></h2>\n<code>func MakeZero(typ *Type) Const</code>\n<p>\nMakeZero returns the zero constant for the given type.\n</p>\n\n",name:"MakeZero"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Underlying!\">Underlying</a></h2>\n<code>func Underlying(typ Type) Type</code>\n<p>\nUnderlying returns the underlying type of a type.\n</p>\n\n",name:"Underlying"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Universe!\"><em>group</em></a></h2>\n<pre>var (\n\tUniverse *ast.Scope\n\tUnsafe   *ast.Object // package unsafe\n)</pre>\n\n",names:["Universe","Unsafe"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Bool!\"><em>group</em></a></h2>\n<pre>var (\n\tBool,\n\tInt,\n\tFloat64,\n\tComplex128,\n\tString *Name\n)</pre>\n\n",names:["Bool","Int","Float64","Complex128","String"],type:""}]}