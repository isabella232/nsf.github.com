var gortfmData = {index:"index.html",html:"<p>\nA package of simple functions to manipulate strings.\n</p>\n",name:"strings",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader string</pre>\n<p>\nA Reader satisfies calls to Read, ReadByte, and ReadRune by\nreading from a string.\n</p>\n\n",name:"Reader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Read!\">Read</a></h2>\n<code>func (r *Reader) Read(b []byte) (n int, err os.Error)</code>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadByte!\">ReadByte</a></h2>\n<code>func (r *Reader) ReadByte() (b byte, err os.Error)</code>\n\n",name:"ReadByte"},{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadRune!\">ReadRune</a></h2>\n<code>func (r *Reader) ReadRune() (rune int, size int, err os.Error)</code>\n<p>\nReadRune reads and returns the next UTF-8-encoded\nUnicode code point from the buffer.\nIf no bytes are available, the error returned is os.EOF.\nIf the bytes are an erroneous UTF-8 encoding, it\nconsumes one byte and returns U+FFFD, 1.\n</p>\n\n",name:"ReadRune"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Contains!\">Contains</a></h2>\n<code>func Contains(s, substr string) bool</code>\n<p>\nContains returns true if substr is within s.\n</p>\n\n",name:"Contains"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Count!\">Count</a></h2>\n<code>func Count(s, sep string) int</code>\n<p>\nCount counts the number of non-overlapping instances of sep in s.\n</p>\n\n",name:"Count"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Fields!\">Fields</a></h2>\n<code>func Fields(s string) []string</code>\n<p>\nFields splits the string s around each instance of one or more consecutive white space\ncharacters, returning an array of substrings of s or an empty list if s contains only white space.\n</p>\n\n",name:"Fields"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FieldsFunc!\">FieldsFunc</a></h2>\n<code>func FieldsFunc(s string, f func(int) bool) []string</code>\n<p>\nFieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If no code points in s satisfy f(c), an empty slice\nis returned.\n</p>\n\n",name:"FieldsFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HasPrefix!\">HasPrefix</a></h2>\n<code>func HasPrefix(s, prefix string) bool</code>\n<p>\nHasPrefix tests whether the string s begins with prefix.\n</p>\n\n",name:"HasPrefix"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HasSuffix!\">HasSuffix</a></h2>\n<code>func HasSuffix(s, suffix string) bool</code>\n<p>\nHasSuffix tests whether the string s ends with suffix.\n</p>\n\n",name:"HasSuffix"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Index!\">Index</a></h2>\n<code>func Index(s, sep string) int</code>\n<p>\nIndex returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n</p>\n\n",name:"Index"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexAny!\">IndexAny</a></h2>\n<code>func IndexAny(s, chars string) int</code>\n<p>\nIndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n</p>\n\n",name:"IndexAny"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexFunc!\">IndexFunc</a></h2>\n<code>func IndexFunc(s string, f func(r int) bool) int</code>\n<p>\nIndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n</p>\n\n",name:"IndexFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IndexRune!\">IndexRune</a></h2>\n<code>func IndexRune(s string, rune int) int</code>\n<p>\nIndexRune returns the index of the first instance of the Unicode code point\nrune, or -1 if rune is not present in s.\n</p>\n\n",name:"IndexRune"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Join!\">Join</a></h2>\n<code>func Join(a []string, sep string) string</code>\n<p>\nJoin concatenates the elements of a to create a single string.   The separator string\nsep is placed between elements in the resulting string.\n</p>\n\n",name:"Join"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LastIndex!\">LastIndex</a></h2>\n<code>func LastIndex(s, sep string) int</code>\n<p>\nLastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n</p>\n\n",name:"LastIndex"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LastIndexFunc!\">LastIndexFunc</a></h2>\n<code>func LastIndexFunc(s string, f func(r int) bool) int</code>\n<p>\nLastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n</p>\n\n",name:"LastIndexFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Map!\">Map</a></h2>\n<code>func Map(mapping func(rune int) int, s string) string</code>\n<p>\nMap returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n</p>\n\n",name:"Map"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(s string) *Reader</code>\n<p>\nNewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n</p>\n\n",name:"NewReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Repeat!\">Repeat</a></h2>\n<code>func Repeat(s string, count int) string</code>\n<p>\nRepeat returns a new string consisting of count copies of the string s.\n</p>\n\n",name:"Repeat"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Replace!\">Replace</a></h2>\n<code>func Replace(s, old, new string, n int) string</code>\n<p>\nReplace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf n &lt; 0, there is no limit on the number of replacements.\n</p>\n\n",name:"Replace"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Split!\">Split</a></h2>\n<code>func Split(s, sep string, n int) []string</code>\n<p>\nSplit slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nThe count determines the number of substrings to return:\n</p>\n<pre>n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn &lt; 0: all substrings\n</pre>\n\n",name:"Split"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SplitAfter!\">SplitAfter</a></h2>\n<code>func SplitAfter(s, sep string, n int) []string</code>\n<p>\nSplitAfter slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\nIf sep is empty, Split splits after each UTF-8 sequence.\nThe count determines the number of substrings to return:\n</p>\n<pre>n &gt; 0: at most n substrings; the last substring will be the unsplit remainder.\nn == 0: the result is nil (zero substrings)\nn &lt; 0: all substrings\n</pre>\n\n",name:"SplitAfter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Title!\">Title</a></h2>\n<code>func Title(s string) string</code>\n<p>\nTitle returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n</p>\n\n",name:"Title"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToLower!\">ToLower</a></h2>\n<code>func ToLower(s string) string</code>\n<p>\nToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n</p>\n\n",name:"ToLower"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToLowerSpecial!\">ToLowerSpecial</a></h2>\n<code>func ToLowerSpecial(_case unicode.SpecialCase, s string) string</code>\n<p>\nToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n</p>\n\n",name:"ToLowerSpecial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToTitle!\">ToTitle</a></h2>\n<code>func ToTitle(s string) string</code>\n<p>\nToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n</p>\n\n",name:"ToTitle"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToTitleSpecial!\">ToTitleSpecial</a></h2>\n<code>func ToTitleSpecial(_case unicode.SpecialCase, s string) string</code>\n<p>\nToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n</p>\n\n",name:"ToTitleSpecial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToUpper!\">ToUpper</a></h2>\n<code>func ToUpper(s string) string</code>\n<p>\nToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n</p>\n\n",name:"ToUpper"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ToUpperSpecial!\">ToUpperSpecial</a></h2>\n<code>func ToUpperSpecial(_case unicode.SpecialCase, s string) string</code>\n<p>\nToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n</p>\n\n",name:"ToUpperSpecial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Trim!\">Trim</a></h2>\n<code>func Trim(s string, cutset string) string</code>\n<p>\nTrim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n</p>\n\n",name:"Trim"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimFunc!\">TrimFunc</a></h2>\n<code>func TrimFunc(s string, f func(r int) bool) string</code>\n<p>\nTrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n</p>\n\n",name:"TrimFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimLeft!\">TrimLeft</a></h2>\n<code>func TrimLeft(s string, cutset string) string</code>\n<p>\nTrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n</p>\n\n",name:"TrimLeft"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimLeftFunc!\">TrimLeftFunc</a></h2>\n<code>func TrimLeftFunc(s string, f func(r int) bool) string</code>\n<p>\nTrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n</p>\n\n",name:"TrimLeftFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimRight!\">TrimRight</a></h2>\n<code>func TrimRight(s string, cutset string) string</code>\n<p>\nTrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n</p>\n\n",name:"TrimRight"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimRightFunc!\">TrimRightFunc</a></h2>\n<code>func TrimRightFunc(s string, f func(r int) bool) string</code>\n<p>\nTrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n</p>\n\n",name:"TrimRightFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TrimSpace!\">TrimSpace</a></h2>\n<code>func TrimSpace(s string) string</code>\n<p>\nTrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n</p>\n\n",name:"TrimSpace"}],consts:[],vars:[]}