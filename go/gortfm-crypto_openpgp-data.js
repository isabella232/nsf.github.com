var gortfmData = {index:"index.html",html:"<p>\nThis openpgp package implements high level operations on OpenPGP messages.\n</p>\n",name:"openpgp",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Entity!\">Entity</a></h2>\n<pre>type Entity struct {\n\tPrimaryKey *packet.PublicKey\n\tPrivateKey *packet.PrivateKey\n\tIdentities map[string]*Identity // indexed by Identity.Name\n\tSubkeys    []Subkey\n}</pre>\n<p>\nAn Entity represents the components of an OpenPGP key: a primary public key\n(which must be a signing key), one or more identities claimed by that key,\nand zero or more subkeys, which may be encryption keys.\n</p>\n\n",name:"Entity","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EntityList!\">EntityList</a></h2>\n<pre>type EntityList []*Entity</pre>\n<p>\nAn EntityList contains one or more Entities.\n</p>\n\n",name:"EntityList","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:EntityList\">func (EntityList)</a> <a href=\"?m:EntityList.DecryptionKeys!\">DecryptionKeys</a></h2>\n<code>func (el EntityList) DecryptionKeys() (keys []Key)</code>\n<p>\nDecryptionKeys returns all private keys that are valid for decryption.\n</p>\n\n",name:"DecryptionKeys"},{html:"\n<h2><a class=\"black\" href=\"?m:EntityList\">func (EntityList)</a> <a href=\"?m:EntityList.KeysById!\">KeysById</a></h2>\n<code>func (el EntityList) KeysById(id uint64) (keys []Key)</code>\n<p>\nKeysById returns the set of keys that have the given key id.\n</p>\n\n",name:"KeysById"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Identity!\">Identity</a></h2>\n<pre>type Identity struct {\n\tName          string // by convention, has the form &#34;Full Name (comment) &lt;email@example.com&gt;&#34;\n\tUserId        *packet.UserId\n\tSelfSignature *packet.Signature\n\tSignatures    []*packet.Signature\n}</pre>\n<p>\nAn Identity represents an identity claimed by an Entity and zero or more\nassertions by other entities about that claim.\n</p>\n\n",name:"Identity","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Key!\">Key</a></h2>\n<pre>type Key struct {\n\tEntity        *Entity\n\tPublicKey     *packet.PublicKey\n\tPrivateKey    *packet.PrivateKey\n\tSelfSignature *packet.Signature\n}</pre>\n<p>\nA Key identifies a specific public key in an Entity. This is either the\nEntity&#39;s primary key or a subkey.\n</p>\n\n",name:"Key","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:KeyRing!\">KeyRing</a></h2>\n<pre>type KeyRing interface {\n\t// KeysById returns the set of keys that have the given key id.\n\tKeysById(id uint64) []Key\n\t// DecryptionKeys returns all private keys that are valid for\n\t// decryption.\n\tDecryptionKeys() []Key\n}</pre>\n<p>\nA KeyRing provides access to public and private keys.\n</p>\n\n",name:"KeyRing","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MessageDetails!\">MessageDetails</a></h2>\n<pre>type MessageDetails struct {\n\tIsEncrypted              bool                // true if the message was encrypted.\n\tEncryptedToKeyIds        []uint64            // the list of recipient key ids.\n\tIsSymmetricallyEncrypted bool                // true if a passphrase could have decrypted the message.\n\tDecryptedWith            Key                 // the private key used to decrypt the message, if any.\n\tIsSigned                 bool                // true if the message is signed.\n\tSignedByKeyId            uint64              // the key id of the signer, if any.\n\tSignedBy                 *Key                // the key of the signer, if availible.\n\tLiteralData              *packet.LiteralData // the metadata of the contents\n\tUnverifiedBody           io.Reader           // the contents of the message.\n\n\n\tSignatureError os.Error          // nil if the signature is good.\n\tSignature      *packet.Signature // the signature packet itself.\n\t// contains unexported fields\n}</pre>\n<p>\nMessageDetails contains the result of parsing an OpenPGP encrypted and/or\nsigned message.\n</p>\n\n",name:"MessageDetails","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PromptFunction!\">PromptFunction</a></h2>\n<pre>type PromptFunction func(keys []Key, symmetric bool) ([]byte, os.Error)</pre>\n<p>\nA PromptFunction is used as a callback by functions that may need to decrypt\na private key, or prompt for a passphrase. It is called with a list of\nacceptable, encrypted private keys and a boolean that indicates whether a\npassphrase is usable. It should either decrypt a private key or return a\npassphrase to try. If the decrypted private key or given passphrase isn&#39;t\ncorrect, the function will be called again, forever. Any error returned will\nbe passed up.\n</p>\n\n",name:"PromptFunction","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Subkey!\">Subkey</a></h2>\n<pre>type Subkey struct {\n\tPublicKey  *packet.PublicKey\n\tPrivateKey *packet.PrivateKey\n\tSig        *packet.Signature\n}</pre>\n<p>\nA Subkey is an additional public key in an Entity. Subkeys can be used for\nencryption.\n</p>\n\n",name:"Subkey","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ArmoredDetachSign!\">ArmoredDetachSign</a></h2>\n<code>func ArmoredDetachSign(w io.Writer, signer *Entity, message io.Reader) (err os.Error)</code>\n<p>\nArmoredDetachSign signs message with the private key from signer (which\nmust already have been decrypted) and writes an armored signature to w.\n</p>\n\n",name:"ArmoredDetachSign"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ArmoredDetachSignText!\">ArmoredDetachSignText</a></h2>\n<code>func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error</code>\n<p>\nArmoredDetachSignText signs message (after canonicalising the line endings)\nwith the private key from signer (which must already have been decrypted)\nand writes an armored signature to w.\n</p>\n\n",name:"ArmoredDetachSignText"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckArmoredDetachedSignature!\">CheckArmoredDetachedSignature</a></h2>\n<code>func CheckArmoredDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error)</code>\n<p>\nCheckArmoredDetachedSignature performs the same actions as\nCheckDetachedSignature but expects the signature to be armored.\n</p>\n\n",name:"CheckArmoredDetachedSignature"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CheckDetachedSignature!\">CheckDetachedSignature</a></h2>\n<code>func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signer *Entity, err os.Error)</code>\n<p>\nCheckDetachedSignature takes a signed file and a detached signature and\nreturns the signer if the signature is valid. If the signer isn&#39;t know,\nUnknownIssuerError is returned.\n</p>\n\n",name:"CheckDetachedSignature"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DetachSign!\">DetachSign</a></h2>\n<code>func DetachSign(w io.Writer, signer *Entity, message io.Reader) os.Error</code>\n<p>\nDetachSign signs message with the private key from signer (which must\nalready have been decrypted) and writes the signature to w.\n</p>\n\n",name:"DetachSign"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DetachSignText!\">DetachSignText</a></h2>\n<code>func DetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error</code>\n<p>\nDetachSignText signs message (after canonicalising the line endings) with\nthe private key from signer (which must already have been decrypted) and\nwrites the signature to w.\n</p>\n\n",name:"DetachSignText"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewCanonicalTextHash!\">NewCanonicalTextHash</a></h2>\n<code>func NewCanonicalTextHash(h hash.Hash) hash.Hash</code>\n<p>\nNewCanonicalTextHash reformats text written to it into the canonical\nform and then applies the hash h.  See RFC 4880, section 5.2.1.\n</p>\n\n",name:"NewCanonicalTextHash"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadArmoredKeyRing!\">ReadArmoredKeyRing</a></h2>\n<code>func ReadArmoredKeyRing(r io.Reader) (EntityList, os.Error)</code>\n<p>\nReadArmoredKeyRing reads one or more public/private keys from an armor keyring file.\n</p>\n\n",name:"ReadArmoredKeyRing"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadKeyRing!\">ReadKeyRing</a></h2>\n<code>func ReadKeyRing(r io.Reader) (el EntityList, err os.Error)</code>\n<p>\nReadKeyRing reads one or more public/private keys, ignoring unsupported keys.\n</p>\n\n",name:"ReadKeyRing"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadMessage!\">ReadMessage</a></h2>\n<code>func ReadMessage(r io.Reader, keyring KeyRing, prompt PromptFunction) (md *MessageDetails, err os.Error)</code>\n<p>\nReadMessage parses an OpenPGP message that may be signed and/or encrypted.\nThe given KeyRing should contain both public keys (for signature\nverification) and, possibly encrypted, private keys for decrypting.\n</p>\n\n",name:"ReadMessage"}],consts:[],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:SignatureType!\">SignatureType</a></h2>\n<pre>var SignatureType = &#34;PGP SIGNATURE&#34;</pre>\n<p>\nSignatureType is the armor type for a PGP signature.\n</p>\n\n",names:["SignatureType"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:PublicKeyType!\">PublicKeyType</a></h2>\n<pre>var PublicKeyType = &#34;PGP PUBLIC KEY BLOCK&#34;</pre>\n<p>\nPublicKeyType is the armor type for a PGP public key.\n</p>\n\n",names:["PublicKeyType"],type:""}]}