var gortfmData = {index:"index.html",html:"<p>\nThe flate package implements the DEFLATE compressed data\nformat, described in RFC 1951.  The gzip and zlib packages\nimplement access to DEFLATE-based file formats.\n</p>\n",name:"flate",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CorruptInputError!\">CorruptInputError</a></h2>\n<pre>type CorruptInputError int64</pre>\n<p>\nA CorruptInputError reports the presence of corrupt input at a given offset.\n</p>\n\n",name:"CorruptInputError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CorruptInputError\">func (CorruptInputError)</a> <a href=\"?m:CorruptInputError.String!\">String</a></h2>\n<code>func (e CorruptInputError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InternalError!\">InternalError</a></h2>\n<pre>type InternalError string</pre>\n<p>\nAn InternalError reports an error in the flate code itself.\n</p>\n\n",name:"InternalError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InternalError\">func (InternalError)</a> <a href=\"?m:InternalError.String!\">String</a></h2>\n<code>func (e InternalError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadError!\">ReadError</a></h2>\n<pre>type ReadError struct {\n\tOffset int64    // byte offset where error occurred\n\tError  os.Error // error returned by underlying Read\n}</pre>\n<p>\nA ReadError reports an error encountered while reading input.\n</p>\n\n",name:"ReadError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReadError\">func (*ReadError)</a> <a href=\"?m:ReadError.String!\">String</a></h2>\n<code>func (e *ReadError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader interface {\n\tio.Reader\n\tReadByte() (c byte, err os.Error)\n}</pre>\n<p>\nThe actual read interface needed by NewReader.\nIf the passed in io.Reader does not also have ReadByte,\nthe NewReader will introduce its own buffering.\n</p>\n\n",name:"Reader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteError!\">WriteError</a></h2>\n<pre>type WriteError struct {\n\tOffset int64    // byte offset where error occurred\n\tError  os.Error // error returned by underlying Write\n}</pre>\n<p>\nA WriteError reports an error encountered while writing output.\n</p>\n\n",name:"WriteError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WriteError\">func (*WriteError)</a> <a href=\"?m:WriteError.String!\">String</a></h2>\n<code>func (e *WriteError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WrongValueError!\">WrongValueError</a></h2>\n<pre>type WrongValueError struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"WrongValueError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WrongValueError\">func (WrongValueError)</a> <a href=\"?m:WrongValueError.String!\">String</a></h2>\n<code>func (err WrongValueError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(r io.Reader) io.ReadCloser</code>\n<p>\nNewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.  It is the caller&#39;s\nresponsibility to call Close on the ReadCloser when\nfinished reading.\n</p>\n\n",name:"NewReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\n<code>func NewWriter(w io.Writer, level int) io.WriteCloser</code>\n\n",name:"NewWriter"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:NoCompression!\"><em>group</em></a></h2>\n<pre>const (\n\tNoCompression = 0\n\tBestSpeed     = 1\n\n\tBestCompression    = 9\n\tDefaultCompression = -1\n)</pre>\n\n",names:["NoCompression","BestSpeed","BestCompression","DefaultCompression"],type:""}],vars:[]}