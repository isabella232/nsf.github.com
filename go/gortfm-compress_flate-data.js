var gortfmData = {index:"index.html",html:"<p>\nThe flate package implements the DEFLATE compressed data\nformat, described in RFC 1951.  The gzip and zlib packages\nimplement access to DEFLATE-based file formats.\n</p>\n",name:"flate",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CorruptInputError!\">CorruptInputError</a></h2>\n<pre>type CorruptInputError int64</pre>\n<p>\nA CorruptInputError reports the presence of corrupt input at a given offset.\n</p>\n\n",name:"CorruptInputError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CorruptInputError\">func (CorruptInputError)</a> <a href=\"?m:CorruptInputError.String!\">String</a></h2>\n<code>func (e CorruptInputError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InternalError!\">InternalError</a></h2>\n<pre>type InternalError string</pre>\n<p>\nAn InternalError reports an error in the flate code itself.\n</p>\n\n",name:"InternalError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InternalError\">func (InternalError)</a> <a href=\"?m:InternalError.String!\">String</a></h2>\n<code>func (e InternalError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadError!\">ReadError</a></h2>\n<pre>type ReadError struct {\n\tOffset int64    // byte offset where error occurred\n\tError  os.Error // error returned by underlying Read\n}</pre>\n<p>\nA ReadError reports an error encountered while reading input.\n</p>\n\n",name:"ReadError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReadError\">func (*ReadError)</a> <a href=\"?m:ReadError.String!\">String</a></h2>\n<code>func (e *ReadError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader interface {\n\tio.Reader\n\tReadByte() (c byte, err os.Error)\n}</pre>\n<p>\nThe actual read interface needed by NewReader.\nIf the passed in io.Reader does not also have ReadByte,\nthe NewReader will introduce its own buffering.\n</p>\n\n",name:"Reader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WriteError!\">WriteError</a></h2>\n<pre>type WriteError struct {\n\tOffset int64    // byte offset where error occurred\n\tError  os.Error // error returned by underlying Write\n}</pre>\n<p>\nA WriteError reports an error encountered while writing output.\n</p>\n\n",name:"WriteError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WriteError\">func (*WriteError)</a> <a href=\"?m:WriteError.String!\">String</a></h2>\n<code>func (e *WriteError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\n<pre>type Writer struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Writer takes data written to it and writes the compressed\nform of that data to an underlying writer (see NewWriter).\n</p>\n\n",name:"Writer","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Close!\">Close</a></h2>\n<code>func (w *Writer) Close() os.Error</code>\n<p>\nClose flushes and closes the writer.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Flush!\">Flush</a></h2>\n<code>func (w *Writer) Flush() os.Error</code>\n<p>\nFlush flushes any pending compressed data to the underlying writer.\nIt is useful mainly in compressed network protocols, to ensure that\na remote reader has enough data to reconstruct a packet.\nFlush does not return until the data has been written.\nIf the underlying writer returns an error, Flush returns that error.\n</p>\n<p>\nIn the terminology of the zlib library, Flush is equivalent to Z_SYNC_FLUSH.\n</p>\n\n",name:"Flush"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Write!\">Write</a></h2>\n<code>func (w *Writer) Write(data []byte) (n int, err os.Error)</code>\n<p>\nWrite writes data to w, which will eventually write the\ncompressed form of data to its underlying writer.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:WrongValueError!\">WrongValueError</a></h2>\n<pre>type WrongValueError struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"WrongValueError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:WrongValueError\">func (WrongValueError)</a> <a href=\"?m:WrongValueError.String!\">String</a></h2>\n<code>func (err WrongValueError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(r io.Reader) io.ReadCloser</code>\n<p>\nNewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.  It is the caller&#39;s\nresponsibility to call Close on the ReadCloser when\nfinished reading.\n</p>\n\n",name:"NewReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\n<code>func NewWriter(w io.Writer, level int) *Writer</code>\n<p>\nNewWriter returns a new Writer compressing\ndata at the given level.  Following zlib, levels\nrange from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more.\nLevel 0 (NoCompression) does not attempt any\ncompression; it only adds the necessary DEFLATE framing.\n</p>\n\n",name:"NewWriter"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:NoCompression!\"><em>group</em></a></h2>\n<pre>const (\n\tNoCompression = 0\n\tBestSpeed     = 1\n\n\tBestCompression    = 9\n\tDefaultCompression = -1\n)</pre>\n\n",names:["NoCompression","BestSpeed","BestCompression","DefaultCompression"],type:""}],vars:[]}