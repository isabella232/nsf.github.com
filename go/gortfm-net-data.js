var gortfmData = {index:"index.html",html:"<p>\nThe net package provides a portable interface to Unix\nnetworks sockets, including TCP/IP, UDP, domain name\nresolution, and Unix domain sockets.\n</p>\n",name:"net",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Addr!\">Addr</a></h2>\n<pre>type Addr interface {\n\tNetwork() string // name of the network\n\tString() string  // string form of address\n}</pre>\n<p>\nAddr represents a network end point address.\n</p>\n\n",name:"Addr","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AddrError!\">AddrError</a></h2>\n<pre>type AddrError struct {\n\tError string\n\tAddr  string\n}</pre>\n\n",name:"AddrError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.String!\">String</a></h2>\n<code>func (e *AddrError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.Temporary!\">Temporary</a></h2>\n<code>func (e *AddrError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:AddrError\">func (*AddrError)</a> <a href=\"?m:AddrError.Timeout!\">Timeout</a></h2>\n<code>func (e *AddrError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Conn!\">Conn</a></h2>\n<pre>type Conn interface {\n\t// Read reads data from the connection.\n\t// Read can be made to time out and return a net.Error with Timeout() == true\n\t// after a fixed time limit; see SetTimeout and SetReadTimeout.\n\tRead(b []byte) (n int, err os.Error)\n\n\t// Write writes data to the connection.\n\t// Write can be made to time out and return a net.Error with Timeout() == true\n\t// after a fixed time limit; see SetTimeout and SetWriteTimeout.\n\tWrite(b []byte) (n int, err os.Error)\n\n\t// Close closes the connection.\n\tClose() os.Error\n\n\t// LocalAddr returns the local network address.\n\tLocalAddr() Addr\n\n\t// RemoteAddr returns the remote network address.\n\tRemoteAddr() Addr\n\n\t// SetTimeout sets the read and write deadlines associated\n\t// with the connection.\n\tSetTimeout(nsec int64) os.Error\n\n\t// SetReadTimeout sets the time (in nanoseconds) that\n\t// Read will wait for data before returning an error with Timeout() == true.\n\t// Setting nsec == 0 (the default) disables the deadline.\n\tSetReadTimeout(nsec int64) os.Error\n\n\t// SetWriteTimeout sets the time (in nanoseconds) that\n\t// Write will wait to send its data before returning an error with Timeout() == true.\n\t// Setting nsec == 0 (the default) disables the deadline.\n\t// Even if write times out, it may return n &gt; 0, indicating that\n\t// some of the data was successfully written.\n\tSetWriteTimeout(nsec int64) os.Error\n}</pre>\n<p>\nConn is a generic stream-oriented network connection.\n</p>\n\n",name:"Conn","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DNSConfigError!\">DNSConfigError</a></h2>\n<pre>type DNSConfigError struct {\n\tError os.Error\n}</pre>\n\n",name:"DNSConfigError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.String!\">String</a></h2>\n<code>func (e *DNSConfigError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.Temporary!\">Temporary</a></h2>\n<code>func (e *DNSConfigError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:DNSConfigError\">func (*DNSConfigError)</a> <a href=\"?m:DNSConfigError.Timeout!\">Timeout</a></h2>\n<code>func (e *DNSConfigError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DNSError!\">DNSError</a></h2>\n<pre>type DNSError struct {\n\tError     string // description of the error\n\tName      string // name looked for\n\tServer    string // server used\n\tIsTimeout bool\n}</pre>\n<p>\nDNSError represents a DNS lookup error.\n</p>\n\n",name:"DNSError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.String!\">String</a></h2>\n<code>func (e *DNSError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.Temporary!\">Temporary</a></h2>\n<code>func (e *DNSError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:DNSError\">func (*DNSError)</a> <a href=\"?m:DNSError.Timeout!\">Timeout</a></h2>\n<code>func (e *DNSError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Error!\">Error</a></h2>\n<pre>type Error interface {\n\tos.Error\n\tTimeout() bool   // Is the error a timeout?\n\tTemporary() bool // Is the error temporary?\n}</pre>\n<p>\nAn Error represents a network error.\n</p>\n\n",name:"Error","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IP!\">IP</a></h2>\n<pre>type IP []byte</pre>\n<p>\nAn IP is a single IP address, an array of bytes.\nFunctions in this package accept either 4-byte (IP v4)\nor 16-byte (IP v6) arrays as input.  Unless otherwise\nspecified, functions in this package always return\nIP addresses in 16-byte form using the canonical\nembedding.\n</p>\n<p>\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte array: a 16-byte array can still\nbe an IPv4 address.\n</p>\n\n",name:"IP","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.DefaultMask!\">DefaultMask</a></h2>\n<code>func (ip IP) DefaultMask() IPMask</code>\n<p>\nDefaultMask returns the default IP mask for the IP address ip.\nOnly IPv4 addresses have default masks; DefaultMask returns\nnil if ip is not a valid IPv4 address.\n</p>\n\n",name:"DefaultMask"},{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.Equal!\">Equal</a></h2>\n<code>func (ip IP) Equal(x IP) bool</code>\n<p>\nEqual returns true if ip and x are the same IP address.\nAn IPv4 address and that same address in IPv6 form are\nconsidered to be equal.\n</p>\n\n",name:"Equal"},{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.Mask!\">Mask</a></h2>\n<code>func (ip IP) Mask(mask IPMask) IP</code>\n<p>\nMask returns the result of masking the IP address ip with mask.\n</p>\n\n",name:"Mask"},{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.String!\">String</a></h2>\n<code>func (ip IP) String() string</code>\n<p>\nString returns the string form of the IP address ip.\nIf the address is an IPv4 address, the string representation\nis dotted decimal (&#34;74.125.19.99&#34;).  Otherwise the representation\nis IPv6 (&#34;2001:4860:0:2001::68&#34;).\n</p>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.To16!\">To16</a></h2>\n<code>func (ip IP) To16() IP</code>\n<p>\nTo16 converts the IP address ip to a 16-byte representation.\nIf ip is not an IP address (it is the wrong length), To16 returns nil.\n</p>\n\n",name:"To16"},{html:"\n<h2><a class=\"black\" href=\"?m:IP\">func (IP)</a> <a href=\"?m:IP.To4!\">To4</a></h2>\n<code>func (ip IP) To4() IP</code>\n<p>\nTo4 converts the IPv4 address ip to a 4-byte representation.\nIf ip is not an IPv4 address, To4 returns nil.\n</p>\n\n",name:"To4"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPAddr!\">IPAddr</a></h2>\n<pre>type IPAddr struct {\n\tIP IP\n}</pre>\n<p>\nIPAddr represents the address of a IP end point.\n</p>\n\n",name:"IPAddr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IPAddr\">func (*IPAddr)</a> <a href=\"?m:IPAddr.Network!\">Network</a></h2>\n<code>func (a *IPAddr) Network() string</code>\n<p>\nNetwork returns the address&#39;s network name, &#34;ip&#34;.\n</p>\n\n",name:"Network"},{html:"\n<h2><a class=\"black\" href=\"?m:IPAddr\">func (*IPAddr)</a> <a href=\"?m:IPAddr.String!\">String</a></h2>\n<code>func (a *IPAddr) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPConn!\">IPConn</a></h2>\n<pre>type IPConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nIPConn is the implementation of the Conn and PacketConn\ninterfaces for IP network connections.\n</p>\n\n",name:"IPConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.BindToDevice!\">BindToDevice</a></h2>\n<code>func (c *IPConn) BindToDevice(device string) os.Error</code>\n<p>\nBindToDevice binds an IPConn to a network interface.\n</p>\n\n",name:"BindToDevice"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Close!\">Close</a></h2>\n<code>func (c *IPConn) Close() os.Error</code>\n<p>\nClose closes the IP connection.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (c *IPConn) LocalAddr() Addr</code>\n<p>\nLocalAddr returns the local network address.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Read!\">Read</a></h2>\n<code>func (c *IPConn) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead implements the net.Conn Read method.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.ReadFrom!\">ReadFrom</a></h2>\n<code>func (c *IPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\n<p>\nReadFrom implements the net.PacketConn ReadFrom method.\n</p>\n\n",name:"ReadFrom"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.ReadFromIP!\">ReadFromIP</a></h2>\n<code>func (c *IPConn) ReadFromIP(b []byte) (n int, addr *IPAddr, err os.Error)</code>\n<p>\nReadFromIP reads a IP packet from c, copying the payload into b.\nIt returns the number of bytes copied into b and the return address\nthat was on the packet.\n</p>\n<p>\nReadFromIP can be made to time out and return an error with\nTimeout() == true after a fixed time limit; see SetTimeout and\nSetReadTimeout.\n</p>\n\n",name:"ReadFromIP"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (c *IPConn) RemoteAddr() Addr</code>\n<p>\nRemoteAddr returns the remote network address, a *IPAddr.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\n<code>func (c *IPConn) SetReadBuffer(bytes int) os.Error</code>\n<p>\nSetReadBuffer sets the size of the operating system&#39;s\nreceive buffer associated with the connection.\n</p>\n\n",name:"SetReadBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (c *IPConn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout implements the net.Conn SetReadTimeout method.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (c *IPConn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout implements the net.Conn SetTimeout method.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\n<code>func (c *IPConn) SetWriteBuffer(bytes int) os.Error</code>\n<p>\nSetWriteBuffer sets the size of the operating system&#39;s\ntransmit buffer associated with the connection.\n</p>\n\n",name:"SetWriteBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (c *IPConn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWriteTimeout implements the net.Conn SetWriteTimeout method.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.Write!\">Write</a></h2>\n<code>func (c *IPConn) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the net.Conn Write method.\n</p>\n\n",name:"Write"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.WriteTo!\">WriteTo</a></h2>\n<code>func (c *IPConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\n<p>\nWriteTo implements the net.PacketConn WriteTo method.\n</p>\n\n",name:"WriteTo"},{html:"\n<h2><a class=\"black\" href=\"?m:IPConn\">func (*IPConn)</a> <a href=\"?m:IPConn.WriteToIP!\">WriteToIP</a></h2>\n<code>func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (n int, err os.Error)</code>\n<p>\nWriteToIP writes a IP packet to addr via c, copying the payload from b.\n</p>\n<p>\nWriteToIP can be made to time out and return\nan error with Timeout() == true after a fixed time limit;\nsee SetTimeout and SetWriteTimeout.\nOn packet-oriented connections, write timeouts are rare.\n</p>\n\n",name:"WriteToIP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:IPMask!\">IPMask</a></h2>\n<pre>type IPMask []byte</pre>\n<p>\nAn IP mask is an IP address.\n</p>\n\n",name:"IPMask","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:IPMask\">func (IPMask)</a> <a href=\"?m:IPMask.String!\">String</a></h2>\n<code>func (mask IPMask) String() string</code>\n<p>\nString returns the string representation of mask.\nIf the mask is in the canonical form--ones followed by zeros--the\nstring representation is just the decimal number of ones.\nIf the mask is in a non-canonical form, it is formatted\nas an IP address.\n</p>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidAddrError!\">InvalidAddrError</a></h2>\n<pre>type InvalidAddrError string</pre>\n\n",name:"InvalidAddrError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.String!\">String</a></h2>\n<code>func (e InvalidAddrError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.Temporary!\">Temporary</a></h2>\n<code>func (e InvalidAddrError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:InvalidAddrError\">func (InvalidAddrError)</a> <a href=\"?m:InvalidAddrError.Timeout!\">Timeout</a></h2>\n<code>func (e InvalidAddrError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidConnError!\">InvalidConnError</a></h2>\n<pre>type InvalidConnError struct{}</pre>\n\n",name:"InvalidConnError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.String!\">String</a></h2>\n<code>func (e *InvalidConnError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.Temporary!\">Temporary</a></h2>\n<code>func (e *InvalidConnError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:InvalidConnError\">func (*InvalidConnError)</a> <a href=\"?m:InvalidConnError.Timeout!\">Timeout</a></h2>\n<code>func (e *InvalidConnError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Listener!\">Listener</a></h2>\n<pre>type Listener interface {\n\t// Accept waits for and returns the next connection to the listener.\n\tAccept() (c Conn, err os.Error)\n\n\t// Close closes the listener.\n\tClose() os.Error\n\n\t// Addr returns the listener&#39;s network address.\n\tAddr() Addr\n}</pre>\n<p>\nA Listener is a generic network listener for stream-oriented protocols.\n</p>\n\n",name:"Listener","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MX!\">MX</a></h2>\n<pre>type MX struct {\n\tHost string\n\tPref uint16\n}</pre>\n<p>\nAn MX represents a single DNS MX record.\n</p>\n\n",name:"MX","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:OpError!\">OpError</a></h2>\n<pre>type OpError struct {\n\tOp    string\n\tNet   string\n\tAddr  Addr\n\tError os.Error\n}</pre>\n\n",name:"OpError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.String!\">String</a></h2>\n<code>func (e *OpError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.Temporary!\">Temporary</a></h2>\n<code>func (e *OpError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:OpError\">func (*OpError)</a> <a href=\"?m:OpError.Timeout!\">Timeout</a></h2>\n<code>func (e *OpError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PacketConn!\">PacketConn</a></h2>\n<pre>type PacketConn interface {\n\t// ReadFrom reads a packet from the connection,\n\t// copying the payload into b.  It returns the number of\n\t// bytes copied into b and the return address that\n\t// was on the packet.\n\t// ReadFrom can be made to time out and return\n\t// an error with Timeout() == true after a fixed time limit;\n\t// see SetTimeout and SetReadTimeout.\n\tReadFrom(b []byte) (n int, addr Addr, err os.Error)\n\n\t// WriteTo writes a packet with payload b to addr.\n\t// WriteTo can be made to time out and return\n\t// an error with Timeout() == true after a fixed time limit;\n\t// see SetTimeout and SetWriteTimeout.\n\t// On packet-oriented connections, write timeouts are rare.\n\tWriteTo(b []byte, addr Addr) (n int, err os.Error)\n\n\t// Close closes the connection.\n\tClose() os.Error\n\n\t// LocalAddr returns the local network address.\n\tLocalAddr() Addr\n\n\t// SetTimeout sets the read and write deadlines associated\n\t// with the connection.\n\tSetTimeout(nsec int64) os.Error\n\n\t// SetReadTimeout sets the time (in nanoseconds) that\n\t// Read will wait for data before returning an error with Timeout() == true.\n\t// Setting nsec == 0 (the default) disables the deadline.\n\tSetReadTimeout(nsec int64) os.Error\n\n\t// SetWriteTimeout sets the time (in nanoseconds) that\n\t// Write will wait to send its data before returning an error with Timeout() == true.\n\t// Setting nsec == 0 (the default) disables the deadline.\n\t// Even if write times out, it may return n &gt; 0, indicating that\n\t// some of the data was successfully written.\n\tSetWriteTimeout(nsec int64) os.Error\n}</pre>\n<p>\nPacketConn is a generic packet-oriented network connection.\n</p>\n\n",name:"PacketConn","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ParseError!\">ParseError</a></h2>\n<pre>type ParseError struct {\n\tType string\n\tText string\n}</pre>\n<p>\nA ParseError represents a malformed text string and the type of string that was expected.\n</p>\n\n",name:"ParseError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ParseError\">func (*ParseError)</a> <a href=\"?m:ParseError.String!\">String</a></h2>\n<code>func (e *ParseError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SRV!\">SRV</a></h2>\n<pre>type SRV struct {\n\tTarget   string\n\tPort     uint16\n\tPriority uint16\n\tWeight   uint16\n}</pre>\n<p>\nAn SRV represents a single DNS SRV record.\n</p>\n\n",name:"SRV","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPAddr!\">TCPAddr</a></h2>\n<pre>type TCPAddr struct {\n\tIP   IP\n\tPort int\n}</pre>\n<p>\nTCPAddr represents the address of a TCP end point.\n</p>\n\n",name:"TCPAddr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TCPAddr\">func (*TCPAddr)</a> <a href=\"?m:TCPAddr.Network!\">Network</a></h2>\n<code>func (a *TCPAddr) Network() string</code>\n<p>\nNetwork returns the address&#39;s network name, &#34;tcp&#34;.\n</p>\n\n",name:"Network"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPAddr\">func (*TCPAddr)</a> <a href=\"?m:TCPAddr.String!\">String</a></h2>\n<code>func (a *TCPAddr) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPConn!\">TCPConn</a></h2>\n<pre>type TCPConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nTCPConn is an implementation of the Conn interface\nfor TCP network connections.\n</p>\n\n",name:"TCPConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Close!\">Close</a></h2>\n<code>func (c *TCPConn) Close() os.Error</code>\n<p>\nClose closes the TCP connection.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.File!\">File</a></h2>\n<code>func (c *TCPConn) File() (f *os.File, err os.Error)</code>\n<p>\nFile returns a copy of the underlying os.File, set to blocking mode.\nIt is the caller&#39;s responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n</p>\n\n",name:"File"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (c *TCPConn) LocalAddr() Addr</code>\n<p>\nLocalAddr returns the local network address, a *TCPAddr.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Read!\">Read</a></h2>\n<code>func (c *TCPConn) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead implements the net.Conn Read method.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (c *TCPConn) RemoteAddr() Addr</code>\n<p>\nRemoteAddr returns the remote network address, a *TCPAddr.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetKeepAlive!\">SetKeepAlive</a></h2>\n<code>func (c *TCPConn) SetKeepAlive(keepalive bool) os.Error</code>\n<p>\nSetKeepAlive sets whether the operating system should send\nkeepalive messages on the connection.\n</p>\n\n",name:"SetKeepAlive"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetLinger!\">SetLinger</a></h2>\n<code>func (c *TCPConn) SetLinger(sec int) os.Error</code>\n<p>\nSetLinger sets the behavior of Close() on a connection\nwhich still has data waiting to be sent or to be acknowledged.\n</p>\n<p>\nIf sec &lt; 0 (the default), Close returns immediately and\nthe operating system finishes sending the data in the background.\n</p>\n<p>\nIf sec == 0, Close returns immediately and the operating system\ndiscards any unsent or unacknowledged data.\n</p>\n<p>\nIf sec &gt; 0, Close blocks for at most sec seconds waiting for\ndata to be sent and acknowledged.\n</p>\n\n",name:"SetLinger"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetNoDelay!\">SetNoDelay</a></h2>\n<code>func (c *TCPConn) SetNoDelay(noDelay bool) os.Error</code>\n<p>\nSetNoDelay controls whether the operating system should delay\npacket transmission in hopes of sending fewer packets\n(Nagle&#39;s algorithm).  The default is true (no delay), meaning\nthat data is sent as soon as possible after a Write.\n</p>\n\n",name:"SetNoDelay"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\n<code>func (c *TCPConn) SetReadBuffer(bytes int) os.Error</code>\n<p>\nSetReadBuffer sets the size of the operating system&#39;s\nreceive buffer associated with the connection.\n</p>\n\n",name:"SetReadBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (c *TCPConn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout implements the net.Conn SetReadTimeout method.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (c *TCPConn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout implements the net.Conn SetTimeout method.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\n<code>func (c *TCPConn) SetWriteBuffer(bytes int) os.Error</code>\n<p>\nSetWriteBuffer sets the size of the operating system&#39;s\ntransmit buffer associated with the connection.\n</p>\n\n",name:"SetWriteBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (c *TCPConn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWriteTimeout implements the net.Conn SetWriteTimeout method.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPConn\">func (*TCPConn)</a> <a href=\"?m:TCPConn.Write!\">Write</a></h2>\n<code>func (c *TCPConn) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the net.Conn Write method.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TCPListener!\">TCPListener</a></h2>\n<pre>type TCPListener struct {\n\t// contains unexported fields\n}</pre>\n<p>\nTCPListener is a TCP network listener.\nClients should typically use variables of type Listener\ninstead of assuming TCP.\n</p>\n\n",name:"TCPListener","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Accept!\">Accept</a></h2>\n<code>func (l *TCPListener) Accept() (c Conn, err os.Error)</code>\n<p>\nAccept implements the Accept method in the Listener interface;\nit waits for the next call and returns a generic Conn.\n</p>\n\n",name:"Accept"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.AcceptTCP!\">AcceptTCP</a></h2>\n<code>func (l *TCPListener) AcceptTCP() (c *TCPConn, err os.Error)</code>\n<p>\nAcceptTCP accepts the next incoming call and returns the new connection\nand the remote address.\n</p>\n\n",name:"AcceptTCP"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Addr!\">Addr</a></h2>\n<code>func (l *TCPListener) Addr() Addr</code>\n<p>\nAddr returns the listener&#39;s network address, a *TCPAddr.\n</p>\n\n",name:"Addr"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.Close!\">Close</a></h2>\n<code>func (l *TCPListener) Close() os.Error</code>\n<p>\nClose stops listening on the TCP address.\nAlready Accepted connections are not closed.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:TCPListener\">func (*TCPListener)</a> <a href=\"?m:TCPListener.File!\">File</a></h2>\n<code>func (l *TCPListener) File() (f *os.File, err os.Error)</code>\n<p>\nFile returns a copy of the underlying os.File, set to blocking mode.\nIt is the caller&#39;s responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n</p>\n\n",name:"File"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UDPAddr!\">UDPAddr</a></h2>\n<pre>type UDPAddr struct {\n\tIP   IP\n\tPort int\n}</pre>\n<p>\nUDPAddr represents the address of a UDP end point.\n</p>\n\n",name:"UDPAddr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UDPAddr\">func (*UDPAddr)</a> <a href=\"?m:UDPAddr.Network!\">Network</a></h2>\n<code>func (a *UDPAddr) Network() string</code>\n<p>\nNetwork returns the address&#39;s network name, &#34;udp&#34;.\n</p>\n\n",name:"Network"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPAddr\">func (*UDPAddr)</a> <a href=\"?m:UDPAddr.String!\">String</a></h2>\n<code>func (a *UDPAddr) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UDPConn!\">UDPConn</a></h2>\n<pre>type UDPConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUDPConn is the implementation of the Conn and PacketConn\ninterfaces for UDP network connections.\n</p>\n\n",name:"UDPConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.BindToDevice!\">BindToDevice</a></h2>\n<code>func (c *UDPConn) BindToDevice(device string) os.Error</code>\n<p>\nBindToDevice binds a UDPConn to a network interface.\n</p>\n\n",name:"BindToDevice"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Close!\">Close</a></h2>\n<code>func (c *UDPConn) Close() os.Error</code>\n<p>\nClose closes the UDP connection.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.File!\">File</a></h2>\n<code>func (c *UDPConn) File() (f *os.File, err os.Error)</code>\n<p>\nFile returns a copy of the underlying os.File, set to blocking mode.\nIt is the caller&#39;s responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n</p>\n\n",name:"File"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.JoinGroup!\">JoinGroup</a></h2>\n<code>func (c *UDPConn) JoinGroup(addr IP) os.Error</code>\n<p>\nJoinGroup joins the IPv4 multicast group named by addr.\nThe UDPConn must use the &#34;udp4&#34; network.\n</p>\n\n",name:"JoinGroup"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.LeaveGroup!\">LeaveGroup</a></h2>\n<code>func (c *UDPConn) LeaveGroup(addr IP) os.Error</code>\n<p>\nLeaveGroup exits the IPv4 multicast group named by addr.\n</p>\n\n",name:"LeaveGroup"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (c *UDPConn) LocalAddr() Addr</code>\n<p>\nLocalAddr returns the local network address.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Read!\">Read</a></h2>\n<code>func (c *UDPConn) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead implements the net.Conn Read method.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.ReadFrom!\">ReadFrom</a></h2>\n<code>func (c *UDPConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\n<p>\nReadFrom implements the net.PacketConn ReadFrom method.\n</p>\n\n",name:"ReadFrom"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.ReadFromUDP!\">ReadFromUDP</a></h2>\n<code>func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err os.Error)</code>\n<p>\nReadFromUDP reads a UDP packet from c, copying the payload into b.\nIt returns the number of bytes copied into b and the return address\nthat was on the packet.\n</p>\n<p>\nReadFromUDP can be made to time out and return an error with Timeout() == true\nafter a fixed time limit; see SetTimeout and SetReadTimeout.\n</p>\n\n",name:"ReadFromUDP"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (c *UDPConn) RemoteAddr() Addr</code>\n<p>\nRemoteAddr returns the remote network address, a *UDPAddr.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetReadBuffer!\">SetReadBuffer</a></h2>\n<code>func (c *UDPConn) SetReadBuffer(bytes int) os.Error</code>\n<p>\nSetReadBuffer sets the size of the operating system&#39;s\nreceive buffer associated with the connection.\n</p>\n\n",name:"SetReadBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (c *UDPConn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout implements the net.Conn SetReadTimeout method.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (c *UDPConn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout implements the net.Conn SetTimeout method.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\n<code>func (c *UDPConn) SetWriteBuffer(bytes int) os.Error</code>\n<p>\nSetWriteBuffer sets the size of the operating system&#39;s\ntransmit buffer associated with the connection.\n</p>\n\n",name:"SetWriteBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (c *UDPConn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWriteTimeout implements the net.Conn SetWriteTimeout method.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.Write!\">Write</a></h2>\n<code>func (c *UDPConn) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the net.Conn Write method.\n</p>\n\n",name:"Write"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.WriteTo!\">WriteTo</a></h2>\n<code>func (c *UDPConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\n<p>\nWriteTo implements the net.PacketConn WriteTo method.\n</p>\n\n",name:"WriteTo"},{html:"\n<h2><a class=\"black\" href=\"?m:UDPConn\">func (*UDPConn)</a> <a href=\"?m:UDPConn.WriteToUDP!\">WriteToUDP</a></h2>\n<code>func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (n int, err os.Error)</code>\n<p>\nWriteToUDP writes a UDP packet to addr via c, copying the payload from b.\n</p>\n<p>\nWriteToUDP can be made to time out and return\nan error with Timeout() == true after a fixed time limit;\nsee SetTimeout and SetWriteTimeout.\nOn packet-oriented connections, write timeouts are rare.\n</p>\n\n",name:"WriteToUDP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixAddr!\">UnixAddr</a></h2>\n<pre>type UnixAddr struct {\n\tName string\n\tNet  string\n}</pre>\n<p>\nUnixAddr represents the address of a Unix domain socket end point.\n</p>\n\n",name:"UnixAddr","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnixAddr\">func (*UnixAddr)</a> <a href=\"?m:UnixAddr.Network!\">Network</a></h2>\n<code>func (a *UnixAddr) Network() string</code>\n<p>\nNetwork returns the address&#39;s network name, &#34;unix&#34; or &#34;unixgram&#34;.\n</p>\n\n",name:"Network"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixAddr\">func (*UnixAddr)</a> <a href=\"?m:UnixAddr.String!\">String</a></h2>\n<code>func (a *UnixAddr) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixConn!\">UnixConn</a></h2>\n<pre>type UnixConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUnixConn is an implementation of the Conn interface\nfor connections to Unix domain sockets.\n</p>\n\n",name:"UnixConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Close!\">Close</a></h2>\n<code>func (c *UnixConn) Close() os.Error</code>\n<p>\nClose closes the Unix domain connection.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.File!\">File</a></h2>\n<code>func (c *UnixConn) File() (f *os.File, err os.Error)</code>\n<p>\nFile returns a copy of the underlying os.File, set to blocking mode.\nIt is the caller&#39;s responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n</p>\n\n",name:"File"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.LocalAddr!\">LocalAddr</a></h2>\n<code>func (c *UnixConn) LocalAddr() Addr</code>\n<p>\nLocalAddr returns the local network address, a *UnixAddr.\nUnlike in other protocols, LocalAddr is usually nil for dialed connections.\n</p>\n\n",name:"LocalAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Read!\">Read</a></h2>\n<code>func (c *UnixConn) Read(b []byte) (n int, err os.Error)</code>\n<p>\nRead implements the net.Conn Read method.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.ReadFrom!\">ReadFrom</a></h2>\n<code>func (c *UnixConn) ReadFrom(b []byte) (n int, addr Addr, err os.Error)</code>\n<p>\nReadFrom implements the net.PacketConn ReadFrom method.\n</p>\n\n",name:"ReadFrom"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.ReadFromUnix!\">ReadFromUnix</a></h2>\n<code>func (c *UnixConn) ReadFromUnix(b []byte) (n int, addr *UnixAddr, err os.Error)</code>\n<p>\nReadFromUnix reads a packet from c, copying the payload into b.\nIt returns the number of bytes copied into b and the return address\nthat was on the packet.\n</p>\n<p>\nReadFromUnix can be made to time out and return\nan error with Timeout() == true after a fixed time limit;\nsee SetTimeout and SetReadTimeout.\n</p>\n\n",name:"ReadFromUnix"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.ReadMsgUnix!\">ReadMsgUnix</a></h2>\n<code>func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err os.Error)</code>\n\n",name:"ReadMsgUnix"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.RemoteAddr!\">RemoteAddr</a></h2>\n<code>func (c *UnixConn) RemoteAddr() Addr</code>\n<p>\nRemoteAddr returns the remote network address, a *UnixAddr.\nUnlike in other protocols, RemoteAddr is usually nil for connections\naccepted by a listener.\n</p>\n\n",name:"RemoteAddr"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetReadBuffer!\">SetReadBuffer</a></h2>\n<code>func (c *UnixConn) SetReadBuffer(bytes int) os.Error</code>\n<p>\nSetReadBuffer sets the size of the operating system&#39;s\nreceive buffer associated with the connection.\n</p>\n\n",name:"SetReadBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetReadTimeout!\">SetReadTimeout</a></h2>\n<code>func (c *UnixConn) SetReadTimeout(nsec int64) os.Error</code>\n<p>\nSetReadTimeout implements the net.Conn SetReadTimeout method.\n</p>\n\n",name:"SetReadTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetTimeout!\">SetTimeout</a></h2>\n<code>func (c *UnixConn) SetTimeout(nsec int64) os.Error</code>\n<p>\nSetTimeout implements the net.Conn SetTimeout method.\n</p>\n\n",name:"SetTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetWriteBuffer!\">SetWriteBuffer</a></h2>\n<code>func (c *UnixConn) SetWriteBuffer(bytes int) os.Error</code>\n<p>\nSetWriteBuffer sets the size of the operating system&#39;s\ntransmit buffer associated with the connection.\n</p>\n\n",name:"SetWriteBuffer"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.SetWriteTimeout!\">SetWriteTimeout</a></h2>\n<code>func (c *UnixConn) SetWriteTimeout(nsec int64) os.Error</code>\n<p>\nSetWriteTimeout implements the net.Conn SetWriteTimeout method.\n</p>\n\n",name:"SetWriteTimeout"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.Write!\">Write</a></h2>\n<code>func (c *UnixConn) Write(b []byte) (n int, err os.Error)</code>\n<p>\nWrite implements the net.Conn Write method.\n</p>\n\n",name:"Write"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.WriteMsgUnix!\">WriteMsgUnix</a></h2>\n<code>func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err os.Error)</code>\n\n",name:"WriteMsgUnix"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.WriteTo!\">WriteTo</a></h2>\n<code>func (c *UnixConn) WriteTo(b []byte, addr Addr) (n int, err os.Error)</code>\n<p>\nWriteTo implements the net.PacketConn WriteTo method.\n</p>\n\n",name:"WriteTo"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixConn\">func (*UnixConn)</a> <a href=\"?m:UnixConn.WriteToUnix!\">WriteToUnix</a></h2>\n<code>func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (n int, err os.Error)</code>\n<p>\nWriteToUnix writes a packet to addr via c, copying the payload from b.\n</p>\n<p>\nWriteToUnix can be made to time out and return\nan error with Timeout() == true after a fixed time limit;\nsee SetTimeout and SetWriteTimeout.\nOn packet-oriented connections, write timeouts are rare.\n</p>\n\n",name:"WriteToUnix"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnixListener!\">UnixListener</a></h2>\n<pre>type UnixListener struct {\n\t// contains unexported fields\n}</pre>\n<p>\nUnixListener is a Unix domain socket listener.\nClients should typically use variables of type Listener\ninstead of assuming Unix domain sockets.\n</p>\n\n",name:"UnixListener","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Accept!\">Accept</a></h2>\n<code>func (l *UnixListener) Accept() (c Conn, err os.Error)</code>\n<p>\nAccept implements the Accept method in the Listener interface;\nit waits for the next call and returns a generic Conn.\n</p>\n\n",name:"Accept"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.AcceptUnix!\">AcceptUnix</a></h2>\n<code>func (l *UnixListener) AcceptUnix() (c *UnixConn, err os.Error)</code>\n<p>\nAcceptUnix accepts the next incoming call and returns the new connection\nand the remote address.\n</p>\n\n",name:"AcceptUnix"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Addr!\">Addr</a></h2>\n<code>func (l *UnixListener) Addr() Addr</code>\n<p>\nAddr returns the listener&#39;s network address.\n</p>\n\n",name:"Addr"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.Close!\">Close</a></h2>\n<code>func (l *UnixListener) Close() os.Error</code>\n<p>\nClose stops listening on the Unix address.\nAlready accepted connections are not closed.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:UnixListener\">func (*UnixListener)</a> <a href=\"?m:UnixListener.File!\">File</a></h2>\n<code>func (l *UnixListener) File() (f *os.File, err os.Error)</code>\n<p>\nFile returns a copy of the underlying os.File, set to blocking mode.\nIt is the caller&#39;s responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n</p>\n\n",name:"File"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownNetworkError!\">UnknownNetworkError</a></h2>\n<pre>type UnknownNetworkError string</pre>\n\n",name:"UnknownNetworkError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.String!\">String</a></h2>\n<code>func (e UnknownNetworkError) String() string</code>\n\n",name:"String"},{html:"\n<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.Temporary!\">Temporary</a></h2>\n<code>func (e UnknownNetworkError) Temporary() bool</code>\n\n",name:"Temporary"},{html:"\n<h2><a class=\"black\" href=\"?m:UnknownNetworkError\">func (UnknownNetworkError)</a> <a href=\"?m:UnknownNetworkError.Timeout!\">Timeout</a></h2>\n<code>func (e UnknownNetworkError) Timeout() bool</code>\n\n",name:"Timeout"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownSocketError!\">UnknownSocketError</a></h2>\n<pre>type UnknownSocketError struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"UnknownSocketError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnknownSocketError\">func (*UnknownSocketError)</a> <a href=\"?m:UnknownSocketError.String!\">String</a></h2>\n<code>func (e *UnknownSocketError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\n<code>func Dial(net, addr string) (c Conn, err os.Error)</code>\n<p>\nDial connects to the address addr on the network net.\n</p>\n<p>\nKnown networks are &#34;tcp&#34;, &#34;tcp4&#34; (IPv4-only), &#34;tcp6&#34; (IPv6-only),\n&#34;udp&#34;, &#34;udp4&#34; (IPv4-only), &#34;udp6&#34; (IPv6-only), &#34;ip&#34;, &#34;ip4&#34;\n(IPv4-only), &#34;ip6&#34; (IPv6-only), &#34;unix&#34; and &#34;unixgram&#34;.\n</p>\n<p>\nFor IP networks, addresses have the form host:port.  If host is\na literal IPv6 address, it must be enclosed in square brackets.\nThe functions JoinHostPort and SplitHostPort manipulate\naddresses in this form.\n</p>\n<p>\nExamples:\n</p>\n<pre>Dial(&#34;tcp&#34;, &#34;12.34.56.78:80&#34;)\nDial(&#34;tcp&#34;, &#34;google.com:80&#34;)\nDial(&#34;tcp&#34;, &#34;[de:ad:be:ef::ca:fe]:80&#34;)\n</pre>\n\n",name:"Dial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialIP!\">DialIP</a></h2>\n<code>func DialIP(netProto string, laddr, raddr *IPAddr) (c *IPConn, err os.Error)</code>\n<p>\nDialIP connects to the remote address raddr on the network net,\nwhich must be &#34;ip&#34;, &#34;ip4&#34;, or &#34;ip6&#34;.\n</p>\n\n",name:"DialIP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialTCP!\">DialTCP</a></h2>\n<code>func DialTCP(net string, laddr, raddr *TCPAddr) (c *TCPConn, err os.Error)</code>\n<p>\nDialTCP connects to the remote address raddr on the network net,\nwhich must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.  If laddr is not nil, it is used\nas the local address for the connection.\n</p>\n\n",name:"DialTCP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialUDP!\">DialUDP</a></h2>\n<code>func DialUDP(net string, laddr, raddr *UDPAddr) (c *UDPConn, err os.Error)</code>\n<p>\nDialUDP connects to the remote address raddr on the network net,\nwhich must be &#34;udp&#34;, &#34;udp4&#34;, or &#34;udp6&#34;.  If laddr is not nil, it is used\nas the local address for the connection.\n</p>\n\n",name:"DialUDP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DialUnix!\">DialUnix</a></h2>\n<code>func DialUnix(net string, laddr, raddr *UnixAddr) (c *UnixConn, err os.Error)</code>\n<p>\nDialUnix connects to the remote address raddr on the network net,\nwhich must be &#34;unix&#34; or &#34;unixgram&#34;.  If laddr is not nil, it is used\nas the local address for the connection.\n</p>\n\n",name:"DialUnix"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileConn!\">FileConn</a></h2>\n<code>func FileConn(f *os.File) (c Conn, err os.Error)</code>\n<p>\nFileConn returns a copy of the network connection corresponding to\nthe open file f.  It is the caller&#39;s responsibility to close f when\nfinished.  Closing c does not affect f, and closing f does not\naffect c.\n</p>\n\n",name:"FileConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileListener!\">FileListener</a></h2>\n<code>func FileListener(f *os.File) (l Listener, err os.Error)</code>\n<p>\nFileListener returns a copy of the network listener corresponding\nto the open file f.  It is the caller&#39;s responsibility to close l\nwhen finished.  Closing c does not affect l, and closing l does not\naffect c.\n</p>\n\n",name:"FileListener"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FilePacketConn!\">FilePacketConn</a></h2>\n<code>func FilePacketConn(f *os.File) (c PacketConn, err os.Error)</code>\n<p>\nFilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.  It is the caller&#39;s\nresponsibility to close f when finished.  Closing c does not affect\nf, and closing f does not affect c.\n</p>\n\n",name:"FilePacketConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IPv4!\">IPv4</a></h2>\n<code>func IPv4(a, b, c, d byte) IP</code>\n<p>\nIPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n</p>\n\n",name:"IPv4"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:IPv4Mask!\">IPv4Mask</a></h2>\n<code>func IPv4Mask(a, b, c, d byte) IPMask</code>\n<p>\nIPv4Mask returns the IP mask (in 16-byte form) of the\nIPv4 mask a.b.c.d.\n</p>\n\n",name:"IPv4Mask"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:JoinHostPort!\">JoinHostPort</a></h2>\n<code>func JoinHostPort(host, port string) string</code>\n<p>\nJoinHostPort combines host and port into a network address\nof the form &#34;host:port&#34; or, if host contains a colon, &#34;[host]:port&#34;.\n</p>\n\n",name:"JoinHostPort"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Listen!\">Listen</a></h2>\n<code>func Listen(net, laddr string) (l Listener, err os.Error)</code>\n<p>\nListen announces on the local network address laddr.\nThe network string net must be a stream-oriented\nnetwork: &#34;tcp&#34;, &#34;tcp4&#34;, &#34;tcp6&#34;, or &#34;unix&#34;, or &#34;unixpacket&#34;.\n</p>\n\n",name:"Listen"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenIP!\">ListenIP</a></h2>\n<code>func ListenIP(netProto string, laddr *IPAddr) (c *IPConn, err os.Error)</code>\n<p>\nListenIP listens for incoming IP packets addressed to the\nlocal address laddr.  The returned connection c&#39;s ReadFrom\nand WriteTo methods can be used to receive and send IP\npackets with per-packet addressing.\n</p>\n\n",name:"ListenIP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenPacket!\">ListenPacket</a></h2>\n<code>func ListenPacket(net, laddr string) (c PacketConn, err os.Error)</code>\n<p>\nListenPacket announces on the local network address laddr.\nThe network string net must be a packet-oriented network:\n&#34;udp&#34;, &#34;udp4&#34;, &#34;udp6&#34;, or &#34;unixgram&#34;.\n</p>\n\n",name:"ListenPacket"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenTCP!\">ListenTCP</a></h2>\n<code>func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err os.Error)</code>\n<p>\nListenTCP announces on the TCP address laddr and returns a TCP listener.\nNet must be &#34;tcp&#34;, &#34;tcp4&#34;, or &#34;tcp6&#34;.\nIf laddr has a port of 0, it means to listen on some available port.\nThe caller can use l.Addr() to retrieve the chosen address.\n</p>\n\n",name:"ListenTCP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUDP!\">ListenUDP</a></h2>\n<code>func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err os.Error)</code>\n<p>\nListenUDP listens for incoming UDP packets addressed to the\nlocal address laddr.  The returned connection c&#39;s ReadFrom\nand WriteTo methods can be used to receive and send UDP\npackets with per-packet addressing.\n</p>\n\n",name:"ListenUDP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUnix!\">ListenUnix</a></h2>\n<code>func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err os.Error)</code>\n<p>\nListenUnix announces on the Unix domain socket laddr and returns a Unix listener.\nNet must be &#34;unix&#34; (stream sockets).\n</p>\n\n",name:"ListenUnix"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenUnixgram!\">ListenUnixgram</a></h2>\n<code>func ListenUnixgram(net string, laddr *UnixAddr) (c *UDPConn, err os.Error)</code>\n<p>\nListenUnixgram listens for incoming Unix datagram packets addressed to the\nlocal address laddr.  The returned connection c&#39;s ReadFrom\nand WriteTo methods can be used to receive and send UDP\npackets with per-packet addressing.  The network net must be &#34;unixgram&#34;.\n</p>\n\n",name:"ListenUnixgram"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupAddr!\">LookupAddr</a></h2>\n<code>func LookupAddr(addr string) (name []string, err os.Error)</code>\n<p>\nLookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n</p>\n\n",name:"LookupAddr"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupCNAME!\">LookupCNAME</a></h2>\n<code>func LookupCNAME(name string) (cname string, err os.Error)</code>\n<p>\nLookupCNAME returns the canonical DNS host for the given name.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n</p>\n\n",name:"LookupCNAME"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupHost!\">LookupHost</a></h2>\n<code>func LookupHost(host string) (addrs []string, err os.Error)</code>\n<p>\nLookupHost looks up the given host using the local resolver.\nIt returns an array of that host&#39;s addresses.\n</p>\n\n",name:"LookupHost"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupIP!\">LookupIP</a></h2>\n<code>func LookupIP(host string) (addrs []IP, err os.Error)</code>\n<p>\nLookupIP looks up host using the local resolver.\nIt returns an array of that host&#39;s IPv4 and IPv6 addresses.\n</p>\n\n",name:"LookupIP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupMX!\">LookupMX</a></h2>\n<code>func LookupMX(name string) (mx []*MX, err os.Error)</code>\n<p>\nLookupMX returns the DNS MX records for the given domain name sorted by preference.\n</p>\n\n",name:"LookupMX"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupPort!\">LookupPort</a></h2>\n<code>func LookupPort(network, service string) (port int, err os.Error)</code>\n<p>\nLookupPort looks up the port for the given network and service.\n</p>\n\n",name:"LookupPort"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookupSRV!\">LookupSRV</a></h2>\n<code>func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err os.Error)</code>\n<p>\nLookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name, as specified in RFC 2782. In most cases\nthe proto argument can be the same as the corresponding\nAddr.Network().\n</p>\n\n",name:"LookupSRV"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseCIDR!\">ParseCIDR</a></h2>\n<code>func ParseCIDR(s string) (ip IP, mask IPMask, err os.Error)</code>\n<p>\nParseCIDR parses s as a CIDR notation IP address and mask,\nlike &#34;192.168.100.1/24&#34;, &#34;2001:DB8::/48&#34;, as defined in\nRFC 4632 and RFC 4291.\n</p>\n\n",name:"ParseCIDR"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseIP!\">ParseIP</a></h2>\n<code>func ParseIP(s string) IP</code>\n<p>\nParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (&#34;74.125.19.99&#34;)\nor IPv6 (&#34;2001:4860:0:2001::68&#34;) form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n</p>\n\n",name:"ParseIP"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Pipe!\">Pipe</a></h2>\n<code>func Pipe() (Conn, Conn)</code>\n<p>\nPipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n</p>\n\n",name:"Pipe"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveIPAddr!\">ResolveIPAddr</a></h2>\n<code>func ResolveIPAddr(addr string) (*IPAddr, os.Error)</code>\n<p>\nResolveIPAddr parses addr as a IP address and resolves domain\nnames to numeric addresses.  A literal IPv6 host address must be\nenclosed in square brackets, as in &#34;[::]&#34;.\n</p>\n\n",name:"ResolveIPAddr"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveTCPAddr!\">ResolveTCPAddr</a></h2>\n<code>func ResolveTCPAddr(addr string) (*TCPAddr, os.Error)</code>\n<p>\nResolveTCPAddr parses addr as a TCP address of the form\nhost:port and resolves domain names or port names to\nnumeric addresses.  A literal IPv6 host address must be\nenclosed in square brackets, as in &#34;[::]:80&#34;.\n</p>\n\n",name:"ResolveTCPAddr"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveUDPAddr!\">ResolveUDPAddr</a></h2>\n<code>func ResolveUDPAddr(addr string) (*UDPAddr, os.Error)</code>\n<p>\nResolveUDPAddr parses addr as a UDP address of the form\nhost:port and resolves domain names or port names to\nnumeric addresses.  A literal IPv6 host address must be\nenclosed in square brackets, as in &#34;[::]:80&#34;.\n</p>\n\n",name:"ResolveUDPAddr"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ResolveUnixAddr!\">ResolveUnixAddr</a></h2>\n<code>func ResolveUnixAddr(net, addr string) (*UnixAddr, os.Error)</code>\n<p>\nResolveUnixAddr parses addr as a Unix domain socket address.\nThe string net gives the network name, &#34;unix&#34;, &#34;unixgram&#34; or\n&#34;unixpacket&#34;.\n</p>\n\n",name:"ResolveUnixAddr"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SplitHostPort!\">SplitHostPort</a></h2>\n<code>func SplitHostPort(hostport string) (host, port string, err os.Error)</code>\n<p>\nSplitHostPort splits a network address of the form\n&#34;host:port&#34; or &#34;[host]:port&#34; into host and port.\nThe latter form must be used when host contains a colon.\n</p>\n\n",name:"SplitHostPort"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:IPv4len!\"><em>group</em></a></h2>\n<pre>const (\n\tIPv4len = 4\n\tIPv6len = 16\n)</pre>\n<p>\nIP address lengths (bytes).\n</p>\n\n",names:["IPv4len","IPv6len"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:IPv4bcast!\"><em>group</em></a></h2>\n<pre>var (\n\tIPv4bcast     = IPv4(255, 255, 255, 255) // broadcast\n\tIPv4allsys    = IPv4(224, 0, 0, 1)       // all systems\n\tIPv4allrouter = IPv4(224, 0, 0, 2)       // all routers\n\tIPv4zero      = IPv4(0, 0, 0, 0)         // all zeros\n)</pre>\n<p>\nWell-known IPv4 addresses\n</p>\n\n",names:["IPv4bcast","IPv4allsys","IPv4allrouter","IPv4zero"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:IPzero!\">IPzero</a></h2>\n<pre>var (\n\tIPzero = make(IP, IPv6len) // all zeros\n)</pre>\n<p>\nWell-known IPv6 addresses\n</p>\n\n",names:["IPzero"],type:""}]}