var gortfmData = {index:"index.html",html:"<p>\nThe testing package provides support for automated testing of Go packages.\nIt is intended to be used in concert with the &ldquo;gotest&rdquo; utility, which automates\nexecution of any function of the form\n</p>\n<pre>func TestXxx(*testing.T)\n</pre>\n<p>\nwhere Xxx can be any alphanumeric string (but the first letter must not be in\n[a-z]) and serves to identify the test routine.\nThese TestXxx routines should be declared within the package they are testing.\n</p>\n<p>\nFunctions of the form\n</p>\n<pre>func BenchmarkXxx(*testing.B)\n</pre>\n<p>\nare considered benchmarks, and are executed by gotest when the -benchmarks\nflag is provided.\n</p>\n<p>\nA sample benchmark function looks like this:\n</p>\n<pre>func BenchmarkHello(b *testing.B) {\n    for i := 0; i &lt; b.N; i++ {\n        fmt.Sprintf(&#34;hello&#34;)\n    }\n}\n</pre>\n<p>\nThe benchmark package will vary b.N until the benchmark function lasts\nlong enough to be timed reliably.  The output\n</p>\n<pre>testing.BenchmarkHello\t500000\t      4076 ns/op\n</pre>\n<p>\nmeans that the loop ran 500000 times at a speed of 4076 ns per loop.\n</p>\n<p>\nIf a benchmark needs some expensive setup before running, the timer\nmay be stopped:\n</p>\n<pre>func BenchmarkBigLen(b *testing.B) {\n    b.StopTimer()\n    big := NewBig()\n    b.StartTimer()\n    for i := 0; i &lt; b.N; i++ {\n        big.Len()\n    }\n}\n</pre>\n",name:"testing",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:B!\">B</a></h2>\n<pre>type B struct {\n\tN int\n\t// contains unexported fields\n}</pre>\n<p>\nB is a type passed to Benchmark functions to manage benchmark\ntiming and to specify the number of iterations to run.\n</p>\n\n",name:"B","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.ResetTimer!\">ResetTimer</a></h2>\n<code>func (b *B) ResetTimer()</code>\n<p>\nResetTimer stops the timer and sets the elapsed benchmark time to zero.\n</p>\n\n",name:"ResetTimer"},{html:"\n<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.SetBytes!\">SetBytes</a></h2>\n<code>func (b *B) SetBytes(n int64)</code>\n<p>\nSetBytes records the number of bytes processed in a single operation.\nIf this is called, the benchmark will report ns/op and MB/s.\n</p>\n\n",name:"SetBytes"},{html:"\n<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.StartTimer!\">StartTimer</a></h2>\n<code>func (b *B) StartTimer()</code>\n<p>\nStartTimer starts timing a test.  This function is called automatically\nbefore a benchmark starts, but it can also used to resume timing after\na call to StopTimer.\n</p>\n\n",name:"StartTimer"},{html:"\n<h2><a class=\"black\" href=\"?m:B\">func (*B)</a> <a href=\"?m:B.StopTimer!\">StopTimer</a></h2>\n<code>func (b *B) StopTimer()</code>\n<p>\nStopTimer stops timing a test.  This can be used to pause the timer\nwhile performing complex initialization that you don&#39;t\nwant to measure.\n</p>\n\n",name:"StopTimer"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BenchmarkResult!\">BenchmarkResult</a></h2>\n<pre>type BenchmarkResult struct {\n\tN     int   // The number of iterations.\n\tNs    int64 // The total time taken.\n\tBytes int64 // The total number of bytes processed.\n}</pre>\n<p>\nThe results of a benchmark run.\n</p>\n\n",name:"BenchmarkResult","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BenchmarkResult\">func (BenchmarkResult)</a> <a href=\"?m:BenchmarkResult.NsPerOp!\">NsPerOp</a></h2>\n<code>func (r BenchmarkResult) NsPerOp() int64</code>\n\n",name:"NsPerOp"},{html:"\n<h2><a class=\"black\" href=\"?m:BenchmarkResult\">func (BenchmarkResult)</a> <a href=\"?m:BenchmarkResult.String!\">String</a></h2>\n<code>func (r BenchmarkResult) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InternalBenchmark!\">InternalBenchmark</a></h2>\n<pre>type InternalBenchmark struct {\n\tName string\n\tF    func(b *B)\n}</pre>\n<p>\nAn internal type but exported because it is cross-package; part of the implementation\nof gotest.\n</p>\n\n",name:"InternalBenchmark","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InternalTest!\">InternalTest</a></h2>\n<pre>type InternalTest struct {\n\tName string\n\tF    func(*T)\n}</pre>\n<p>\nAn internal type but exported because it is cross-package; part of the implementation\nof gotest.\n</p>\n\n",name:"InternalTest","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:T!\">T</a></h2>\n<pre>type T struct {\n\t// contains unexported fields\n}</pre>\n<p>\nT is a type passed to Test functions to manage test state and support formatted test logs.\nLogs are accumulated during execution and dumped to standard error when done.\n</p>\n\n",name:"T","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Error!\">Error</a></h2>\n<code>func (t *T) Error(args ...interface{})</code>\n<p>\nError is equivalent to Log() followed by Fail().\n</p>\n\n",name:"Error"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Errorf!\">Errorf</a></h2>\n<code>func (t *T) Errorf(format string, args ...interface{})</code>\n<p>\nErrorf is equivalent to Logf() followed by Fail().\n</p>\n\n",name:"Errorf"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fail!\">Fail</a></h2>\n<code>func (t *T) Fail()</code>\n<p>\nFail marks the Test function as having failed but continues execution.\n</p>\n\n",name:"Fail"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.FailNow!\">FailNow</a></h2>\n<code>func (t *T) FailNow()</code>\n<p>\nFailNow marks the Test function as having failed and stops its execution.\nExecution will continue at the next Test.\n</p>\n\n",name:"FailNow"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Failed!\">Failed</a></h2>\n<code>func (t *T) Failed() bool</code>\n<p>\nFailed returns whether the Test function has failed.\n</p>\n\n",name:"Failed"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fatal!\">Fatal</a></h2>\n<code>func (t *T) Fatal(args ...interface{})</code>\n<p>\nFatal is equivalent to Log() followed by FailNow().\n</p>\n\n",name:"Fatal"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Fatalf!\">Fatalf</a></h2>\n<code>func (t *T) Fatalf(format string, args ...interface{})</code>\n<p>\nFatalf is equivalent to Logf() followed by FailNow().\n</p>\n\n",name:"Fatalf"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Log!\">Log</a></h2>\n<code>func (t *T) Log(args ...interface{})</code>\n<p>\nLog formats its arguments using default formatting, analogous to Print(),\nand records the text in the error log.\n</p>\n\n",name:"Log"},{html:"\n<h2><a class=\"black\" href=\"?m:T\">func (*T)</a> <a href=\"?m:T.Logf!\">Logf</a></h2>\n<code>func (t *T) Logf(format string, args ...interface{})</code>\n<p>\nLog formats its arguments according to the format, analogous to Printf(),\nand records the text in the error log.\n</p>\n\n",name:"Logf"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Benchmark!\">Benchmark</a></h2>\n<code>func Benchmark(f func(b *B)) BenchmarkResult</code>\n<p>\nBenchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use gotest.\n</p>\n\n",name:"Benchmark"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Main!\">Main</a></h2>\n<code>func Main(matchString func(pat, str string) (bool, os.Error), tests []InternalTest)</code>\n<p>\nAn internal function but exported because it is cross-package; part of the implementation\nof gotest.\n</p>\n\n",name:"Main"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RunBenchmarks!\">RunBenchmarks</a></h2>\n<code>func RunBenchmarks(matchString func(pat, str string) (bool, os.Error), benchmarks []InternalBenchmark)</code>\n<p>\nAn internal function but exported because it is cross-package; part of the implementation\nof gotest.\n</p>\n\n",name:"RunBenchmarks"}],consts:[],vars:[]}