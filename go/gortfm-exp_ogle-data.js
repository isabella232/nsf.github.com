var gortfmData = {index:"index.html",html:"<p>\nPackage ogle is the beginning of a debugger for Go.\n</p>\n",name:"ogle",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Arch!\">Arch</a></h2>\n<pre>type Arch interface {\n\t// ToWord converts an array of up to 8 bytes in memory order\n\t// to a word.\n\tToWord(data []byte) proc.Word\n\t// FromWord converts a word to an array of up to 8 bytes in\n\t// memory order.\n\tFromWord(v proc.Word, out []byte)\n\t// ToFloat32 converts a word to a float.  The order of this\n\t// word will be the order returned by ToWord on the memory\n\t// representation of a float, and thus may require reversing.\n\tToFloat32(bits uint32) float32\n\t// FromFloat32 converts a float to a word.  This should return\n\t// a word that can be passed to FromWord to get the memory\n\t// representation of a float on this architecture.\n\tFromFloat32(f float32) uint32\n\t// ToFloat64 is to float64 as ToFloat32 is to float32.\n\tToFloat64(bits uint64) float64\n\t// FromFloat64 is to float64 as FromFloat32 is to float32.\n\tFromFloat64(f float64) uint64\n\n\t// IntSize returns the number of bytes in an &#39;int&#39;.\n\tIntSize() int\n\t// PtrSize returns the number of bytes in a &#39;uintptr&#39;.\n\tPtrSize() int\n\t// FloatSize returns the number of bytes in a &#39;float&#39;.\n\tFloatSize() int\n\t// Align rounds offset up to the appropriate offset for a\n\t// basic type with the given width.\n\tAlign(offset, width int) int\n\n\t// G returns the current G pointer.\n\tG(regs proc.Regs) proc.Word\n\n\t// ClosureSize returns the number of bytes expected by\n\t// ParseClosure.\n\tClosureSize() int\n\t// ParseClosure takes ClosureSize bytes read from a return PC\n\t// in a remote process, determines if the code is a closure,\n\t// and returns the frame size of the closure if it is.\n\tParseClosure(data []byte) (frame int, ok bool)\n}</pre>\n\n",name:"Arch","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArchAlignedMultiple!\">ArchAlignedMultiple</a></h2>\n<pre>type ArchAlignedMultiple struct{}</pre>\n\n",name:"ArchAlignedMultiple","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ArchAlignedMultiple\">func (ArchAlignedMultiple)</a> <a href=\"?m:ArchAlignedMultiple.Align!\">Align</a></h2>\n<code>func (ArchAlignedMultiple) Align(offset, width int) int</code>\n\n",name:"Align"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ArchLSB!\">ArchLSB</a></h2>\n<pre>type ArchLSB struct{}</pre>\n\n",name:"ArchLSB","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromFloat32!\">FromFloat32</a></h2>\n<code>func (ArchLSB) FromFloat32(f float32) uint32</code>\n\n",name:"FromFloat32"},{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromFloat64!\">FromFloat64</a></h2>\n<code>func (ArchLSB) FromFloat64(f float64) uint64</code>\n\n",name:"FromFloat64"},{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.FromWord!\">FromWord</a></h2>\n<code>func (ArchLSB) FromWord(v proc.Word, out []byte)</code>\n\n",name:"FromWord"},{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToFloat32!\">ToFloat32</a></h2>\n<code>func (ArchLSB) ToFloat32(bits uint32) float32</code>\n\n",name:"ToFloat32"},{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToFloat64!\">ToFloat64</a></h2>\n<code>func (ArchLSB) ToFloat64(bits uint64) float64</code>\n\n",name:"ToFloat64"},{html:"\n<h2><a class=\"black\" href=\"?m:ArchLSB\">func (ArchLSB)</a> <a href=\"?m:ArchLSB.ToWord!\">ToWord</a></h2>\n<code>func (ArchLSB) ToWord(data []byte) proc.Word</code>\n\n",name:"ToWord"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Breakpoint!\">Breakpoint</a></h2>\n<pre>type Breakpoint struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Breakpoint event occurs when a process reaches a particular\nprogram counter.  When this event is handled, the current goroutine\nwill be the goroutine that reached the program counter.\n</p>\n\n",name:"Breakpoint","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Breakpoint\">func (*Breakpoint)</a> <a href=\"?m:Breakpoint.PC!\">PC</a></h2>\n<code>func (b *Breakpoint) PC() proc.Word</code>\n\n",name:"PC"},{html:"\n<h2><a class=\"black\" href=\"?m:Breakpoint\">func (*Breakpoint)</a> <a href=\"?m:Breakpoint.String!\">String</a></h2>\n<code>func (b *Breakpoint) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Event!\">Event</a></h2>\n<pre>type Event interface {\n\tProcess() *Process\n\tGoroutine() *Goroutine\n\tString() string\n}</pre>\n\n",name:"Event","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventAction!\">EventAction</a></h2>\n<pre>type EventAction int</pre>\n<p>\nAn EventAction is an event handler&#39;s response to an event.  If all\nof an event&#39;s handlers execute without returning errors, their\nresults are combined as follows: If any handler returned\nEAContinue, then the process resumes (without returning from\nWaitStop); otherwise, if any handler returned EAStop, the process\nremains stopped; otherwise, if all handlers returned EADefault, the\nprocess resumes.  A handler may return EARemoveSelf bit-wise or&#39;d\nwith any other action to indicate that the handler should be\nremoved from the hook.\n</p>\n\n",name:"EventAction","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventHandler!\">EventHandler</a></h2>\n<pre>type EventHandler func(e Event) (EventAction, os.Error)</pre>\n<p>\nAn EventHandler is a function that takes an event and returns a\nresponse to that event and possibly an error.  If an event handler\nreturns an error, the process stops and no other handlers for that\nevent are executed.\n</p>\n\n",name:"EventHandler","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:EventHook!\">EventHook</a></h2>\n<pre>type EventHook interface {\n\tAddHandler(EventHandler)\n\tRemoveHandler(EventHandler)\n\tNumHandler() int\n\n\tString() string\n\t// contains unexported methods\n}</pre>\n<p>\nA EventHook allows event handlers to be added and removed.\n</p>\n\n",name:"EventHook","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatError!\">FormatError</a></h2>\n<pre>type FormatError string</pre>\n<p>\nA FormatError indicates a failure to process information in or\nabout a remote process, such as unexpected or missing information\nin the object file or runtime structures.\n</p>\n\n",name:"FormatError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FormatError\">func (FormatError)</a> <a href=\"?m:FormatError.String!\">String</a></h2>\n<code>func (e FormatError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Frame!\">Frame</a></h2>\n<pre>type Frame struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Frame represents a single frame on a remote call stack.\n</p>\n\n",name:"Frame","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.Inner!\">Inner</a></h2>\n<code>func (f *Frame) Inner() *Frame</code>\n<p>\nInner returns the Frame called by this Frame, or nil if this is the\ninnermost frame.\n</p>\n\n",name:"Inner"},{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.Outer!\">Outer</a></h2>\n<code>func (f *Frame) Outer() (*Frame, os.Error)</code>\n<p>\nOuter returns the Frame that called this Frame, or nil if this is\nthe outermost frame.\n</p>\n\n",name:"Outer"},{html:"\n<h2><a class=\"black\" href=\"?m:Frame\">func (*Frame)</a> <a href=\"?m:Frame.String!\">String</a></h2>\n<code>func (f *Frame) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Goroutine!\">Goroutine</a></h2>\n<pre>type Goroutine struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Goroutine represents a goroutine in a remote process.\n</p>\n\n",name:"Goroutine","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.In!\">In</a></h2>\n<code>func (t *Goroutine) In() os.Error</code>\n<p>\nIn selects the frame called by the current frame.\n</p>\n\n",name:"In"},{html:"\n<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.Out!\">Out</a></h2>\n<code>func (t *Goroutine) Out() os.Error</code>\n<p>\nOut selects the caller frame of the current frame.\n</p>\n\n",name:"Out"},{html:"\n<h2><a class=\"black\" href=\"?m:Goroutine\">func (*Goroutine)</a> <a href=\"?m:Goroutine.String!\">String</a></h2>\n<code>func (t *Goroutine) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoroutineCreate!\">GoroutineCreate</a></h2>\n<pre>type GoroutineCreate struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA GoroutineCreate event occurs when a process creates a new\ngoroutine.  When this event is handled, the current goroutine will\nbe the newly created goroutine.\n</p>\n\n",name:"GoroutineCreate","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:GoroutineCreate\">func (*GoroutineCreate)</a> <a href=\"?m:GoroutineCreate.Parent!\">Parent</a></h2>\n<code>func (e *GoroutineCreate) Parent() *Goroutine</code>\n<p>\nParent returns the goroutine that created this goroutine.  May be\nnil if this event is the creation of the first goroutine.\n</p>\n\n",name:"Parent"},{html:"\n<h2><a class=\"black\" href=\"?m:GoroutineCreate\">func (*GoroutineCreate)</a> <a href=\"?m:GoroutineCreate.String!\">String</a></h2>\n<code>func (e *GoroutineCreate) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GoroutineExit!\">GoroutineExit</a></h2>\n<pre>type GoroutineExit struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA GoroutineExit event occurs when a Go goroutine exits.\n</p>\n\n",name:"GoroutineExit","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:GoroutineExit\">func (*GoroutineExit)</a> <a href=\"?m:GoroutineExit.String!\">String</a></h2>\n<code>func (e *GoroutineExit) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NoCurrentGoroutine!\">NoCurrentGoroutine</a></h2>\n<pre>type NoCurrentGoroutine struct{}</pre>\n<p>\nA NoCurrentGoroutine error occurs when no goroutine is currently\nselected in a process (or when there are no goroutines in a\nprocess).\n</p>\n\n",name:"NoCurrentGoroutine","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NoCurrentGoroutine\">func (NoCurrentGoroutine)</a> <a href=\"?m:NoCurrentGoroutine.String!\">String</a></h2>\n<code>func (e NoCurrentGoroutine) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:NotOnStack!\">NotOnStack</a></h2>\n<pre>type NotOnStack struct {\n\tFn        *gosym.Func\n\tGoroutine *Goroutine\n}</pre>\n<p>\nA NotOnStack error occurs when attempting to access a variable in a\nremote frame where that remote frame is not on the current stack.\n</p>\n\n",name:"NotOnStack","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:NotOnStack\">func (NotOnStack)</a> <a href=\"?m:NotOnStack.String!\">String</a></h2>\n<code>func (e NotOnStack) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Process!\">Process</a></h2>\n<pre>type Process struct {\n\tArch\n\t// contains unexported fields\n}</pre>\n<p>\nA Process represents a remote attached process.\n</p>\n\n",name:"Process","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.ContWait!\">ContWait</a></h2>\n<code>func (p *Process) ContWait() os.Error</code>\n<p>\nContWait resumes process execution and waits for an event to occur\nthat stops the process.\n</p>\n\n",name:"ContWait"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Event!\">Event</a></h2>\n<code>func (p *Process) Event() Event</code>\n<p>\nEvent returns the last event that caused the process to stop.  This\nmay return nil if the process has never been stopped by an event.\n</p>\n<p>\nTODO(austin) Return nil if the user calls p.Stop()?\n</p>\n\n",name:"Event"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.In!\">In</a></h2>\n<code>func (p *Process) In() os.Error</code>\n<p>\nIn selects the frame called by the current frame.\n</p>\n\n",name:"In"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnBreakpoint!\">OnBreakpoint</a></h2>\n<code>func (p *Process) OnBreakpoint(pc proc.Word) EventHook</code>\n<p>\nOnBreakpoint returns the hook that is run when the program reaches\nthe given program counter.\n</p>\n\n",name:"OnBreakpoint"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnGoroutineCreate!\">OnGoroutineCreate</a></h2>\n<code>func (p *Process) OnGoroutineCreate() EventHook</code>\n<p>\nOnGoroutineCreate returns the hook that is run when a goroutine is created.\n</p>\n\n",name:"OnGoroutineCreate"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.OnGoroutineExit!\">OnGoroutineExit</a></h2>\n<code>func (p *Process) OnGoroutineExit() EventHook</code>\n<p>\nOnGoroutineExit returns the hook that is run when a goroutine exits.\n</p>\n\n",name:"OnGoroutineExit"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Out!\">Out</a></h2>\n<code>func (p *Process) Out() os.Error</code>\n<p>\nOut selects the caller frame of the current frame.\n</p>\n\n",name:"Out"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Peek!\">Peek</a></h2>\n<code>func (p *Process) Peek(addr proc.Word, out []byte) (int, os.Error)</code>\n\n",name:"Peek"},{html:"\n<h2><a class=\"black\" href=\"?m:Process\">func (*Process)</a> <a href=\"?m:Process.Poke!\">Poke</a></h2>\n<code>func (p *Process) Poke(addr proc.Word, b []byte) (int, os.Error)</code>\n\n",name:"Poke"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProcessNotStopped!\">ProcessNotStopped</a></h2>\n<pre>type ProcessNotStopped struct{}</pre>\n<p>\nA ProcessNotStopped error occurs when attempting to read or write\nmemory or registers of a process that is not stopped.\n</p>\n\n",name:"ProcessNotStopped","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ProcessNotStopped\">func (ProcessNotStopped)</a> <a href=\"?m:ProcessNotStopped.String!\">String</a></h2>\n<code>func (e ProcessNotStopped) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReadOnlyError!\">ReadOnlyError</a></h2>\n<pre>type ReadOnlyError string</pre>\n<p>\nA ReadOnlyError occurs when attempting to set or assign to a\nread-only value.\n</p>\n\n",name:"ReadOnlyError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReadOnlyError\">func (ReadOnlyError)</a> <a href=\"?m:ReadOnlyError.String!\">String</a></h2>\n<code>func (e ReadOnlyError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RemoteMismatchError!\">RemoteMismatchError</a></h2>\n<pre>type RemoteMismatchError string</pre>\n<p>\nA RemoteMismatchError occurs when an operation that requires two\nidentical remote processes is given different process.  For\nexample, this occurs when trying to set a pointer in one process to\npoint to something in another process.\n</p>\n\n",name:"RemoteMismatchError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RemoteMismatchError\">func (RemoteMismatchError)</a> <a href=\"?m:RemoteMismatchError.String!\">String</a></h2>\n<code>func (e RemoteMismatchError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownArchitecture!\">UnknownArchitecture</a></h2>\n<pre>type UnknownArchitecture elf.Machine</pre>\n<p>\nAn UnknownArchitecture occurs when trying to load an object file\nthat indicates an architecture not supported by the debugger.\n</p>\n\n",name:"UnknownArchitecture","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnknownArchitecture\">func (UnknownArchitecture)</a> <a href=\"?m:UnknownArchitecture.String!\">String</a></h2>\n<code>func (e UnknownArchitecture) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnknownGoroutine!\">UnknownGoroutine</a></h2>\n<pre>type UnknownGoroutine struct {\n\tOSThread  proc.Thread\n\tGoroutine proc.Word\n}</pre>\n<p>\nAn UnknownGoroutine error is an internal error representing an\nunrecognized G structure pointer.\n</p>\n\n",name:"UnknownGoroutine","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnknownGoroutine\">func (UnknownGoroutine)</a> <a href=\"?m:UnknownGoroutine.String!\">String</a></h2>\n<code>func (e UnknownGoroutine) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UsageError!\">UsageError</a></h2>\n<pre>type UsageError string</pre>\n<p>\nA UsageError occurs when a command is called with illegal arguments.\n</p>\n\n",name:"UsageError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UsageError\">func (UsageError)</a> <a href=\"?m:UsageError.String!\">String</a></h2>\n<code>func (e UsageError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EventPrint!\">EventPrint</a></h2>\n<code>func EventPrint(ev Event) (EventAction, os.Error)</code>\n<p>\nEventPrint is a standard event handler that prints events as they\noccur.  It will not cause the process to stop.\n</p>\n\n",name:"EventPrint"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EventStop!\">EventStop</a></h2>\n<code>func EventStop(ev Event) (EventAction, os.Error)</code>\n<p>\nEventStop is a standard event handler that causes the process to stop.\n</p>\n\n",name:"EventStop"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Main!\">Main</a></h2>\n<code>func Main()</code>\n\n",name:"Main"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewProcess!\">NewProcess</a></h2>\n<code>func NewProcess(tproc proc.Process, arch Arch, syms *gosym.Table) (*Process, os.Error)</code>\n<p>\nNewProcess constructs a new remote process around a traced\nprocess, an architecture, and a symbol table.\n</p>\n\n",name:"NewProcess"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewProcessElf!\">NewProcessElf</a></h2>\n<code>func NewProcessElf(tproc proc.Process, f *elf.File) (*Process, os.Error)</code>\n<p>\nNewProcessElf constructs a new remote process around a traced\nprocess and the process&#39; ELF object.\n</p>\n\n",name:"NewProcessElf"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EventAction!\">EventAction</a></h2>\n<pre>const (\n\tEARemoveSelf EventAction = 0x100\n\tEADefault    EventAction = iota\n\tEAStop\n\tEAContinue\n)</pre>\n\n",names:["EARemoveSelf","EADefault","EAStop","EAContinue"],type:"EventAction"}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:Amd64!\">Amd64</a></h2>\n<pre>var Amd64 = &amp;amd64{gReg: -1}</pre>\n\n",names:["Amd64"],type:""}]}