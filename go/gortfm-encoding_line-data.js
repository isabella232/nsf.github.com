var gortfmData = {index:"index.html",html:"<p>\nPackage line implements a Reader that reads lines delimited by &#39;\\n&#39; or\n&#39; \\r\\n&#39;.\n</p>\n",name:"line",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader struct {\n\t// contains unexported fields\n}</pre>\n<p>\nReader reads lines, delimited by &#39;\\n&#39; or \\r\\n&#39;, from an io.Reader.\n</p>\n\n",name:"Reader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.Read!\">Read</a></h2>\n<code>func (l *Reader) Read(p []byte) (n int, err os.Error)</code>\n<p>\nRead reads from any buffered data past the last line read, or from the underlying\nio.Reader if the buffer is empty.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:Reader\">func (*Reader)</a> <a href=\"?m:Reader.ReadLine!\">ReadLine</a></h2>\n<code>func (l *Reader) ReadLine() (line []byte, isPrefix bool, err os.Error)</code>\n<p>\nReadLine tries to return a single line, not including the end-of-line bytes.\nIf the line was found to be longer than the maximum length then isPrefix is\nset and the beginning of the line is returned. The rest of the line will be\nreturned from future calls. isPrefix will be false when returning the last\nfragment of the line.  The returned buffer points into the internal state of\nthe Reader and is only valid until the next call to ReadLine. ReadLine\neither returns a non-nil line or it returns an error, never both.\n</p>\n\n",name:"ReadLine"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(input io.Reader, maxLineLength int) *Reader</code>\n<p>\nNewReader returns a new Reader that will read successive\nlines from the input Reader.\n</p>\n\n",name:"NewReader"}],consts:[],vars:[]}