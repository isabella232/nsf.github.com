var gortfmData = {index:"index.html",html:"<p>\nThe asn1 package implements parsing of DER-encoded ASN.1 data structures,\nas defined in ITU-T Rec X.690.\n</p>\n<p>\nSee also &ldquo;A Layman&#39;s Guide to a Subset of ASN.1, BER, and DER,&rdquo;\n<a href=\"http://luca.ntop.org/Teaching/Appunti/asn1.html\">http://luca.ntop.org/Teaching/Appunti/asn1.html</a>.\n</p>\n",name:"asn1",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:BitString!\">BitString</a></h2>\n<pre>type BitString struct {\n\tBytes     []byte // bits packed into bytes.\n\tBitLength int    // length in bits.\n}</pre>\n<p>\nBitString is the structure to use when you want an ASN.1 BIT STRING type. A\nbit string is padded up to the nearest byte in memory and the number of\nvalid bits is recorded. Padding bits will be zero.\n</p>\n\n",name:"BitString","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:BitString\">func (BitString)</a> <a href=\"?m:BitString.At!\">At</a></h2>\n<code>func (b BitString) At(i int) int</code>\n<p>\nAt returns the bit at the given index. If the index is out of range it\nreturns false.\n</p>\n\n",name:"At"},{html:"\n<h2><a class=\"black\" href=\"?m:BitString\">func (BitString)</a> <a href=\"?m:BitString.RightAlign!\">RightAlign</a></h2>\n<code>func (b BitString) RightAlign() []byte</code>\n<p>\nRightAlign returns a slice where the padding bits are at the beginning. The\nslice may share memory with the BitString.\n</p>\n\n",name:"RightAlign"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Enumerated!\">Enumerated</a></h2>\n<pre>type Enumerated int</pre>\n<p>\nAn Enumerated is represented as a plain int.\n</p>\n\n",name:"Enumerated","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Flag!\">Flag</a></h2>\n<pre>type Flag bool</pre>\n<p>\nA Flag accepts any data and is set to true if present.\n</p>\n\n",name:"Flag","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ObjectIdentifier!\">ObjectIdentifier</a></h2>\n<pre>type ObjectIdentifier []int</pre>\n<p>\nAn ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.\n</p>\n\n",name:"ObjectIdentifier","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ObjectIdentifier\">func (ObjectIdentifier)</a> <a href=\"?m:ObjectIdentifier.Equal!\">Equal</a></h2>\n<code>func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool</code>\n<p>\nEqual returns true iff oi and other represent the same identifier.\n</p>\n\n",name:"Equal"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawContent!\">RawContent</a></h2>\n<pre>type RawContent []byte</pre>\n<p>\nRawContent is used to signal that the undecoded, DER data needs to be\npreserved for a struct. To use it, the first field of the struct must have\nthis type. It&#39;s an error for any of the other fields to have this type.\n</p>\n\n",name:"RawContent","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawValue!\">RawValue</a></h2>\n<pre>type RawValue struct {\n\tClass, Tag int\n\tIsCompound bool\n\tBytes      []byte\n\tFullBytes  []byte // includes the tag and length\n}</pre>\n<p>\nA RawValue represents an undecoded ASN.1 object.\n</p>\n\n",name:"RawValue","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:StructuralError!\">StructuralError</a></h2>\n<pre>type StructuralError struct {\n\tMsg string\n}</pre>\n<p>\nA StructuralError suggests that the ASN.1 data is valid, but the Go type\nwhich is receiving it doesn&#39;t match.\n</p>\n\n",name:"StructuralError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:StructuralError\">func (StructuralError)</a> <a href=\"?m:StructuralError.String!\">String</a></h2>\n<code>func (e StructuralError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SyntaxError!\">SyntaxError</a></h2>\n<pre>type SyntaxError struct {\n\tMsg string\n}</pre>\n<p>\nA SyntaxError suggests that the ASN.1 data is invalid.\n</p>\n\n",name:"SyntaxError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SyntaxError\">func (SyntaxError)</a> <a href=\"?m:SyntaxError.String!\">String</a></h2>\n<code>func (e SyntaxError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Marshal!\">Marshal</a></h2>\n<code>func Marshal(val interface{}) ([]byte, os.Error)</code>\n<p>\nMarshal returns the ASN.1 encoding of val.\n</p>\n\n",name:"Marshal"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Unmarshal!\">Unmarshal</a></h2>\n<code>func Unmarshal(b []byte, val interface{}) (rest []byte, err os.Error)</code>\n<p>\nUnmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n</p>\n<p>\nAn ASN.1 INTEGER can be written to an int or int64.\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n</p>\n<p>\nAn ASN.1 BIT STRING can be written to a BitString.\n</p>\n<p>\nAn ASN.1 OCTET STRING can be written to a []byte.\n</p>\n<p>\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n</p>\n<p>\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n</p>\n<p>\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a *time.Time.\n</p>\n<p>\nAn ASN.1 PrintableString or IA5String can be written to a string.\n</p>\n<p>\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n</p>\n<p>\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice&#39;s element type.\n</p>\n<p>\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n</p>\n<p>\nThe following tags on struct fields have special meaning to Unmarshal:\n</p>\n<pre>optional\t\tmarks the field as ASN.1 OPTIONAL\n[explicit] tag:x\tspecifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\ndefault:x\t\tsets the default value for optional integer fields\n</pre>\n<p>\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n</p>\n<p>\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n</p>\n\n",name:"Unmarshal"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnmarshalWithParams!\">UnmarshalWithParams</a></h2>\n<code>func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err os.Error)</code>\n<p>\nUnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n</p>\n\n",name:"UnmarshalWithParams"}],consts:[],vars:[]}