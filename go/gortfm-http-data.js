var gortfmData = {index:"index.html",html:"<p>\nThe http package implements parsing of HTTP requests, replies,\nand URLs and provides an extensible HTTP server and a basic\nHTTP client.\n</p>\n",name:"http",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ClientConn!\">ClientConn</a></h2>\n<pre>type ClientConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA ClientConn sends request and receives headers over an underlying\nconnection, while respecting the HTTP keepalive logic. ClientConn is not\nresponsible for closing the underlying connection. One must call Close to\nregain control of that connection and deal with it as desired.\n</p>\n\n",name:"ClientConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Close!\">Close</a></h2>\n<code>func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader)</code>\n<p>\nClose detaches the ClientConn and returns the underlying connection as well\nas the read-side bufio which may have some left over data. Close may be\ncalled before the user or Read have signaled the end of the keep-alive\nlogic. The user should not call Close while Read or Write is in progress.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Pending!\">Pending</a></h2>\n<code>func (cc *ClientConn) Pending() int</code>\n<p>\nPending returns the number of unanswered requests\nthat have been sent on the connection.\n</p>\n\n",name:"Pending"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Read!\">Read</a></h2>\n<code>func (cc *ClientConn) Read() (resp *Response, err os.Error)</code>\n<p>\nRead reads the next response from the wire. A valid response might be\nreturned together with an ErrPersistEOF, which means that the remote\nrequested that this be the last request serviced. Read can be called\nconcurrently with Write, but not with another Read.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Write!\">Write</a></h2>\n<code>func (cc *ClientConn) Write(req *Request) os.Error</code>\n<p>\nWrite writes a request. An ErrPersistEOF error is returned if the connection\nhas been closed in an HTTP keepalive sense. If req.Close equals true, the\nkeepalive connection is logically closed after this request and the opposing\nserver is informed. An ErrUnexpectedEOF indicates the remote closed the\nunderlying TCP connection, which is usually considered as graceful close.\nWrite can be called concurrently with Read, but not with another Write.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Handler!\">Handler</a></h2>\n<pre>type Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}</pre>\n<p>\nObjects implementing the Handler interface can be\nregistered to serve a particular path or subtree\nin the HTTP server.\n</p>\n<p>\nServeHTTP should write reply headers and data to the ResponseWriter\nand then return.  Returning signals that the request is finished\nand that the HTTP server can move on to the next request on\nthe connection.\n</p>\n\n",name:"Handler","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HandlerFunc!\">HandlerFunc</a></h2>\n<pre>type HandlerFunc func(ResponseWriter, *Request)</pre>\n<p>\nThe HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers.  If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler object that calls f.\n</p>\n\n",name:"HandlerFunc","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HandlerFunc\">func (HandlerFunc)</a> <a href=\"?m:HandlerFunc.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</code>\n<p>\nServeHTTP calls f(w, req).\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProtocolError!\">ProtocolError</a></h2>\n<pre>type ProtocolError struct {\n\tos.ErrorString\n}</pre>\n<p>\nHTTP request parsing errors.\n</p>\n\n",name:"ProtocolError","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Request!\">Request</a></h2>\n<pre>type Request struct {\n\tMethod     string // GET, POST, PUT, etc.\n\tRawURL     string // The raw URL given in the request.\n\tURL        *URL   // Parsed URL.\n\tProto      string // &#34;HTTP/1.0&#34;\n\tProtoMajor int    // 1\n\tProtoMinor int    // 0\n\n\n\t// A header maps request lines to their values.\n\t// If the header says\n\t//\n\t//\taccept-encoding: gzip, deflate\n\t//\tAccept-Language: en-us\n\t//\tConnection: keep-alive\n\t//\n\t// then\n\t//\n\t//\tHeader = map[string]string{\n\t//\t\t&#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,\n\t//\t\t&#34;Accept-Language&#34;: &#34;en-us&#34;,\n\t//\t\t&#34;Connection&#34;: &#34;keep-alive&#34;,\n\t//\t}\n\t//\n\t// HTTP defines that header names are case-insensitive.\n\t// The request parser implements this by canonicalizing the\n\t// name, making the first character and any characters\n\t// following a hyphen uppercase and the rest lowercase.\n\tHeader map[string]string\n\n\t// The message body.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content.\n\t// The value -1 indicates that the length is unknown.\n\t// Values &gt;= 0 indicate that the given number of bytes may be read from Body.\n\tContentLength int64\n\n\t// TransferEncoding lists the transfer encodings from outermost to innermost.\n\t// An empty list denotes the &#34;identity&#34; encoding.\n\tTransferEncoding []string\n\n\t// Whether to close the connection after replying to this request.\n\tClose bool\n\n\t// The host on which the URL is sought.\n\t// Per RFC 2616, this is either the value of the Host: header\n\t// or the host name given in the URL itself.\n\tHost string\n\n\t// The referring URL, if sent in the request.\n\t//\n\t// Referer is misspelled as in the request itself,\n\t// a mistake from the earliest days of HTTP.\n\t// This value can also be fetched from the Header map\n\t// as Header[&#34;Referer&#34;]; the benefit of making it\n\t// available as a structure field is that the compiler\n\t// can diagnose programs that use the alternate\n\t// (correct English) spelling req.Referrer but cannot\n\t// diagnose programs that use Header[&#34;Referrer&#34;].\n\tReferer string\n\n\t// The User-Agent: header string, if sent in the request.\n\tUserAgent string\n\n\t// The parsed form. Only available after ParseForm is called.\n\tForm map[string][]string\n\n\t// Trailer maps trailer keys to values.  Like for Header, if the\n\t// response has multiple trailer lines with the same key, they will be\n\t// concatenated, delimited by commas.\n\tTrailer map[string]string\n}</pre>\n<p>\nA Request represents a parsed HTTP request header.\n</p>\n\n",name:"Request","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.FormValue!\">FormValue</a></h2>\n<code>func (r *Request) FormValue(key string) string</code>\n<p>\nFormValue returns the first value for the named component of the query.\nFormValue calls ParseForm if necessary.\n</p>\n\n",name:"FormValue"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.MultipartReader!\">MultipartReader</a></h2>\n<code>func (r *Request) MultipartReader() (multipart.Reader, os.Error)</code>\n<p>\nMultipartReader returns a MIME multipart reader if this is a\nmultipart/form-data POST request, else returns nil and an error.\n</p>\n\n",name:"MultipartReader"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ParseForm!\">ParseForm</a></h2>\n<code>func (r *Request) ParseForm() (err os.Error)</code>\n<p>\nParseForm parses the request body as a form for POST requests, or the raw query for GET requests.\nIt is idempotent.\n</p>\n\n",name:"ParseForm"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ProtoAtLeast!\">ProtoAtLeast</a></h2>\n<code>func (r *Request) ProtoAtLeast(major, minor int) bool</code>\n<p>\nProtoAtLeast returns whether the HTTP protocol used\nin the request is at least major.minor.\n</p>\n\n",name:"ProtoAtLeast"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.Write!\">Write</a></h2>\n<code>func (req *Request) Write(w io.Writer) os.Error</code>\n<p>\nWrite writes an HTTP/1.1 request -- header and body -- in wire format.\nThis method consults the following fields of req:\n</p>\n<pre>Host\nRawURL, if non-empty, or else URL\nMethod (defaults to &#34;GET&#34;)\nUserAgent (defaults to defaultUserAgent)\nReferer\nHeader\nBody\n</pre>\n<p>\nIf Body is present, Write forces &#34;Transfer-Encoding: chunked&#34; as a header\nand then closes Body when finished sending it.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Response!\">Response</a></h2>\n<pre>type Response struct {\n\tStatus     string // e.g. &#34;200 OK&#34;\n\tStatusCode int    // e.g. 200\n\tProto      string // e.g. &#34;HTTP/1.0&#34;\n\tProtoMajor int    // e.g. 1\n\tProtoMinor int    // e.g. 0\n\n\n\t// RequestMethod records the method used in the HTTP request.\n\t// Header fields such as Content-Length have method-specific meaning.\n\tRequestMethod string // e.g. &#34;HEAD&#34;, &#34;CONNECT&#34;, &#34;GET&#34;, etc.\n\n\n\t// Header maps header keys to values.  If the response had multiple\n\t// headers with the same key, they will be concatenated, with comma\n\t// delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers\n\t// be semantically equivalent to a comma-delimited sequence.) Values\n\t// duplicated by other fields in this struct (e.g., ContentLength) are\n\t// omitted from Header.\n\t//\n\t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n\tHeader map[string]string\n\n\t// Body represents the response body.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content.  The\n\t// value -1 indicates that the length is unknown.  Unless RequestMethod\n\t// is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\tContentLength int64\n\n\t// Contains transfer encodings from outer-most to inner-most. Value is\n\t// nil, means that &#34;identity&#34; encoding is used.\n\tTransferEncoding []string\n\n\t// Close records whether the header directed that the connection be\n\t// closed after reading Body.  The value is advice for clients: neither\n\t// ReadResponse nor Response.Write ever closes a connection.\n\tClose bool\n\n\t// Trailer maps trailer keys to values.  Like for Header, if the\n\t// response has multiple trailer lines with the same key, they will be\n\t// concatenated, delimited by commas.\n\tTrailer map[string]string\n}</pre>\n<p>\nResponse represents the response from an HTTP request.\n</p>\n\n",name:"Response","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.AddHeader!\">AddHeader</a></h2>\n<code>func (r *Response) AddHeader(key, value string)</code>\n<p>\nAddHeader adds a value under the given key.  Keys are not case sensitive.\n</p>\n\n",name:"AddHeader"},{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.GetHeader!\">GetHeader</a></h2>\n<code>func (r *Response) GetHeader(key string) (value string)</code>\n<p>\nGetHeader returns the value of the response header with the given key.\nIf there were multiple headers with this key, their values are concatenated,\nwith a comma delimiter.  If there were no response headers with the given\nkey, GetHeader returns an empty string.  Keys are not case sensitive.\n</p>\n\n",name:"GetHeader"},{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.ProtoAtLeast!\">ProtoAtLeast</a></h2>\n<code>func (r *Response) ProtoAtLeast(major, minor int) bool</code>\n<p>\nProtoAtLeast returns whether the HTTP protocol used\nin the response is at least major.minor.\n</p>\n\n",name:"ProtoAtLeast"},{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.Write!\">Write</a></h2>\n<code>func (resp *Response) Write(w io.Writer) os.Error</code>\n<p>\nWrites the response (header, body and trailer) in wire format. This method\nconsults the following fields of resp:\n</p>\n<pre>StatusCode\nProtoMajor\nProtoMinor\nRequestMethod\nTransferEncoding\nTrailer\nBody\nContentLength\nHeader, values for non-canonical keys will have unpredictable behavior\n</pre>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ResponseWriter!\">ResponseWriter</a></h2>\n<pre>type ResponseWriter interface {\n\t// RemoteAddr returns the address of the client that sent the current request\n\tRemoteAddr() string\n\n\t// UsingTLS returns true if the client is connected using TLS\n\tUsingTLS() bool\n\n\t// SetHeader sets a header line in the eventual response.\n\t// For example, SetHeader(&#34;Content-Type&#34;, &#34;text/html; charset=utf-8&#34;)\n\t// will result in the header line\n\t//\n\t//\tContent-Type: text/html; charset=utf-8\n\t//\n\t// being sent.  UTF-8 encoded HTML is the default setting for\n\t// Content-Type in this library, so users need not make that\n\t// particular call.  Calls to SetHeader after WriteHeader (or Write)\n\t// are ignored.\n\tSetHeader(string, string)\n\n\t// Write writes the data to the connection as part of an HTTP reply.\n\t// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n\t// before writing the data.\n\tWrite([]byte) (int, os.Error)\n\n\t// WriteHeader sends an HTTP response header with status code.\n\t// If WriteHeader is not called explicitly, the first call to Write\n\t// will trigger an implicit WriteHeader(http.StatusOK).\n\t// Thus explicit calls to WriteHeader are mainly used to\n\t// send error codes.\n\tWriteHeader(int)\n\n\t// Flush sends any buffered data to the client.\n\tFlush()\n\n\t// Hijack lets the caller take over the connection.\n\t// After a call to Hijack(), the HTTP server library\n\t// will not do anything else with the connection.\n\t// It becomes the caller&#39;s responsibility to manage\n\t// and close the connection.\n\tHijack() (io.ReadWriteCloser, *bufio.ReadWriter, os.Error)\n}</pre>\n<p>\nA ResponseWriter interface is used by an HTTP handler to\nconstruct an HTTP response.\n</p>\n\n",name:"ResponseWriter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServeMux!\">ServeMux</a></h2>\n<pre>type ServeMux struct {\n\t// contains unexported fields\n}</pre>\n<p>\nServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n</p>\n<p>\nPatterns named fixed paths, like &#34;/favicon.ico&#34;,\nor subtrees, like &#34;/images/&#34; (note the trailing slash).\nPatterns must begin with /.\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both &#34;/images/&#34;\nand &#34;/images/thumbnails/&#34;, the latter handler will be\ncalled for paths beginning &#34;/images/thumbnails/&#34; and the\nformer will receiver requests for any other paths in the\n&#34;/images/&#34; subtree.\n</p>\n<p>\nIn the future, the pattern syntax may be relaxed to allow\nan optional host-name at the beginning of the pattern,\nso that a handler might register for the two patterns\n&#34;/codesearch&#34; and &#34;codesearch.google.com/&#34;\nwithout taking over requests for <a href=\"http://www.google.com/\">http://www.google.com/</a>.\n</p>\n<p>\nServeMux also takes care of sanitizing the URL request path,\nredirecting any request containing . or .. elements to an\nequivalent .- and ..-free URL.\n</p>\n\n",name:"ServeMux","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.Handle!\">Handle</a></h2>\n<code>func (mux *ServeMux) Handle(pattern string, handler Handler)</code>\n<p>\nHandle registers the handler for the given pattern.\n</p>\n\n",name:"Handle"},{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.HandleFunc!\">HandleFunc</a></h2>\n<code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\n<p>\nHandleFunc registers the handler function for the given pattern.\n</p>\n\n",name:"HandleFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</code>\n<p>\nServeHTTP dispatches the request to the handler whose\npattern most closely matches the request URL.\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerConn!\">ServerConn</a></h2>\n<pre>type ServerConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA ServerConn reads requests and sends responses over an underlying\nconnection, until the HTTP keepalive logic commands an end. ServerConn\ndoes not close the underlying connection. Instead, the user calls Close\nand regains control over the connection. ServerConn supports pipe-lining,\ni.e. requests can be read out of sync (but in the same order) while the\nrespective responses are sent.\n</p>\n\n",name:"ServerConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Close!\">Close</a></h2>\n<code>func (sc *ServerConn) Close() (c net.Conn, r *bufio.Reader)</code>\n<p>\nClose detaches the ServerConn and returns the underlying connection as well\nas the read-side bufio which may have some left over data. Close may be\ncalled before Read has signaled the end of the keep-alive logic. The user\nshould not call Close while Read or Write is in progress.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Pending!\">Pending</a></h2>\n<code>func (sc *ServerConn) Pending() int</code>\n<p>\nPending returns the number of unanswered requests\nthat have been received on the connection.\n</p>\n\n",name:"Pending"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Read!\">Read</a></h2>\n<code>func (sc *ServerConn) Read() (req *Request, err os.Error)</code>\n<p>\nRead returns the next request on the wire. An ErrPersistEOF is returned if\nit is gracefully determined that there are no more requests (e.g. after the\nfirst request on an HTTP/1.0 connection, or after a Connection:close on a\nHTTP/1.1 connection). Read can be called concurrently with Write, but not\nwith another Read.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Write!\">Write</a></h2>\n<code>func (sc *ServerConn) Write(resp *Response) os.Error</code>\n<p>\nWrite writes a repsonse. To close the connection gracefully, set the\nResponse.Close field to true. Write should be considered operational until\nit returns an error, regardless of any errors returned on the Read side.\nWrite can be called concurrently with Read, but not with another Write.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URL!\">URL</a></h2>\n<pre>type URL struct {\n\tRaw          string // the original string\n\tScheme       string // scheme\n\tRawAuthority string // [userinfo@]host\n\tRawUserinfo  string // userinfo\n\tHost         string // host\n\tRawPath      string // /path[?query][#fragment]\n\tPath         string // /path\n\tOpaquePath   bool   // path is opaque (unrooted when scheme is present)\n\tRawQuery     string // query\n\tFragment     string // fragment\n}</pre>\n<p>\nA URL represents a parsed URL (technically, a URI reference).\nThe general form represented is:\n</p>\n<pre>scheme://[userinfo@]host/path[?query][#fragment]\n</pre>\n<p>\nThe Raw, RawAuthority, RawPath, and RawQuery fields are in &#34;wire format&#34;\n(special characters must be hex-escaped if not meant to have special meaning).\nAll other fields are logical values; &#39;+&#39; or &#39;%&#39; represent themselves.\n</p>\n<p>\nThe various Raw values are supplied in wire format because\nclients typically have to split them into pieces before further\ndecoding.\n</p>\n\n",name:"URL","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.String!\">String</a></h2>\n<code>func (url *URL) String() string</code>\n<p>\nString reassembles url into a valid URL string.\n</p>\n<p>\nThere are redundant fields stored in the URL structure:\nthe String method consults Scheme, Path, Host, RawUserinfo,\nRawQuery, and Fragment, but not Raw, RawPath or Authority.\n</p>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLError!\">URLError</a></h2>\n<pre>type URLError struct {\n\tOp    string\n\tURL   string\n\tError os.Error\n}</pre>\n<p>\nURLError reports an error and the operation and URL that caused it.\n</p>\n\n",name:"URLError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URLError\">func (*URLError)</a> <a href=\"?m:URLError.String!\">String</a></h2>\n<code>func (e *URLError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLEscapeError!\">URLEscapeError</a></h2>\n<pre>type URLEscapeError string</pre>\n\n",name:"URLEscapeError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URLEscapeError\">func (URLEscapeError)</a> <a href=\"?m:URLEscapeError.String!\">String</a></h2>\n<code>func (e URLEscapeError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalHeaderKey!\">CanonicalHeaderKey</a></h2>\n<code>func CanonicalHeaderKey(s string) string</code>\n<p>\nCanonicalHeaderKey returns the canonical format of the\nHTTP header key s.  The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase.  For example, the\ncanonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.\n</p>\n\n",name:"CanonicalHeaderKey"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalPath!\">CanonicalPath</a></h2>\n<code>func CanonicalPath(path string) string</code>\n<p>\nCanonicalPath applies the algorithm specified in RFC 2396 to\nsimplify the path, removing unnecessary  . and .. elements.\n</p>\n\n",name:"CanonicalPath"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpRequest!\">DumpRequest</a></h2>\n<code>func DumpRequest(req *Request, body bool) (dump []byte, err os.Error)</code>\n<p>\nDumpRequest returns the wire representation of req,\noptionally including the request body, for debugging.\nDumpRequest is semantically a no-op, but in order to\ndump the body, it reads the body data into memory and\nchanges req.Body to refer to the in-memory copy.\n</p>\n\n",name:"DumpRequest"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpResponse!\">DumpResponse</a></h2>\n<code>func DumpResponse(resp *Response, body bool) (dump []byte, err os.Error)</code>\n<p>\nDumpResponse is like DumpRequest but dumps a response.\n</p>\n\n",name:"DumpResponse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Error!\">Error</a></h2>\n<code>func Error(w ResponseWriter, error string, code int)</code>\n<p>\nError replies to the request with the specified error message and HTTP code.\n</p>\n\n",name:"Error"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EscapeUserinfo!\">EscapeUserinfo</a></h2>\n<code>func EscapeUserinfo(user, password string) string</code>\n<p>\nEscapeUserinfo combines user and password in the form\nuser:password (or just user if password is empty) and then\nescapes it for use as the URL.RawUserinfo field.\n</p>\n<p>\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n&ldquo;is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.&rdquo;\n</p>\n\n",name:"EscapeUserinfo"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileServer!\">FileServer</a></h2>\n<code>func FileServer(root, prefix string) Handler</code>\n<p>\nFileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\nIt strips prefix from the incoming requests before\nlooking up the file name in the file system.\n</p>\n\n",name:"FileServer"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Get!\">Get</a></h2>\n<code>func Get(url string) (r *Response, finalURL string, err os.Error)</code>\n<p>\nGet issues a GET to the specified URL.  If the response is one of the following\nredirect codes, it follows the redirect, up to a maximum of 10 redirects:\n</p>\n<pre>301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre>\n<p>\nfinalURL is the URL from which the response was fetched -- identical to the\ninput URL unless redirects were followed.\n</p>\n<p>\nCaller should close r.Body when done reading it.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Handle!\">Handle</a></h2>\n<code>func Handle(pattern string, handler Handler)</code>\n<p>\nHandle registers the handler for the given pattern\nin the DefaultServeMux.\n</p>\n\n",name:"Handle"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HandleFunc!\">HandleFunc</a></h2>\n<code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\n<p>\nHandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\n</p>\n\n",name:"HandleFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Head!\">Head</a></h2>\n<code>func Head(url string) (r *Response, err os.Error)</code>\n<p>\nHead issues a HEAD to the specified URL.\n</p>\n\n",name:"Head"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServe!\">ListenAndServe</a></h2>\n<code>func ListenAndServe(addr string, handler Handler) os.Error</code>\n<p>\nListenAndServe listens on the TCP network address addr\nand then calls Serve with handler to handle requests\non incoming connections.  Handler is typically nil,\nin which case the DefaultServeMux is used.\n</p>\n<p>\nA trivial example server is:\n</p>\n<pre>package main\n\nimport (\n\t&#34;http&#34;\n\t&#34;io&#34;\n\t&#34;log&#34;\n)\n\n// hello world, the web server\nfunc HelloServer(w http.ResponseWriter, req *http.Request) {\n\tio.WriteString(w, &#34;hello, world!\\n&#34;)\n}\n\nfunc main() {\n\thttp.HandleFunc(&#34;/hello&#34;, HelloServer)\n\terr := http.ListenAndServe(&#34;:12345&#34;, nil)\n\tif err != nil {\n\t\tlog.Exit(&#34;ListenAndServe: &#34;, err.String())\n\t}\n}\n</pre>\n\n",name:"ListenAndServe"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServeTLS!\">ListenAndServeTLS</a></h2>\n<code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) os.Error</code>\n<p>\nListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided.\n</p>\n<p>\nA trivial example server is:\n</p>\n<pre>import (\n\t&#34;http&#34;\n\t&#34;log&#34;\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.SetHeader(&#34;Content-Type&#34;, &#34;text/plain&#34;)\n\tw.Write([]byte(&#34;This is an example server.\\n&#34;))\n}\n\nfunc main() {\n\thttp.HandleFunc(&#34;/&#34;, handler)\n\tlog.Printf(&#34;About to listen on 10443. Go to <a href=\"https://127.0.0.1:10443/\">https://127.0.0.1:10443/</a>&#34;)\n\terr := http.ListenAndServeTLS(&#34;:10443&#34;, &#34;cert.pem&#34;, &#34;key.pem&#34;, nil)\n\tif err != nil {\n\t\tlog.Exit(err)\n\t}\n}\n</pre>\n<p>\nOne can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.\n</p>\n\n",name:"ListenAndServeTLS"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewChunkedWriter!\">NewChunkedWriter</a></h2>\n<code>func NewChunkedWriter(w io.Writer) io.WriteCloser</code>\n<p>\nNewChunkedWriter returns a new writer that translates writes into HTTP\n&#34;chunked&#34; format before writing them to w.  Closing the returned writer\nsends the final 0-length chunk that marks the end of the stream.\n</p>\n\n",name:"NewChunkedWriter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClientConn!\">NewClientConn</a></h2>\n<code>func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</code>\n<p>\nNewClientConn returns a new ClientConn reading and writing c.  If r is not\nnil, it is the buffer to use when reading c.\n</p>\n\n",name:"NewClientConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServeMux!\">NewServeMux</a></h2>\n<code>func NewServeMux() *ServeMux</code>\n<p>\nNewServeMux allocates and returns a new ServeMux.\n</p>\n\n",name:"NewServeMux"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServerConn!\">NewServerConn</a></h2>\n<code>func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</code>\n<p>\nNewServerConn returns a new ServerConn reading and writing c.  If r is not\nnil, it is the buffer to use when reading c.\n</p>\n\n",name:"NewServerConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFound!\">NotFound</a></h2>\n<code>func NotFound(w ResponseWriter, r *Request)</code>\n<p>\nNotFound replies to the request with an HTTP 404 not found error.\n</p>\n\n",name:"NotFound"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFoundHandler!\">NotFoundHandler</a></h2>\n<code>func NotFoundHandler() Handler</code>\n<p>\nNotFoundHandler returns a simple request handler\nthat replies to each request with a &ldquo;404 page not found&rdquo; reply.\n</p>\n\n",name:"NotFoundHandler"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseQuery!\">ParseQuery</a></h2>\n<code>func ParseQuery(query string) (m map[string][]string, err os.Error)</code>\n<p>\nParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n</p>\n\n",name:"ParseQuery"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURL!\">ParseURL</a></h2>\n<code>func ParseURL(rawurl string) (url *URL, err os.Error)</code>\n<p>\nParseURL parses rawurl into a URL structure.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n</p>\n\n",name:"ParseURL"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURLReference!\">ParseURLReference</a></h2>\n<code>func ParseURLReference(rawurlref string) (url *URL, err os.Error)</code>\n<p>\nParseURLReference is like ParseURL but allows a trailing #fragment.\n</p>\n\n",name:"ParseURLReference"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Post!\">Post</a></h2>\n<code>func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error)</code>\n<p>\nPost issues a POST to the specified URL.\n</p>\n<p>\nCaller should close r.Body when done reading it.\n</p>\n\n",name:"Post"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PostForm!\">PostForm</a></h2>\n<code>func PostForm(url string, data map[string]string) (r *Response, err os.Error)</code>\n<p>\nPostForm issues a POST to the specified URL,\nwith data&#39;s keys and values urlencoded as the request body.\n</p>\n<p>\nCaller should close r.Body when done reading it.\n</p>\n\n",name:"PostForm"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadRequest!\">ReadRequest</a></h2>\n<code>func ReadRequest(b *bufio.Reader) (req *Request, err os.Error)</code>\n<p>\nReadRequest reads and parses a request from b.\n</p>\n\n",name:"ReadRequest"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadResponse!\">ReadResponse</a></h2>\n<code>func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error)</code>\n<p>\nReadResponse reads and returns an HTTP response from r.  The RequestMethod\nparameter specifies the method used in the corresponding request (e.g.,\n&#34;GET&#34;, &#34;HEAD&#34;).  Clients must call resp.Body.Close when finished reading\nresp.Body.  After that call, clients can inspect resp.Trailer to find\nkey/value pairs included in the response trailer.\n</p>\n\n",name:"ReadResponse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Redirect!\">Redirect</a></h2>\n<code>func Redirect(w ResponseWriter, r *Request, url string, code int)</code>\n<p>\nRedirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n</p>\n\n",name:"Redirect"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RedirectHandler!\">RedirectHandler</a></h2>\n<code>func RedirectHandler(url string, code int) Handler</code>\n<p>\nRedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n</p>\n\n",name:"RedirectHandler"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Serve!\">Serve</a></h2>\n<code>func Serve(l net.Listener, handler Handler) os.Error</code>\n<p>\nServe accepts incoming HTTP connections on the listener l,\ncreating a new service thread for each.  The service threads\nread requests and then call handler to reply to them.\nHandler is typically nil, in which case the DefaultServeMux is used.\n</p>\n\n",name:"Serve"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeFile!\">ServeFile</a></h2>\n<code>func ServeFile(w ResponseWriter, r *Request, name string)</code>\n<p>\nServeFile replies to the request with the contents of the named file or directory.\n</p>\n\n",name:"ServeFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:StatusText!\">StatusText</a></h2>\n<code>func StatusText(code int) string</code>\n<p>\nStatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n</p>\n\n",name:"StatusText"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLEscape!\">URLEscape</a></h2>\n<code>func URLEscape(s string) string</code>\n<p>\nURLEscape converts a string into &ldquo;URL encoded&rdquo; form.\nDespite the name, this encoding applies only to individual\ncomponents of the query portion of the URL.\n</p>\n\n",name:"URLEscape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLUnescape!\">URLUnescape</a></h2>\n<code>func URLUnescape(s string) (string, os.Error)</code>\n<p>\nURLUnescape unescapes a string in &ldquo;URL encoded&rdquo; form,\nconverting %AB into the byte 0xAB and &#39;+&#39; into &#39; &#39; (space).\nIt returns an error if any % is not followed\nby two hexadecimal digits.\nDespite the name, this encoding applies only to individual\ncomponents of the query portion of the URL.\n</p>\n\n",name:"URLUnescape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnescapeUserinfo!\">UnescapeUserinfo</a></h2>\n<code>func UnescapeUserinfo(rawUserinfo string) (user, password string, err os.Error)</code>\n<p>\nUnescapeUserinfo parses the RawUserinfo field of a URL\nas the form user or user:password and unescapes and returns\nthe two halves.\n</p>\n<p>\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n&ldquo;is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.&rdquo;\n</p>\n\n",name:"UnescapeUserinfo"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TimeFormat!\">TimeFormat</a></h2>\n<pre>const TimeFormat = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;</pre>\n<p>\nTimeFormat is the time format to use with\ntime.Parse and time.Time.Format when parsing\nor generating times in HTTP headers.\nIt is like time.RFC1123 but hard codes GMT as the time zone.\n</p>\n\n",names:["TimeFormat"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:StatusContinue!\"><em>group</em></a></h2>\n<pre>const (\n\tStatusContinue           = 100\n\tStatusSwitchingProtocols = 101\n\n\tStatusOK                   = 200\n\tStatusCreated              = 201\n\tStatusAccepted             = 202\n\tStatusNonAuthoritativeInfo = 203\n\tStatusNoContent            = 204\n\tStatusResetContent         = 205\n\tStatusPartialContent       = 206\n\n\tStatusMultipleChoices   = 300\n\tStatusMovedPermanently  = 301\n\tStatusFound             = 302\n\tStatusSeeOther          = 303\n\tStatusNotModified       = 304\n\tStatusUseProxy          = 305\n\tStatusTemporaryRedirect = 307\n\n\tStatusBadRequest                   = 400\n\tStatusUnauthorized                 = 401\n\tStatusPaymentRequired              = 402\n\tStatusForbidden                    = 403\n\tStatusNotFound                     = 404\n\tStatusMethodNotAllowed             = 405\n\tStatusNotAcceptable                = 406\n\tStatusProxyAuthRequired            = 407\n\tStatusRequestTimeout               = 408\n\tStatusConflict                     = 409\n\tStatusGone                         = 410\n\tStatusLengthRequired               = 411\n\tStatusPreconditionFailed           = 412\n\tStatusRequestEntityTooLarge        = 413\n\tStatusRequestURITooLong            = 414\n\tStatusUnsupportedMediaType         = 415\n\tStatusRequestedRangeNotSatisfiable = 416\n\tStatusExpectationFailed            = 417\n\n\tStatusInternalServerError     = 500\n\tStatusNotImplemented          = 501\n\tStatusBadGateway              = 502\n\tStatusServiceUnavailable      = 503\n\tStatusGatewayTimeout          = 504\n\tStatusHTTPVersionNotSupported = 505\n)</pre>\n<p>\nHTTP status codes, defined in RFC 2616.\n</p>\n\n",names:["StatusContinue","StatusSwitchingProtocols","StatusOK","StatusCreated","StatusAccepted","StatusNonAuthoritativeInfo","StatusNoContent","StatusResetContent","StatusPartialContent","StatusMultipleChoices","StatusMovedPermanently","StatusFound","StatusSeeOther","StatusNotModified","StatusUseProxy","StatusTemporaryRedirect","StatusBadRequest","StatusUnauthorized","StatusPaymentRequired","StatusForbidden","StatusNotFound","StatusMethodNotAllowed","StatusNotAcceptable","StatusProxyAuthRequired","StatusRequestTimeout","StatusConflict","StatusGone","StatusLengthRequired","StatusPreconditionFailed","StatusRequestEntityTooLarge","StatusRequestURITooLong","StatusUnsupportedMediaType","StatusRequestedRangeNotSatisfiable","StatusExpectationFailed","StatusInternalServerError","StatusNotImplemented","StatusBadGateway","StatusServiceUnavailable","StatusGatewayTimeout","StatusHTTPVersionNotSupported"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrLineTooLong!\"><em>group</em></a></h2>\n<pre>var (\n\tErrLineTooLong          = &amp;ProtocolError{&#34;header line too long&#34;}\n\tErrHeaderTooLong        = &amp;ProtocolError{&#34;header too long&#34;}\n\tErrShortBody            = &amp;ProtocolError{&#34;entity body too short&#34;}\n\tErrNotSupported         = &amp;ProtocolError{&#34;feature not supported&#34;}\n\tErrUnexpectedTrailer    = &amp;ProtocolError{&#34;trailer header without chunked transfer encoding&#34;}\n\tErrMissingContentLength = &amp;ProtocolError{&#34;missing ContentLength in HEAD response&#34;}\n\tErrNotMultipart         = &amp;ProtocolError{&#34;request Content-Type isn&#39;t multipart/form-data&#34;}\n\tErrMissingBoundary      = &amp;ProtocolError{&#34;no multipart boundary param Content-Type&#34;}\n)</pre>\n\n",names:["ErrLineTooLong","ErrHeaderTooLong","ErrShortBody","ErrNotSupported","ErrUnexpectedTrailer","ErrMissingContentLength","ErrNotMultipart","ErrMissingBoundary"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrWriteAfterFlush!\"><em>group</em></a></h2>\n<pre>var (\n\tErrWriteAfterFlush = os.NewError(&#34;Conn.Write called after Flush&#34;)\n\tErrBodyNotAllowed  = os.NewError(&#34;http: response status code does not allow body&#34;)\n\tErrHijacked        = os.NewError(&#34;Conn has been hijacked&#34;)\n)</pre>\n<p>\nErrors introduced by the HTTP server.\n</p>\n\n",names:["ErrWriteAfterFlush","ErrBodyNotAllowed","ErrHijacked"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultServeMux!\">DefaultServeMux</a></h2>\n<pre>var DefaultServeMux = NewServeMux()</pre>\n<p>\nDefaultServeMux is the default ServeMux used by Serve.\n</p>\n\n",names:["DefaultServeMux"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrPersistEOF!\">ErrPersistEOF</a></h2>\n<pre>var ErrPersistEOF = &amp;ProtocolError{&#34;persistent connection closed&#34;}</pre>\n\n",names:["ErrPersistEOF"],type:""}]}