var gortfmData = {index:"index.html",html:"<p>\nPackage http implements parsing of HTTP requests, replies, and URLs and\nprovides an extensible HTTP server and a basic HTTP client.\n</p>\n",name:"http",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Client!\">Client</a></h2>\n<pre>type Client struct {\n\tTransport RoundTripper // if nil, DefaultTransport is used\n\n\n\t// If CheckRedirect is not nil, the client calls it before\n\t// following an HTTP redirect. The arguments req and via\n\t// are the upcoming request and the requests made already,\n\t// oldest first. If CheckRedirect returns an error, the client\n\t// returns that error instead of issue the Request req.\n\t//\n\t// If CheckRedirect is nil, the Client uses its default policy,\n\t// which is to stop after 10 consecutive requests.\n\tCheckRedirect func(req *Request, via []*Request) os.Error\n}</pre>\n<p>\nA Client is an HTTP client. Its zero value (DefaultClient) is a usable client\nthat uses DefaultTransport.\nClient is not yet very configurable.\n</p>\n\n",name:"Client","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Do!\">Do</a></h2>\n<code>func (c *Client) Do(req *Request) (resp *Response, err os.Error)</code>\n<p>\nDo sends an HTTP request and returns an HTTP response, following\npolicy (e.g. redirects, cookies, auth) as configured on the client.\n</p>\n<p>\nCallers should close resp.Body when done reading from it.\n</p>\n<p>\nGenerally Get, Post, or PostForm will be used instead of Do.\n</p>\n\n",name:"Do"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Get!\">Get</a></h2>\n<code>func (c *Client) Get(url string) (r *Response, finalURL string, err os.Error)</code>\n<p>\nGet issues a GET to the specified URL.  If the response is one of the\nfollowing redirect codes, Get follows the redirect after calling the\nClient&#39;s CheckRedirect function.\n</p>\n<pre>301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre>\n<p>\nfinalURL is the URL from which the response was fetched -- identical\nto the input URL unless redirects were followed.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Head!\">Head</a></h2>\n<code>func (c *Client) Head(url string) (r *Response, err os.Error)</code>\n<p>\nHead issues a HEAD to the specified URL.\n</p>\n\n",name:"Head"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Post!\">Post</a></h2>\n<code>func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error)</code>\n<p>\nPost issues a POST to the specified URL.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n\n",name:"Post"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.PostForm!\">PostForm</a></h2>\n<code>func (c *Client) PostForm(url string, data map[string]string) (r *Response, err os.Error)</code>\n<p>\nPostForm issues a POST to the specified URL,\nwith data&#39;s keys and values urlencoded as the request body.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n\n",name:"PostForm"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ClientConn!\">ClientConn</a></h2>\n<pre>type ClientConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA ClientConn sends request and receives headers over an underlying\nconnection, while respecting the HTTP keepalive logic. ClientConn\nsupports hijacking the connection calling Hijack to\nregain control of the underlying net.Conn and deal with it as desired.\n</p>\n\n",name:"ClientConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Close!\">Close</a></h2>\n<code>func (cc *ClientConn) Close() os.Error</code>\n<p>\nClose calls Hijack and then also closes the underlying connection\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Do!\">Do</a></h2>\n<code>func (cc *ClientConn) Do(req *Request) (resp *Response, err os.Error)</code>\n<p>\nDo is convenience method that writes a request and reads a response.\n</p>\n\n",name:"Do"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Hijack!\">Hijack</a></h2>\n<code>func (cc *ClientConn) Hijack() (c net.Conn, r *bufio.Reader)</code>\n<p>\nHijack detaches the ClientConn and returns the underlying connection as well\nas the read-side bufio which may have some left over data. Hijack may be\ncalled before the user or Read have signaled the end of the keep-alive\nlogic. The user should not call Hijack while Read or Write is in progress.\n</p>\n\n",name:"Hijack"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Pending!\">Pending</a></h2>\n<code>func (cc *ClientConn) Pending() int</code>\n<p>\nPending returns the number of unanswered requests\nthat have been sent on the connection.\n</p>\n\n",name:"Pending"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Read!\">Read</a></h2>\n<code>func (cc *ClientConn) Read(req *Request) (resp *Response, err os.Error)</code>\n<p>\nRead reads the next response from the wire. A valid response might be\nreturned together with an ErrPersistEOF, which means that the remote\nrequested that this be the last request serviced. Read can be called\nconcurrently with Write, but not with another Read.\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:ClientConn\">func (*ClientConn)</a> <a href=\"?m:ClientConn.Write!\">Write</a></h2>\n<code>func (cc *ClientConn) Write(req *Request) (err os.Error)</code>\n<p>\nWrite writes a request. An ErrPersistEOF error is returned if the connection\nhas been closed in an HTTP keepalive sense. If req.Close equals true, the\nkeepalive connection is logically closed after this request and the opposing\nserver is informed. An ErrUnexpectedEOF indicates the remote closed the\nunderlying TCP connection, which is usually considered as graceful close.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cookie!\">Cookie</a></h2>\n<pre>type Cookie struct {\n\tName       string\n\tValue      string\n\tPath       string\n\tDomain     string\n\tExpires    time.Time\n\tRawExpires string\n\n\t// MaxAge=0 means no &#39;Max-Age&#39; attribute specified. \n\t// MaxAge&lt;0 means delete cookie now, equivalently &#39;Max-Age: 0&#39;\n\t// MaxAge&gt;0 means Max-Age attribute present and given in seconds\n\tMaxAge   int\n\tSecure   bool\n\tHttpOnly bool\n\tRaw      string\n\tUnparsed []string // Raw text of unparsed attribute-value pairs\n}</pre>\n<p>\nA Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n</p>\n\n",name:"Cookie","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Flusher!\">Flusher</a></h2>\n<pre>type Flusher interface {\n\t// Flush sends any buffered data to the client.\n\tFlush()\n}</pre>\n<p>\nThe Flusher interface is implemented by ResponseWriters that allow\nan HTTP handler to flush buffered data to the client.\n</p>\n<p>\nNote that even for ResponseWriters that support Flush,\nif the client is connected through an HTTP proxy,\nthe buffered data may not reach the client until the response\ncompletes.\n</p>\n\n",name:"Flusher","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Handler!\">Handler</a></h2>\n<pre>type Handler interface {\n\tServeHTTP(ResponseWriter, *Request)\n}</pre>\n<p>\nObjects implementing the Handler interface can be\nregistered to serve a particular path or subtree\nin the HTTP server.\n</p>\n<p>\nServeHTTP should write reply headers and data to the ResponseWriter\nand then return.  Returning signals that the request is finished\nand that the HTTP server can move on to the next request on\nthe connection.\n</p>\n\n",name:"Handler","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:HandlerFunc!\">HandlerFunc</a></h2>\n<pre>type HandlerFunc func(ResponseWriter, *Request)</pre>\n<p>\nThe HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers.  If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler object that calls f.\n</p>\n\n",name:"HandlerFunc","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:HandlerFunc\">func (HandlerFunc)</a> <a href=\"?m:HandlerFunc.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request)</code>\n<p>\nServeHTTP calls f(w, req).\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Header!\">Header</a></h2>\n<pre>type Header map[string][]string</pre>\n<p>\nA Header represents the key-value pairs in an HTTP header.\n</p>\n\n",name:"Header","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Header\">func (Header)</a> <a href=\"?m:Header.Add!\">Add</a></h2>\n<code>func (h Header) Add(key, value string)</code>\n<p>\nAdd adds the key, value pair to the header.\nIt appends to any existing values associated with key.\n</p>\n\n",name:"Add"},{html:"\n<h2><a class=\"black\" href=\"?m:Header\">func (Header)</a> <a href=\"?m:Header.Del!\">Del</a></h2>\n<code>func (h Header) Del(key string)</code>\n<p>\nDel deletes the values associated with key.\n</p>\n\n",name:"Del"},{html:"\n<h2><a class=\"black\" href=\"?m:Header\">func (Header)</a> <a href=\"?m:Header.Get!\">Get</a></h2>\n<code>func (h Header) Get(key string) string</code>\n<p>\nGet gets the first value associated with the given key.\nIf there are no values associated with the key, Get returns &#34;&#34;.\nGet is a convenience method.  For more complex queries,\naccess the map directly.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?m:Header\">func (Header)</a> <a href=\"?m:Header.Set!\">Set</a></h2>\n<code>func (h Header) Set(key, value string)</code>\n<p>\nSet sets the header entries associated with key to\nthe single element value.  It replaces any existing\nvalues associated with key.\n</p>\n\n",name:"Set"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Hijacker!\">Hijacker</a></h2>\n<pre>type Hijacker interface {\n\t// Hijack lets the caller take over the connection.\n\t// After a call to Hijack(), the HTTP server library\n\t// will not do anything else with the connection.\n\t// It becomes the caller&#39;s responsibility to manage\n\t// and close the connection.\n\tHijack() (net.Conn, *bufio.ReadWriter, os.Error)\n}</pre>\n<p>\nThe Hijacker interface is implemented by ResponseWriters that allow\nan HTTP handler to take over the connection.\n</p>\n\n",name:"Hijacker","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ProtocolError!\">ProtocolError</a></h2>\n<pre>type ProtocolError struct {\n\tos.ErrorString\n}</pre>\n<p>\nHTTP request parsing errors.\n</p>\n\n",name:"ProtocolError","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Request!\">Request</a></h2>\n<pre>type Request struct {\n\tMethod string // GET, POST, PUT, etc.\n\tRawURL string // The raw URL given in the request.\n\tURL    *URL   // Parsed URL.\n\n\n\t// The protocol version for incoming requests.\n\t// Outgoing requests always use HTTP/1.1.\n\tProto      string // &#34;HTTP/1.0&#34;\n\tProtoMajor int    // 1\n\tProtoMinor int    // 0\n\n\n\t// A header maps request lines to their values.\n\t// If the header says\n\t//\n\t//\taccept-encoding: gzip, deflate\n\t//\tAccept-Language: en-us\n\t//\tConnection: keep-alive\n\t//\n\t// then\n\t//\n\t//\tHeader = map[string]string{\n\t//\t\t&#34;Accept-Encoding&#34;: &#34;gzip, deflate&#34;,\n\t//\t\t&#34;Accept-Language&#34;: &#34;en-us&#34;,\n\t//\t\t&#34;Connection&#34;: &#34;keep-alive&#34;,\n\t//\t}\n\t//\n\t// HTTP defines that header names are case-insensitive.\n\t// The request parser implements this by canonicalizing the\n\t// name, making the first character and any characters\n\t// following a hyphen uppercase and the rest lowercase.\n\tHeader Header\n\n\t// Cookie records the HTTP cookies sent with the request.\n\tCookie []*Cookie\n\n\t// The message body.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content.\n\t// The value -1 indicates that the length is unknown.\n\t// Values &gt;= 0 indicate that the given number of bytes may be read from Body.\n\tContentLength int64\n\n\t// TransferEncoding lists the transfer encodings from outermost to innermost.\n\t// An empty list denotes the &#34;identity&#34; encoding.\n\tTransferEncoding []string\n\n\t// Whether to close the connection after replying to this request.\n\tClose bool\n\n\t// The host on which the URL is sought.\n\t// Per RFC 2616, this is either the value of the Host: header\n\t// or the host name given in the URL itself.\n\tHost string\n\n\t// The referring URL, if sent in the request.\n\t//\n\t// Referer is misspelled as in the request itself,\n\t// a mistake from the earliest days of HTTP.\n\t// This value can also be fetched from the Header map\n\t// as Header[&#34;Referer&#34;]; the benefit of making it\n\t// available as a structure field is that the compiler\n\t// can diagnose programs that use the alternate\n\t// (correct English) spelling req.Referrer but cannot\n\t// diagnose programs that use Header[&#34;Referrer&#34;].\n\tReferer string\n\n\t// The User-Agent: header string, if sent in the request.\n\tUserAgent string\n\n\t// The parsed form. Only available after ParseForm is called.\n\tForm map[string][]string\n\n\t// The parsed multipart form, including file uploads.\n\t// Only available after ParseMultipartForm is called.\n\tMultipartForm *multipart.Form\n\n\t// Trailer maps trailer keys to values.  Like for Header, if the\n\t// response has multiple trailer lines with the same key, they will be\n\t// concatenated, delimited by commas.\n\tTrailer Header\n\n\t// RemoteAddr allows HTTP servers and other software to record\n\t// the network address that sent the request, usually for\n\t// logging. This field is not filled in by ReadRequest and\n\t// has no defined format. The HTTP server in this package\n\t// sets RemoteAddr to an &#34;IP:port&#34; address before invoking a\n\t// handler.\n\tRemoteAddr string\n\n\t// TLS allows HTTP servers and other software to record\n\t// information about the TLS connection on which the request\n\t// was received. This field is not filled in by ReadRequest.\n\t// The HTTP server in this package sets the field for\n\t// TLS-enabled connections before invoking a handler;\n\t// otherwise it leaves the field nil.\n\tTLS *tls.ConnectionState\n}</pre>\n<p>\nA Request represents a parsed HTTP request header.\n</p>\n\n",name:"Request","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.FormFile!\">FormFile</a></h2>\n<code>func (r *Request) FormFile(key string) (multipart.File, *multipart.FileHeader, os.Error)</code>\n<p>\nFormFile returns the first file for the provided form key.\nFormFile calls ParseMultipartForm and ParseForm if necessary.\n</p>\n\n",name:"FormFile"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.FormValue!\">FormValue</a></h2>\n<code>func (r *Request) FormValue(key string) string</code>\n<p>\nFormValue returns the first value for the named component of the query.\nFormValue calls ParseMultipartForm and ParseForm if necessary.\n</p>\n\n",name:"FormValue"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.MultipartReader!\">MultipartReader</a></h2>\n<code>func (r *Request) MultipartReader() (multipart.Reader, os.Error)</code>\n<p>\nMultipartReader returns a MIME multipart reader if this is a\nmultipart/form-data POST request, else returns nil and an error.\nUse this function instead of ParseMultipartForm to\nprocess the request body as a stream.\n</p>\n\n",name:"MultipartReader"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ParseForm!\">ParseForm</a></h2>\n<code>func (r *Request) ParseForm() (err os.Error)</code>\n<p>\nParseForm parses the raw query.\nFor POST requests, it also parses the request body as a form.\nParseMultipartForm calls ParseForm automatically.\nIt is idempotent.\n</p>\n\n",name:"ParseForm"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ParseMultipartForm!\">ParseMultipartForm</a></h2>\n<code>func (r *Request) ParseMultipartForm(maxMemory int64) os.Error</code>\n<p>\nParseMultipartForm parses a request body as multipart/form-data.\nThe whole request body is parsed and up to a total of maxMemory bytes of\nits file parts are stored in memory, with the remainder stored on\ndisk in temporary files.\nParseMultipartForm calls ParseForm if necessary.\nAfter one call to ParseMultipartForm, subsequent calls have no effect.\n</p>\n\n",name:"ParseMultipartForm"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.ProtoAtLeast!\">ProtoAtLeast</a></h2>\n<code>func (r *Request) ProtoAtLeast(major, minor int) bool</code>\n<p>\nProtoAtLeast returns whether the HTTP protocol used\nin the request is at least major.minor.\n</p>\n\n",name:"ProtoAtLeast"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.Write!\">Write</a></h2>\n<code>func (req *Request) Write(w io.Writer) os.Error</code>\n<p>\nWrite writes an HTTP/1.1 request -- header and body -- in wire format.\nThis method consults the following fields of req:\n</p>\n<pre>Host\nRawURL, if non-empty, or else URL\nMethod (defaults to &#34;GET&#34;)\nUserAgent (defaults to defaultUserAgent)\nReferer\nHeader\nCookie\nContentLength\nTransferEncoding\nBody\n</pre>\n<p>\nIf Body is present but Content-Length is &lt;= 0, Write adds\n&#34;Transfer-Encoding: chunked&#34; to the header. Body is closed after\nit is sent.\n</p>\n\n",name:"Write"},{html:"\n<h2><a class=\"black\" href=\"?m:Request\">func (*Request)</a> <a href=\"?m:Request.WriteProxy!\">WriteProxy</a></h2>\n<code>func (req *Request) WriteProxy(w io.Writer) os.Error</code>\n<p>\nWriteProxy is like Write but writes the request in the form\nexpected by an HTTP proxy.  It includes the scheme and host\nname in the URI instead of using a separate Host: header line.\nIf req.RawURL is non-empty, WriteProxy uses it unchanged\ninstead of URL but still omits the Host: header.\n</p>\n\n",name:"WriteProxy"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Response!\">Response</a></h2>\n<pre>type Response struct {\n\tStatus     string // e.g. &#34;200 OK&#34;\n\tStatusCode int    // e.g. 200\n\tProto      string // e.g. &#34;HTTP/1.0&#34;\n\tProtoMajor int    // e.g. 1\n\tProtoMinor int    // e.g. 0\n\n\n\t// RequestMethod records the method used in the HTTP request.\n\t// Header fields such as Content-Length have method-specific meaning.\n\tRequestMethod string // e.g. &#34;HEAD&#34;, &#34;CONNECT&#34;, &#34;GET&#34;, etc.\n\n\n\t// Header maps header keys to values.  If the response had multiple\n\t// headers with the same key, they will be concatenated, with comma\n\t// delimiters.  (Section 4.2 of RFC 2616 requires that multiple headers\n\t// be semantically equivalent to a comma-delimited sequence.) Values\n\t// duplicated by other fields in this struct (e.g., ContentLength) are\n\t// omitted from Header.\n\t//\n\t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n\tHeader Header\n\n\t// SetCookie records the Set-Cookie requests sent with the response.\n\tSetCookie []*Cookie\n\n\t// Body represents the response body.\n\tBody io.ReadCloser\n\n\t// ContentLength records the length of the associated content.  The\n\t// value -1 indicates that the length is unknown.  Unless RequestMethod\n\t// is &#34;HEAD&#34;, values &gt;= 0 indicate that the given number of bytes may\n\t// be read from Body.\n\tContentLength int64\n\n\t// Contains transfer encodings from outer-most to inner-most. Value is\n\t// nil, means that &#34;identity&#34; encoding is used.\n\tTransferEncoding []string\n\n\t// Close records whether the header directed that the connection be\n\t// closed after reading Body.  The value is advice for clients: neither\n\t// ReadResponse nor Response.Write ever closes a connection.\n\tClose bool\n\n\t// Trailer maps trailer keys to values, in the same\n\t// format as the header.\n\tTrailer Header\n}</pre>\n<p>\nResponse represents the response from an HTTP request.\n</p>\n\n",name:"Response","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.ProtoAtLeast!\">ProtoAtLeast</a></h2>\n<code>func (r *Response) ProtoAtLeast(major, minor int) bool</code>\n<p>\nProtoAtLeast returns whether the HTTP protocol used\nin the response is at least major.minor.\n</p>\n\n",name:"ProtoAtLeast"},{html:"\n<h2><a class=\"black\" href=\"?m:Response\">func (*Response)</a> <a href=\"?m:Response.Write!\">Write</a></h2>\n<code>func (resp *Response) Write(w io.Writer) os.Error</code>\n<p>\nWrites the response (header, body and trailer) in wire format. This method\nconsults the following fields of resp:\n</p>\n<pre>StatusCode\nProtoMajor\nProtoMinor\nRequestMethod\nTransferEncoding\nTrailer\nBody\nContentLength\nHeader, values for non-canonical keys will have unpredictable behavior\n</pre>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ResponseWriter!\">ResponseWriter</a></h2>\n<pre>type ResponseWriter interface {\n\t// Header returns the header map that will be sent by WriteHeader.\n\t// Changing the header after a call to WriteHeader (or Write) has\n\t// no effect.\n\tHeader() Header\n\n\t// Write writes the data to the connection as part of an HTTP reply.\n\t// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n\t// before writing the data.\n\tWrite([]byte) (int, os.Error)\n\n\t// WriteHeader sends an HTTP response header with status code.\n\t// If WriteHeader is not called explicitly, the first call to Write\n\t// will trigger an implicit WriteHeader(http.StatusOK).\n\t// Thus explicit calls to WriteHeader are mainly used to\n\t// send error codes.\n\tWriteHeader(int)\n}</pre>\n<p>\nA ResponseWriter interface is used by an HTTP handler to\nconstruct an HTTP response.\n</p>\n\n",name:"ResponseWriter","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ReverseProxy!\">ReverseProxy</a></h2>\n<pre>type ReverseProxy struct {\n\t// Director must be a function which modifies\n\t// the request into a new request to be sent\n\t// using Transport. Its response is then copied\n\t// back to the original client unmodified.\n\tDirector func(*Request)\n\n\t// The Transport used to perform proxy requests.\n\t// If nil, DefaultTransport is used.\n\tTransport RoundTripper\n}</pre>\n<p>\nReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n</p>\n\n",name:"ReverseProxy","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ReverseProxy\">func (*ReverseProxy)</a> <a href=\"?m:ReverseProxy.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (p *ReverseProxy) ServeHTTP(rw ResponseWriter, req *Request)</code>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RoundTripper!\">RoundTripper</a></h2>\n<pre>type RoundTripper interface {\n\t// RoundTrip executes a single HTTP transaction, returning\n\t// the Response for the request req.  RoundTrip should not\n\t// attempt to interpret the response.  In particular,\n\t// RoundTrip must return err == nil if it obtained a response,\n\t// regardless of the response&#39;s HTTP status code.  A non-nil\n\t// err should be reserved for failure to obtain a response.\n\t// Similarly, RoundTrip should not attempt to handle\n\t// higher-level protocol details such as redirects,\n\t// authentication, or cookies.\n\t//\n\t// RoundTrip may modify the request. The request Headers field is\n\t// guaranteed to be initialized.\n\tRoundTrip(req *Request) (resp *Response, err os.Error)\n}</pre>\n<p>\nRoundTripper is an interface representing the ability to execute a\nsingle HTTP transaction, obtaining the Response for a given Request.\n</p>\n\n",name:"RoundTripper","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServeMux!\">ServeMux</a></h2>\n<pre>type ServeMux struct {\n\t// contains unexported fields\n}</pre>\n<p>\nServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n</p>\n<p>\nPatterns named fixed, rooted paths, like &#34;/favicon.ico&#34;,\nor rooted subtrees, like &#34;/images/&#34; (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both &#34;/images/&#34;\nand &#34;/images/thumbnails/&#34;, the latter handler will be\ncalled for paths beginning &#34;/images/thumbnails/&#34; and the\nformer will receiver requests for any other paths in the\n&#34;/images/&#34; subtree.\n</p>\n<p>\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only.  Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n&#34;/codesearch&#34; and &#34;codesearch.google.com/&#34; without also taking over\nrequests for &#34;<a href=\"http://www.google.com/\">http://www.google.com/</a>&#34;.\n</p>\n<p>\nServeMux also takes care of sanitizing the URL request path,\nredirecting any request containing . or .. elements to an\nequivalent .- and ..-free URL.\n</p>\n\n",name:"ServeMux","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.Handle!\">Handle</a></h2>\n<code>func (mux *ServeMux) Handle(pattern string, handler Handler)</code>\n<p>\nHandle registers the handler for the given pattern.\n</p>\n\n",name:"Handle"},{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.HandleFunc!\">HandleFunc</a></h2>\n<code>func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\n<p>\nHandleFunc registers the handler function for the given pattern.\n</p>\n\n",name:"HandleFunc"},{html:"\n<h2><a class=\"black\" href=\"?m:ServeMux\">func (*ServeMux)</a> <a href=\"?m:ServeMux.ServeHTTP!\">ServeHTTP</a></h2>\n<code>func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request)</code>\n<p>\nServeHTTP dispatches the request to the handler whose\npattern most closely matches the request URL.\n</p>\n\n",name:"ServeHTTP"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Server!\">Server</a></h2>\n<pre>type Server struct {\n\tAddr         string  // TCP address to listen on, &#34;:http&#34; if empty\n\tHandler      Handler // handler to invoke, http.DefaultServeMux if nil\n\tReadTimeout  int64   // the net.Conn.SetReadTimeout value for new connections\n\tWriteTimeout int64   // the net.Conn.SetWriteTimeout value for new connections\n}</pre>\n<p>\nA Server defines parameters for running an HTTP server.\n</p>\n\n",name:"Server","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.ListenAndServe!\">ListenAndServe</a></h2>\n<code>func (srv *Server) ListenAndServe() os.Error</code>\n<p>\nListenAndServe listens on the TCP network address srv.Addr and then\ncalls Serve to handle requests on incoming connections.  If\nsrv.Addr is blank, &#34;:http&#34; is used.\n</p>\n\n",name:"ListenAndServe"},{html:"\n<h2><a class=\"black\" href=\"?m:Server\">func (*Server)</a> <a href=\"?m:Server.Serve!\">Serve</a></h2>\n<code>func (srv *Server) Serve(l net.Listener) os.Error</code>\n<p>\nServe accepts incoming connections on the Listener l, creating a\nnew service thread for each.  The service threads read requests and\nthen call srv.Handler to reply to them.\n</p>\n\n",name:"Serve"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerConn!\">ServerConn</a></h2>\n<pre>type ServerConn struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA ServerConn reads requests and sends responses over an underlying\nconnection, until the HTTP keepalive logic commands an end. ServerConn\nalso allows hijacking the underlying connection by calling Hijack\nto regain control over the connection. ServerConn supports pipe-lining,\ni.e. requests can be read out of sync (but in the same order) while the\nrespective responses are sent.\n</p>\n\n",name:"ServerConn","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Close!\">Close</a></h2>\n<code>func (sc *ServerConn) Close() os.Error</code>\n<p>\nClose calls Hijack and then also closes the underlying connection\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Hijack!\">Hijack</a></h2>\n<code>func (sc *ServerConn) Hijack() (c net.Conn, r *bufio.Reader)</code>\n<p>\nHijack detaches the ServerConn and returns the underlying connection as well\nas the read-side bufio which may have some left over data. Hijack may be\ncalled before Read has signaled the end of the keep-alive logic. The user\nshould not call Hijack while Read or Write is in progress.\n</p>\n\n",name:"Hijack"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Pending!\">Pending</a></h2>\n<code>func (sc *ServerConn) Pending() int</code>\n<p>\nPending returns the number of unanswered requests\nthat have been received on the connection.\n</p>\n\n",name:"Pending"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Read!\">Read</a></h2>\n<code>func (sc *ServerConn) Read() (req *Request, err os.Error)</code>\n<p>\nRead returns the next request on the wire. An ErrPersistEOF is returned if\nit is gracefully determined that there are no more requests (e.g. after the\nfirst request on an HTTP/1.0 connection, or after a Connection:close on a\nHTTP/1.1 connection).\n</p>\n\n",name:"Read"},{html:"\n<h2><a class=\"black\" href=\"?m:ServerConn\">func (*ServerConn)</a> <a href=\"?m:ServerConn.Write!\">Write</a></h2>\n<code>func (sc *ServerConn) Write(req *Request, resp *Response) os.Error</code>\n<p>\nWrite writes resp in response to req. To close the connection gracefully, set the\nResponse.Close field to true. Write should be considered operational until\nit returns an error, regardless of any errors returned on the Read side.\n</p>\n\n",name:"Write"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Transport!\">Transport</a></h2>\n<pre>type Transport struct {\n\tIgnoreEnvironment  bool // don&#39;t look at environment variables for proxy configuration\n\tDisableKeepAlives  bool\n\tDisableCompression bool\n\n\t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n\t// (keep-alive) to keep to keep per-host.  If zero,\n\t// DefaultMaxIdleConnsPerHost is used.\n\tMaxIdleConnsPerHost int\n\t// contains unexported fields\n}</pre>\n<p>\nTransport is an implementation of RoundTripper that supports http,\nhttps, and http proxies (for either http or https with CONNECT).\nTransport can also cache connections for future re-use.\n</p>\n\n",name:"Transport","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Transport\">func (*Transport)</a> <a href=\"?m:Transport.CloseIdleConnections!\">CloseIdleConnections</a></h2>\n<code>func (t *Transport) CloseIdleConnections()</code>\n<p>\nCloseIdleConnections closes any connections which were previously\nconnected from previous requests but are now sitting idle in\na &#34;keep-alive&#34; state. It does not interrupt any connections currently\nin use.\n</p>\n\n",name:"CloseIdleConnections"},{html:"\n<h2><a class=\"black\" href=\"?m:Transport\">func (*Transport)</a> <a href=\"?m:Transport.RoundTrip!\">RoundTrip</a></h2>\n<code>func (t *Transport) RoundTrip(req *Request) (resp *Response, err os.Error)</code>\n<p>\nRoundTrip implements the RoundTripper interface.\n</p>\n\n",name:"RoundTrip"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URL!\">URL</a></h2>\n<pre>type URL struct {\n\tRaw          string // the original string\n\tScheme       string // scheme\n\tRawAuthority string // [userinfo@]host\n\tRawUserinfo  string // userinfo\n\tHost         string // host\n\tRawPath      string // /path[?query][#fragment]\n\tPath         string // /path\n\tOpaquePath   bool   // path is opaque (unrooted when scheme is present)\n\tRawQuery     string // query\n\tFragment     string // fragment\n}</pre>\n<p>\nA URL represents a parsed URL (technically, a URI reference).\nThe general form represented is:\n</p>\n<pre>scheme://[userinfo@]host/path[?query][#fragment]\n</pre>\n<p>\nThe Raw, RawAuthority, RawPath, and RawQuery fields are in &#34;wire format&#34;\n(special characters must be hex-escaped if not meant to have special meaning).\nAll other fields are logical values; &#39;+&#39; or &#39;%&#39; represent themselves.\n</p>\n<p>\nThe various Raw values are supplied in wire format because\nclients typically have to split them into pieces before further\ndecoding.\n</p>\n\n",name:"URL","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.IsAbs!\">IsAbs</a></h2>\n<code>func (url *URL) IsAbs() bool</code>\n<p>\nIsAbs returns true if the URL is absolute.\n</p>\n\n",name:"IsAbs"},{html:"\n<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.ParseURL!\">ParseURL</a></h2>\n<code>func (base *URL) ParseURL(ref string) (*URL, os.Error)</code>\n<p>\nParseURL parses a URL in the context of a base URL.  The URL in ref\nmay be relative or absolute.  ParseURL returns nil, err on parse\nfailure, otherwise its return value is the same as ResolveReference.\n</p>\n\n",name:"ParseURL"},{html:"\n<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.ResolveReference!\">ResolveReference</a></h2>\n<code>func (base *URL) ResolveReference(ref *URL) *URL</code>\n<p>\nResolveReference resolves a URI reference to an absolute URI from\nan absolute base URI, per RFC 2396 Section 5.2.  The URI reference\nmay be relative or absolute.  ResolveReference always returns a new\nURL instance, even if the returned URL is identical to either the\nbase or reference. If ref is an absolute URL, then ResolveReference\nignores base and returns a copy of ref.\n</p>\n\n",name:"ResolveReference"},{html:"\n<h2><a class=\"black\" href=\"?m:URL\">func (*URL)</a> <a href=\"?m:URL.String!\">String</a></h2>\n<code>func (url *URL) String() string</code>\n<p>\nString reassembles url into a valid URL string.\n</p>\n<p>\nThere are redundant fields stored in the URL structure:\nthe String method consults Scheme, Path, Host, RawUserinfo,\nRawQuery, and Fragment, but not Raw, RawPath or Authority.\n</p>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLError!\">URLError</a></h2>\n<pre>type URLError struct {\n\tOp    string\n\tURL   string\n\tError os.Error\n}</pre>\n<p>\nURLError reports an error and the operation and URL that caused it.\n</p>\n\n",name:"URLError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URLError\">func (*URLError)</a> <a href=\"?m:URLError.String!\">String</a></h2>\n<code>func (e *URLError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:URLEscapeError!\">URLEscapeError</a></h2>\n<pre>type URLEscapeError string</pre>\n\n",name:"URLEscapeError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:URLEscapeError\">func (URLEscapeError)</a> <a href=\"?m:URLEscapeError.String!\">String</a></h2>\n<code>func (e URLEscapeError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:CanonicalHeaderKey!\">CanonicalHeaderKey</a></h2>\n<code>func CanonicalHeaderKey(s string) string</code>\n<p>\nCanonicalHeaderKey returns the canonical format of the\nheader key s.  The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase.  For example, the\ncanonical key for &#34;accept-encoding&#34; is &#34;Accept-Encoding&#34;.\n</p>\n\n",name:"CanonicalHeaderKey"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpRequest!\">DumpRequest</a></h2>\n<code>func DumpRequest(req *Request, body bool) (dump []byte, err os.Error)</code>\n<p>\nDumpRequest returns the wire representation of req,\noptionally including the request body, for debugging.\nDumpRequest is semantically a no-op, but in order to\ndump the body, it reads the body data into memory and\nchanges req.Body to refer to the in-memory copy.\nThe documentation for Request.Write details which fields\nof req are used.\n</p>\n\n",name:"DumpRequest"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:DumpResponse!\">DumpResponse</a></h2>\n<code>func DumpResponse(resp *Response, body bool) (dump []byte, err os.Error)</code>\n<p>\nDumpResponse is like DumpRequest but dumps a response.\n</p>\n\n",name:"DumpResponse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EncodeQuery!\">EncodeQuery</a></h2>\n<code>func EncodeQuery(m map[string][]string) string</code>\n<p>\nEncodeQuery encodes the query represented as a multimap.\n</p>\n\n",name:"EncodeQuery"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Error!\">Error</a></h2>\n<code>func Error(w ResponseWriter, error string, code int)</code>\n<p>\nError replies to the request with the specified error message and HTTP code.\n</p>\n\n",name:"Error"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:EscapeUserinfo!\">EscapeUserinfo</a></h2>\n<code>func EscapeUserinfo(user, password string) string</code>\n<p>\nEscapeUserinfo combines user and password in the form\nuser:password (or just user if password is empty) and then\nescapes it for use as the URL.RawUserinfo field.\n</p>\n<p>\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n&ldquo;is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.&rdquo;\n</p>\n\n",name:"EscapeUserinfo"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:FileServer!\">FileServer</a></h2>\n<code>func FileServer(root, prefix string) Handler</code>\n<p>\nFileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\nIt strips prefix from the incoming requests before\nlooking up the file name in the file system.\n</p>\n\n",name:"FileServer"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Get!\">Get</a></h2>\n<code>func Get(url string) (r *Response, finalURL string, err os.Error)</code>\n<p>\nGet issues a GET to the specified URL.  If the response is one of the following\nredirect codes, Get follows the redirect, up to a maximum of 10 redirects:\n</p>\n<pre>301 (Moved Permanently)\n302 (Found)\n303 (See Other)\n307 (Temporary Redirect)\n</pre>\n<p>\nfinalURL is the URL from which the response was fetched -- identical to the\ninput URL unless redirects were followed.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n<p>\nGet is a convenience wrapper around DefaultClient.Get.\n</p>\n\n",name:"Get"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Handle!\">Handle</a></h2>\n<code>func Handle(pattern string, handler Handler)</code>\n<p>\nHandle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n</p>\n\n",name:"Handle"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HandleFunc!\">HandleFunc</a></h2>\n<code>func HandleFunc(pattern string, handler func(ResponseWriter, *Request))</code>\n<p>\nHandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n</p>\n\n",name:"HandleFunc"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Head!\">Head</a></h2>\n<code>func Head(url string) (r *Response, err os.Error)</code>\n<p>\nHead issues a HEAD to the specified URL.\n</p>\n<p>\nHead is a wrapper around DefaultClient.Head\n</p>\n\n",name:"Head"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServe!\">ListenAndServe</a></h2>\n<code>func ListenAndServe(addr string, handler Handler) os.Error</code>\n<p>\nListenAndServe listens on the TCP network address addr\nand then calls Serve with handler to handle requests\non incoming connections.  Handler is typically nil,\nin which case the DefaultServeMux is used.\n</p>\n<p>\nA trivial example server is:\n</p>\n<pre>package main\n\nimport (\n\t&#34;http&#34;\n\t&#34;io&#34;\n\t&#34;log&#34;\n)\n\n// hello world, the web server\nfunc HelloServer(w http.ResponseWriter, req *http.Request) {\n\tio.WriteString(w, &#34;hello, world!\\n&#34;)\n}\n\nfunc main() {\n\thttp.HandleFunc(&#34;/hello&#34;, HelloServer)\n\terr := http.ListenAndServe(&#34;:12345&#34;, nil)\n\tif err != nil {\n\t\tlog.Fatal(&#34;ListenAndServe: &#34;, err.String())\n\t}\n}\n</pre>\n\n",name:"ListenAndServe"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ListenAndServeTLS!\">ListenAndServeTLS</a></h2>\n<code>func ListenAndServeTLS(addr string, certFile string, keyFile string, handler Handler) os.Error</code>\n<p>\nListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided.\n</p>\n<p>\nA trivial example server is:\n</p>\n<pre>import (\n\t&#34;http&#34;\n\t&#34;log&#34;\n)\n\nfunc handler(w http.ResponseWriter, req *http.Request) {\n\tw.Header().Set(&#34;Content-Type&#34;, &#34;text/plain&#34;)\n\tw.Write([]byte(&#34;This is an example server.\\n&#34;))\n}\n\nfunc main() {\n\thttp.HandleFunc(&#34;/&#34;, handler)\n\tlog.Printf(&#34;About to listen on 10443. Go to <a href=\"https://127.0.0.1:10443/\">https://127.0.0.1:10443/</a>&#34;)\n\terr := http.ListenAndServeTLS(&#34;:10443&#34;, &#34;cert.pem&#34;, &#34;key.pem&#34;, nil)\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n}\n</pre>\n<p>\nOne can use generate_cert.go in crypto/tls to generate cert.pem and key.pem.\n</p>\n\n",name:"ListenAndServeTLS"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewChunkedWriter!\">NewChunkedWriter</a></h2>\n<code>func NewChunkedWriter(w io.Writer) io.WriteCloser</code>\n<p>\nNewChunkedWriter returns a new writer that translates writes into HTTP\n&#34;chunked&#34; format before writing them to w.  Closing the returned writer\nsends the final 0-length chunk that marks the end of the stream.\n</p>\n\n",name:"NewChunkedWriter"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClientConn!\">NewClientConn</a></h2>\n<code>func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn</code>\n<p>\nNewClientConn returns a new ClientConn reading and writing c.  If r is not\nnil, it is the buffer to use when reading c.\n</p>\n\n",name:"NewClientConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewProxyClientConn!\">NewProxyClientConn</a></h2>\n<code>func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn</code>\n<p>\nNewProxyClientConn works like NewClientConn but writes Requests\nusing Request&#39;s WriteProxy method.\n</p>\n\n",name:"NewProxyClientConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewRequest!\">NewRequest</a></h2>\n<code>func NewRequest(method, url string, body io.Reader) (*Request, os.Error)</code>\n<p>\nNewRequest returns a new Request given a method, URL, and optional body.\n</p>\n\n",name:"NewRequest"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServeMux!\">NewServeMux</a></h2>\n<code>func NewServeMux() *ServeMux</code>\n<p>\nNewServeMux allocates and returns a new ServeMux.\n</p>\n\n",name:"NewServeMux"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewServerConn!\">NewServerConn</a></h2>\n<code>func NewServerConn(c net.Conn, r *bufio.Reader) *ServerConn</code>\n<p>\nNewServerConn returns a new ServerConn reading and writing c.  If r is not\nnil, it is the buffer to use when reading c.\n</p>\n\n",name:"NewServerConn"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewSingleHostReverseProxy!\">NewSingleHostReverseProxy</a></h2>\n<code>func NewSingleHostReverseProxy(target *URL) *ReverseProxy</code>\n<p>\nNewSingleHostReverseProxy returns a new ReverseProxy that rewrites\nURLs to the scheme, host, and base path provided in target. If the\ntarget&#39;s path is &#34;/base&#34; and the incoming request was for &#34;/dir&#34;,\nthe target request will be for /base/dir.\n</p>\n\n",name:"NewSingleHostReverseProxy"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFound!\">NotFound</a></h2>\n<code>func NotFound(w ResponseWriter, r *Request)</code>\n<p>\nNotFound replies to the request with an HTTP 404 not found error.\n</p>\n\n",name:"NotFound"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NotFoundHandler!\">NotFoundHandler</a></h2>\n<code>func NotFoundHandler() Handler</code>\n<p>\nNotFoundHandler returns a simple request handler\nthat replies to each request with a &ldquo;404 page not found&rdquo; reply.\n</p>\n\n",name:"NotFoundHandler"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseHTTPVersion!\">ParseHTTPVersion</a></h2>\n<code>func ParseHTTPVersion(vers string) (major, minor int, ok bool)</code>\n<p>\nParseHTTPVersion parses a HTTP version string.\n&#34;HTTP/1.0&#34; returns (1, 0, true).\n</p>\n\n",name:"ParseHTTPVersion"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseQuery!\">ParseQuery</a></h2>\n<code>func ParseQuery(query string) (m map[string][]string, err os.Error)</code>\n<p>\nParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n</p>\n\n",name:"ParseQuery"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseRequestURL!\">ParseRequestURL</a></h2>\n<code>func ParseRequestURL(rawurl string) (url *URL, err os.Error)</code>\n<p>\nParseRequestURL parses rawurl into a URL structure.  It assumes that\nrawurl was received from an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n</p>\n\n",name:"ParseRequestURL"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURL!\">ParseURL</a></h2>\n<code>func ParseURL(rawurl string) (url *URL, err os.Error)</code>\n<p>\nParseURL parses rawurl into a URL structure.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\nThe rawurl may be relative or absolute.\n</p>\n\n",name:"ParseURL"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseURLReference!\">ParseURLReference</a></h2>\n<code>func ParseURLReference(rawurlref string) (url *URL, err os.Error)</code>\n<p>\nParseURLReference is like ParseURL but allows a trailing #fragment.\n</p>\n\n",name:"ParseURLReference"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Post!\">Post</a></h2>\n<code>func Post(url string, bodyType string, body io.Reader) (r *Response, err os.Error)</code>\n<p>\nPost issues a POST to the specified URL.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n<p>\nPost is a wrapper around DefaultClient.Post\n</p>\n\n",name:"Post"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PostForm!\">PostForm</a></h2>\n<code>func PostForm(url string, data map[string]string) (r *Response, err os.Error)</code>\n<p>\nPostForm issues a POST to the specified URL,\nwith data&#39;s keys and values urlencoded as the request body.\n</p>\n<p>\nCaller should close r.Body when done reading from it.\n</p>\n<p>\nPostForm is a wrapper around DefaultClient.PostForm\n</p>\n\n",name:"PostForm"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadRequest!\">ReadRequest</a></h2>\n<code>func ReadRequest(b *bufio.Reader) (req *Request, err os.Error)</code>\n<p>\nReadRequest reads and parses a request from b.\n</p>\n\n",name:"ReadRequest"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ReadResponse!\">ReadResponse</a></h2>\n<code>func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error)</code>\n<p>\nReadResponse reads and returns an HTTP response from r.  The RequestMethod\nparameter specifies the method used in the corresponding request (e.g.,\n&#34;GET&#34;, &#34;HEAD&#34;).  Clients must call resp.Body.Close when finished reading\nresp.Body.  After that call, clients can inspect resp.Trailer to find\nkey/value pairs included in the response trailer.\n</p>\n\n",name:"ReadResponse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Redirect!\">Redirect</a></h2>\n<code>func Redirect(w ResponseWriter, r *Request, url string, code int)</code>\n<p>\nRedirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n</p>\n\n",name:"Redirect"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RedirectHandler!\">RedirectHandler</a></h2>\n<code>func RedirectHandler(url string, code int) Handler</code>\n<p>\nRedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n</p>\n\n",name:"RedirectHandler"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Serve!\">Serve</a></h2>\n<code>func Serve(l net.Listener, handler Handler) os.Error</code>\n<p>\nServe accepts incoming HTTP connections on the listener l,\ncreating a new service thread for each.  The service threads\nread requests and then call handler to reply to them.\nHandler is typically nil, in which case the DefaultServeMux is used.\n</p>\n\n",name:"Serve"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ServeFile!\">ServeFile</a></h2>\n<code>func ServeFile(w ResponseWriter, r *Request, name string)</code>\n<p>\nServeFile replies to the request with the contents of the named file or directory.\n</p>\n\n",name:"ServeFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:StatusText!\">StatusText</a></h2>\n<code>func StatusText(code int) string</code>\n<p>\nStatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n</p>\n\n",name:"StatusText"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TimeoutHandler!\">TimeoutHandler</a></h2>\n<code>func TimeoutHandler(h Handler, ns int64, msg string) Handler</code>\n<p>\nTimeoutHandler returns a Handler that runs h with the given time limit.\n</p>\n<p>\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for more than ns nanoseconds, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n</p>\n\n",name:"TimeoutHandler"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLEscape!\">URLEscape</a></h2>\n<code>func URLEscape(s string) string</code>\n<p>\nURLEscape converts a string into &ldquo;URL encoded&rdquo; form.\nDespite the name, this encoding applies only to individual\ncomponents of the query portion of the URL.\n</p>\n\n",name:"URLEscape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:URLUnescape!\">URLUnescape</a></h2>\n<code>func URLUnescape(s string) (string, os.Error)</code>\n<p>\nURLUnescape unescapes a string in &ldquo;URL encoded&rdquo; form,\nconverting %AB into the byte 0xAB and &#39;+&#39; into &#39; &#39; (space).\nIt returns an error if any % is not followed\nby two hexadecimal digits.\nDespite the name, this encoding applies only to individual\ncomponents of the query portion of the URL.\n</p>\n\n",name:"URLUnescape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:UnescapeUserinfo!\">UnescapeUserinfo</a></h2>\n<code>func UnescapeUserinfo(rawUserinfo string) (user, password string, err os.Error)</code>\n<p>\nUnescapeUserinfo parses the RawUserinfo field of a URL\nas the form user or user:password and unescapes and returns\nthe two halves.\n</p>\n<p>\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n&ldquo;is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.&rdquo;\n</p>\n\n",name:"UnescapeUserinfo"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:TimeFormat!\">TimeFormat</a></h2>\n<pre>const TimeFormat = &#34;Mon, 02 Jan 2006 15:04:05 GMT&#34;</pre>\n<p>\nTimeFormat is the time format to use with\ntime.Parse and time.Time.Format when parsing\nor generating times in HTTP headers.\nIt is like time.RFC1123 but hard codes GMT as the time zone.\n</p>\n\n",names:["TimeFormat"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:StatusContinue!\"><em>group</em></a></h2>\n<pre>const (\n\tStatusContinue           = 100\n\tStatusSwitchingProtocols = 101\n\n\tStatusOK                   = 200\n\tStatusCreated              = 201\n\tStatusAccepted             = 202\n\tStatusNonAuthoritativeInfo = 203\n\tStatusNoContent            = 204\n\tStatusResetContent         = 205\n\tStatusPartialContent       = 206\n\n\tStatusMultipleChoices   = 300\n\tStatusMovedPermanently  = 301\n\tStatusFound             = 302\n\tStatusSeeOther          = 303\n\tStatusNotModified       = 304\n\tStatusUseProxy          = 305\n\tStatusTemporaryRedirect = 307\n\n\tStatusBadRequest                   = 400\n\tStatusUnauthorized                 = 401\n\tStatusPaymentRequired              = 402\n\tStatusForbidden                    = 403\n\tStatusNotFound                     = 404\n\tStatusMethodNotAllowed             = 405\n\tStatusNotAcceptable                = 406\n\tStatusProxyAuthRequired            = 407\n\tStatusRequestTimeout               = 408\n\tStatusConflict                     = 409\n\tStatusGone                         = 410\n\tStatusLengthRequired               = 411\n\tStatusPreconditionFailed           = 412\n\tStatusRequestEntityTooLarge        = 413\n\tStatusRequestURITooLong            = 414\n\tStatusUnsupportedMediaType         = 415\n\tStatusRequestedRangeNotSatisfiable = 416\n\tStatusExpectationFailed            = 417\n\n\tStatusInternalServerError     = 500\n\tStatusNotImplemented          = 501\n\tStatusBadGateway              = 502\n\tStatusServiceUnavailable      = 503\n\tStatusGatewayTimeout          = 504\n\tStatusHTTPVersionNotSupported = 505\n)</pre>\n<p>\nHTTP status codes, defined in RFC 2616.\n</p>\n\n",names:["StatusContinue","StatusSwitchingProtocols","StatusOK","StatusCreated","StatusAccepted","StatusNonAuthoritativeInfo","StatusNoContent","StatusResetContent","StatusPartialContent","StatusMultipleChoices","StatusMovedPermanently","StatusFound","StatusSeeOther","StatusNotModified","StatusUseProxy","StatusTemporaryRedirect","StatusBadRequest","StatusUnauthorized","StatusPaymentRequired","StatusForbidden","StatusNotFound","StatusMethodNotAllowed","StatusNotAcceptable","StatusProxyAuthRequired","StatusRequestTimeout","StatusConflict","StatusGone","StatusLengthRequired","StatusPreconditionFailed","StatusRequestEntityTooLarge","StatusRequestURITooLong","StatusUnsupportedMediaType","StatusRequestedRangeNotSatisfiable","StatusExpectationFailed","StatusInternalServerError","StatusNotImplemented","StatusBadGateway","StatusServiceUnavailable","StatusGatewayTimeout","StatusHTTPVersionNotSupported"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DefaultMaxIdleConnsPerHost!\">DefaultMaxIdleConnsPerHost</a></h2>\n<pre>const DefaultMaxIdleConnsPerHost = 2</pre>\n<p>\nDefaultMaxIdleConnsPerHost is the default value of Transport&#39;s\nMaxIdleConnsPerHost.\n</p>\n\n",names:["DefaultMaxIdleConnsPerHost"],type:""}],vars:[{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrMissingFile!\">ErrMissingFile</a></h2>\n<pre>var ErrMissingFile = os.ErrorString(&#34;http: no such file&#34;)</pre>\n<p>\nErrMissingFile is returned by FormFile when the provided file field name\nis either not present in the request or not a file field.\n</p>\n\n",names:["ErrMissingFile"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrLineTooLong!\"><em>group</em></a></h2>\n<pre>var (\n\tErrLineTooLong          = &amp;ProtocolError{&#34;header line too long&#34;}\n\tErrHeaderTooLong        = &amp;ProtocolError{&#34;header too long&#34;}\n\tErrShortBody            = &amp;ProtocolError{&#34;entity body too short&#34;}\n\tErrNotSupported         = &amp;ProtocolError{&#34;feature not supported&#34;}\n\tErrUnexpectedTrailer    = &amp;ProtocolError{&#34;trailer header without chunked transfer encoding&#34;}\n\tErrMissingContentLength = &amp;ProtocolError{&#34;missing ContentLength in HEAD response&#34;}\n\tErrNotMultipart         = &amp;ProtocolError{&#34;request Content-Type isn&#39;t multipart/form-data&#34;}\n\tErrMissingBoundary      = &amp;ProtocolError{&#34;no multipart boundary param Content-Type&#34;}\n)</pre>\n\n",names:["ErrLineTooLong","ErrHeaderTooLong","ErrShortBody","ErrNotSupported","ErrUnexpectedTrailer","ErrMissingContentLength","ErrNotMultipart","ErrMissingBoundary"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrWriteAfterFlush!\"><em>group</em></a></h2>\n<pre>var (\n\tErrWriteAfterFlush = os.NewError(&#34;Conn.Write called after Flush&#34;)\n\tErrBodyNotAllowed  = os.NewError(&#34;http: response status code does not allow body&#34;)\n\tErrHijacked        = os.NewError(&#34;Conn has been hijacked&#34;)\n\tErrContentLength   = os.NewError(&#34;Conn.Write wrote more than the declared Content-Length&#34;)\n)</pre>\n<p>\nErrors introduced by the HTTP server.\n</p>\n\n",names:["ErrWriteAfterFlush","ErrBodyNotAllowed","ErrHijacked","ErrContentLength"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultServeMux!\">DefaultServeMux</a></h2>\n<pre>var DefaultServeMux = NewServeMux()</pre>\n<p>\nDefaultServeMux is the default ServeMux used by Serve.\n</p>\n\n",names:["DefaultServeMux"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrHandlerTimeout!\">ErrHandlerTimeout</a></h2>\n<pre>var ErrHandlerTimeout = os.NewError(&#34;http: Handler timeout&#34;)</pre>\n<p>\nErrHandlerTimeout is returned on ResponseWriter Write calls\nin handlers which have timed out.\n</p>\n\n",names:["ErrHandlerTimeout"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultClient!\">DefaultClient</a></h2>\n<pre>var DefaultClient = &amp;Client{}</pre>\n<p>\nDefaultClient is the default Client and is used by Get, Head, and Post.\n</p>\n\n",names:["DefaultClient"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:ErrPersistEOF!\"><em>group</em></a></h2>\n<pre>var (\n\tErrPersistEOF = &amp;ProtocolError{&#34;persistent connection closed&#34;}\n\tErrPipeline   = &amp;ProtocolError{&#34;pipeline error&#34;}\n)</pre>\n\n",names:["ErrPersistEOF","ErrPipeline"],type:""},{html:"\n<h2><a class=\"black\" href=\"?v:\">var</a> <a href=\"?v:DefaultTransport!\">DefaultTransport</a></h2>\n<pre>var DefaultTransport RoundTripper = &amp;Transport{}</pre>\n<p>\nDefaultTransport is the default implementation of Transport and is\nused by DefaultClient.  It establishes a new network connection for\neach call to Do and uses HTTP proxies as directed by the\n$HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy)\nenvironment variables.\n</p>\n\n",names:["DefaultTransport"],type:""}]}