var gortfmData = {index:"index.html",html:"<p>\nPackage smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.\nIt also implements the following extensions:\n</p>\n<pre>8BITMIME  RFC 1652\nAUTH      RFC 2554\nSTARTTLS  RFC 3207\n</pre>\n<p>\nAdditional extensions may be handled by clients.\n</p>\n",name:"smtp",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Auth!\">Auth</a></h2>\n<pre>type Auth interface {\n\t// Start begins an authentication with a server.\n\t// It returns the name of the authentication protocol\n\t// and optionally data to include in the initial AUTH message\n\t// sent to the server. It can return proto == &#34;&#34; to indicate\n\t// that the authentication should be skipped.\n\t// If it returns a non-nil os.Error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tStart(server *ServerInfo) (proto string, toServer []byte, err os.Error)\n\n\t// Next continues the authentication. The server has just sent\n\t// the fromServer data. If more is true, the server expects a\n\t// response, which Next should return as toServer; otherwise\n\t// Next should return toServer == nil.\n\t// If Next returns a non-nil os.Error, the SMTP client aborts\n\t// the authentication attempt and closes the connection.\n\tNext(fromServer []byte, more bool) (toServer []byte, err os.Error)\n}</pre>\n<p>\nAuth is implemented by an SMTP authentication mechanism.\n</p>\n\n",name:"Auth","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Client!\">Client</a></h2>\n<pre>type Client struct {\n\t// Text is the textproto.Conn used by the Client. It is exported to allow for\n\t// clients to add extensions.\n\tText *textproto.Conn\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA Client represents a client connection to an SMTP server.\n</p>\n\n",name:"Client","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Auth!\">Auth</a></h2>\n<code>func (c *Client) Auth(a Auth) os.Error</code>\n<p>\nAuth authenticates a client using the provided authentication mechanism.\nA failed authentication closes the connection.\nOnly servers that advertise the AUTH extension support this function.\n</p>\n\n",name:"Auth"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Data!\">Data</a></h2>\n<code>func (c *Client) Data() (io.WriteCloser, os.Error)</code>\n<p>\nData issues a DATA command to the server and returns a writer that\ncan be used to write the data. The caller should close the writer\nbefore calling any more methods on c.\nA call to Data must be preceded by one or more calls to Rcpt.\n</p>\n\n",name:"Data"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Extension!\">Extension</a></h2>\n<code>func (c *Client) Extension(ext string) (bool, string)</code>\n<p>\nExtension reports whether an extension is support by the server.\nThe extension name is case-insensitive. If the extension is supported,\nExtension also returns a string that contains any parameters the\nserver specifies for the extension.\n</p>\n\n",name:"Extension"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Mail!\">Mail</a></h2>\n<code>func (c *Client) Mail(from string) os.Error</code>\n<p>\nMail issues a MAIL command to the server using the provided email address.\nIf the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME\nparameter.\nThis initiates a mail transaction and is followed by one or more Rcpt calls.\n</p>\n\n",name:"Mail"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Quit!\">Quit</a></h2>\n<code>func (c *Client) Quit() os.Error</code>\n<p>\nQuit sends the QUIT command and closes the connection to the server.\n</p>\n\n",name:"Quit"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Rcpt!\">Rcpt</a></h2>\n<code>func (c *Client) Rcpt(to string) os.Error</code>\n<p>\nRcpt issues a RCPT command to the server using the provided email address.\nA call to Rcpt must be preceded by a call to Mail and may be followed by\na Data call or another Rcpt call.\n</p>\n\n",name:"Rcpt"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Reset!\">Reset</a></h2>\n<code>func (c *Client) Reset() os.Error</code>\n<p>\nReset sends the RSET command to the server, aborting the current mail\ntransaction.\n</p>\n\n",name:"Reset"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.StartTLS!\">StartTLS</a></h2>\n<code>func (c *Client) StartTLS(config *tls.Config) os.Error</code>\n<p>\nStartTLS sends the STARTTLS command and encrypts all further communication.\nOnly servers that advertise the STARTTLS extension support this function.\n</p>\n\n",name:"StartTLS"},{html:"\n<h2><a class=\"black\" href=\"?m:Client\">func (*Client)</a> <a href=\"?m:Client.Verify!\">Verify</a></h2>\n<code>func (c *Client) Verify(addr string) os.Error</code>\n<p>\nVerify checks the validity of an email address on the server.\nIf Verify returns nil, the address is valid. A non-nil return\ndoes not necessarily indicate an invalid address. Many servers\nwill not verify addresses for security reasons.\n</p>\n\n",name:"Verify"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:ServerInfo!\">ServerInfo</a></h2>\n<pre>type ServerInfo struct {\n\tName string   // SMTP server name\n\tTLS  bool     // using TLS, with valid certificate for Name\n\tAuth []string // advertised authentication mechanisms\n}</pre>\n<p>\nServerInfo records information about an SMTP server.\n</p>\n\n",name:"ServerInfo","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Dial!\">Dial</a></h2>\n<code>func Dial(addr string) (*Client, os.Error)</code>\n<p>\nDial returns a new Client connected to an SMTP server at addr.\n</p>\n\n",name:"Dial"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewClient!\">NewClient</a></h2>\n<code>func NewClient(conn net.Conn, host string) (*Client, os.Error)</code>\n<p>\nNewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n</p>\n\n",name:"NewClient"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:PlainAuth!\">PlainAuth</a></h2>\n<code>func PlainAuth(identity, username, password, host string) Auth</code>\n<p>\nPlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616.\nThe returned Auth uses the given username and password to authenticate\non TLS connections to host and act as identity. Usually identity will be\nleft blank to act as username.\n</p>\n\n",name:"PlainAuth"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:SendMail!\">SendMail</a></h2>\n<code>func SendMail(addr string, a Auth, from string, to []string, msg []byte) os.Error</code>\n<p>\nSendMail connects to the server at addr, switches to TLS if possible,\nauthenticates with mechanism a if possible, and then sends an email from\naddress from, to addresses to, with message msg.\n</p>\n\n",name:"SendMail"}],consts:[],vars:[]}