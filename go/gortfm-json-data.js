var gortfmData = {index:"index.html",html:"<p>\nThe json package implements encoding and decoding of JSON objects as\ndefined in RFC 4627.\n</p>\n",name:"json",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decoder!\">Decoder</a></h2>\n<pre>type Decoder struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Decoder reads and decodes JSON objects from an input stream.\n</p>\n\n",name:"Decoder","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.Decode!\">Decode</a></h2>\n<code>func (dec *Decoder) Decode(v interface{}) os.Error</code>\n<p>\nDecode reads the next JSON-encoded value from the\nconnection and stores it in the value pointed to by v.\n</p>\n<p>\nSee the documentation for Unmarshal for details about\nthe conversion of JSON into a Go value.\n</p>\n\n",name:"Decode"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Encoder!\">Encoder</a></h2>\n<pre>type Encoder struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn Encoder writes JSON objects to an output stream.\n</p>\n\n",name:"Encoder","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.Encode!\">Encode</a></h2>\n<code>func (enc *Encoder) Encode(v interface{}) os.Error</code>\n<p>\nEncode writes the JSON encoding of v to the connection.\n</p>\n<p>\nSee the documentation for Marshal for details about the\nconversion of Go values to JSON.\n</p>\n\n",name:"Encode"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:InvalidUnmarshalError!\">InvalidUnmarshalError</a></h2>\n<pre>type InvalidUnmarshalError struct {\n\tType reflect.Type\n}</pre>\n<p>\nAn InvalidUnmarshalError describes an invalid argument passed to Unmarshal.\n(The argument to Unmarshal must be a non-nil pointer.)\n</p>\n\n",name:"InvalidUnmarshalError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:InvalidUnmarshalError\">func (*InvalidUnmarshalError)</a> <a href=\"?m:InvalidUnmarshalError.String!\">String</a></h2>\n<code>func (e *InvalidUnmarshalError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Marshaler!\">Marshaler</a></h2>\n<pre>type Marshaler interface {\n\tMarshalJSON() ([]byte, os.Error)\n}</pre>\n<p>\nMarshaler is the interface implemented by objects that\ncan marshal themselves into valid JSON.\n</p>\n\n",name:"Marshaler","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:MarshalerError!\">MarshalerError</a></h2>\n<pre>type MarshalerError struct {\n\tType  reflect.Type\n\tError os.Error\n}</pre>\n\n",name:"MarshalerError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:MarshalerError\">func (*MarshalerError)</a> <a href=\"?m:MarshalerError.String!\">String</a></h2>\n<code>func (e *MarshalerError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RawMessage!\">RawMessage</a></h2>\n<pre>type RawMessage []byte</pre>\n<p>\nRawMessage is a raw encoded JSON object.\nIt implements Marshaler and Unmarshaler and can\nbe used to delay JSON decoding or precompute a JSON encoding.\n</p>\n\n",name:"RawMessage","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:RawMessage\">func (*RawMessage)</a> <a href=\"?m:RawMessage.MarshalJSON!\">MarshalJSON</a></h2>\n<code>func (m *RawMessage) MarshalJSON() ([]byte, os.Error)</code>\n<p>\nMarshalJSON returns *m as the JSON encoding of m.\n</p>\n\n",name:"MarshalJSON"},{html:"\n<h2><a class=\"black\" href=\"?m:RawMessage\">func (*RawMessage)</a> <a href=\"?m:RawMessage.UnmarshalJSON!\">UnmarshalJSON</a></h2>\n<code>func (m *RawMessage) UnmarshalJSON(data []byte) os.Error</code>\n<p>\nUnmarshalJSON sets *m to a copy of data.\n</p>\n\n",name:"UnmarshalJSON"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SyntaxError!\">SyntaxError</a></h2>\n<pre>type SyntaxError string</pre>\n<p>\nA SyntaxError is a description of a JSON syntax error.\n</p>\n\n",name:"SyntaxError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:SyntaxError\">func (SyntaxError)</a> <a href=\"?m:SyntaxError.String!\">String</a></h2>\n<code>func (e SyntaxError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnmarshalFieldError!\">UnmarshalFieldError</a></h2>\n<pre>type UnmarshalFieldError struct {\n\tKey   string\n\tType  *reflect.StructType\n\tField reflect.StructField\n}</pre>\n<p>\nAn UnmarshalFieldError describes a JSON object key that\nled to an unexported (and therefore unwritable) struct field.\n</p>\n\n",name:"UnmarshalFieldError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnmarshalFieldError\">func (*UnmarshalFieldError)</a> <a href=\"?m:UnmarshalFieldError.String!\">String</a></h2>\n<code>func (e *UnmarshalFieldError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnmarshalTypeError!\">UnmarshalTypeError</a></h2>\n<pre>type UnmarshalTypeError struct {\n\tValue string       // description of JSON value - &#34;bool&#34;, &#34;array&#34;, &#34;number -5&#34;\n\tType  reflect.Type // type of Go value it could not be assigned to\n}</pre>\n<p>\nAn UnmarshalTypeError describes a JSON value that was\nnot appropriate for a value of a specific Go type.\n</p>\n\n",name:"UnmarshalTypeError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnmarshalTypeError\">func (*UnmarshalTypeError)</a> <a href=\"?m:UnmarshalTypeError.String!\">String</a></h2>\n<code>func (e *UnmarshalTypeError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Unmarshaler!\">Unmarshaler</a></h2>\n<pre>type Unmarshaler interface {\n\tUnmarshalJSON([]byte) os.Error\n}</pre>\n<p>\nUnmarshaler is the interface implemented by objects\nthat can unmarshal a JSON description of themselves.\nThe input can be assumed to be a valid JSON object\nencoding.  UnmarshalJSON must copy the JSON data\nif it wishes to retain the data after returning.\n</p>\n\n",name:"Unmarshaler","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:UnsupportedTypeError!\">UnsupportedTypeError</a></h2>\n<pre>type UnsupportedTypeError struct {\n\tType reflect.Type\n}</pre>\n\n",name:"UnsupportedTypeError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:UnsupportedTypeError\">func (*UnsupportedTypeError)</a> <a href=\"?m:UnsupportedTypeError.String!\">String</a></h2>\n<code>func (e *UnsupportedTypeError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Compact!\">Compact</a></h2>\n<code>func Compact(dst *bytes.Buffer, src []byte) os.Error</code>\n<p>\nCompact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n</p>\n\n",name:"Compact"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:HTMLEscape!\">HTMLEscape</a></h2>\n<code>func HTMLEscape(dst *bytes.Buffer, src []byte)</code>\n<p>\nHTMLEscape appends to dst the JSON-encoded src with &lt;, &gt;, and &amp;\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026\nso that the JSON will be safe to embed inside HTML &lt;script&gt; tags.\nFor historical reasons, web browsers don&#39;t honor standard HTML\nescaping within &lt;script&gt; tags, so an alternative JSON encoding must\nbe used.\n</p>\n\n",name:"HTMLEscape"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Indent!\">Indent</a></h2>\n<code>func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) os.Error</code>\n<p>\nIndent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst has no trailing newline, to make it easier\nto embed inside other formatted JSON data.\n</p>\n\n",name:"Indent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Marshal!\">Marshal</a></h2>\n<code>func Marshal(v interface{}) ([]byte, os.Error)</code>\n<p>\nMarshal returns the JSON encoding of v.\n</p>\n<p>\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface,\nMarshal calls its MarshalJSON method to produce JSON.\n</p>\n<p>\nOtherwise, Marshal uses the following type-dependent default encodings:\n</p>\n<p>\nBoolean values encode as JSON booleans.\n</p>\n<p>\nFloating point and integer values encode as JSON numbers.\n</p>\n<p>\nString values encode as JSON strings, with each invalid UTF-8 sequence\nreplaced by the encoding of the Unicode replacement character U+FFFD.\n</p>\n<p>\nArray and slice values encode as JSON arrays.\n</p>\n<p>\nStruct values encode as JSON objects.  Each struct field becomes\na member of the object.  By default the object&#39;s key name is the\nstruct field name converted to lower case.  If the struct field\nhas a tag, that tag will be used as the name instead.\n</p>\n<p>\nMap values encode as JSON objects.\nThe map&#39;s key type must be string; the object keys are used directly\nas map keys.\n</p>\n<p>\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON object.\n</p>\n<p>\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON object.\n</p>\n<p>\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan InvalidTypeError.\n</p>\n<p>\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them.  Passing cyclic structures to Marshal will result in\nan infinite recursion.\n</p>\n\n",name:"Marshal"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalForHTML!\">MarshalForHTML</a></h2>\n<code>func MarshalForHTML(v interface{}) ([]byte, os.Error)</code>\n<p>\nMarshalForHTML is like Marshal but applies HTMLEscape to the output.\n</p>\n\n",name:"MarshalForHTML"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:MarshalIndent!\">MarshalIndent</a></h2>\n<code>func MarshalIndent(v interface{}, prefix, indent string) ([]byte, os.Error)</code>\n<p>\nMarshalIndent is like Marshal but applies Indent to format the output.\n</p>\n\n",name:"MarshalIndent"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewDecoder!\">NewDecoder</a></h2>\n<code>func NewDecoder(r io.Reader) *Decoder</code>\n<p>\nNewDecoder returns a new decoder that reads from r.\n</p>\n\n",name:"NewDecoder"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEncoder!\">NewEncoder</a></h2>\n<code>func NewEncoder(w io.Writer) *Encoder</code>\n<p>\nNewEncoder returns a new encoder that writes to w.\n</p>\n\n",name:"NewEncoder"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Unmarshal!\">Unmarshal</a></h2>\n<code>func Unmarshal(data []byte, v interface{}) os.Error</code>\n<p>\nUnmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v.\n</p>\n<p>\nUnmarshal traverses the value v recursively.\nIf an encountered value implements the Unmarshaler interface,\nUnmarshal calls its UnmarshalJSON method with a well-formed\nJSON encoding.\n</p>\n<p>\nOtherwise, Unmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n</p>\n<p>\nTo unmarshal a JSON value into a nil interface value, the\ntype stored in the interface value is one of:\n</p>\n<pre>bool, for JSON booleans\nfloat64, for JSON numbers\nstring, for JSON strings\n[]interface{}, for JSON arrays\nmap[string]interface{}, for JSON objects\nnil for JSON null\n</pre>\n<p>\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshalling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error.\n</p>\n\n",name:"Unmarshal"}],consts:[],vars:[]}