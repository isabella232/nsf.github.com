var gortfmData = {index:"index.html",html:"<p>\nPackage macho implements access to Mach-O object files, as defined by\n<a href=\"http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html\">http://developer.apple.com/mac/library/documentation/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html</a>.\n</p>\n",name:"macho",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cpu!\">Cpu</a></h2>\n<pre>type Cpu uint32</pre>\n<p>\nA Cpu is a Mach-O cpu type.\n</p>\n\n",name:"Cpu","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Cpu\">func (Cpu)</a> <a href=\"?m:Cpu.GoString!\">GoString</a></h2>\n<code>func (i Cpu) GoString() string</code>\n\n",name:"GoString"},{html:"\n<h2><a class=\"black\" href=\"?m:Cpu\">func (Cpu)</a> <a href=\"?m:Cpu.String!\">String</a></h2>\n<code>func (i Cpu) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Dylib!\">Dylib</a></h2>\n<pre>type Dylib struct {\n\tLoadBytes\n\tName           string\n\tTime           uint32\n\tCurrentVersion uint32\n\tCompatVersion  uint32\n}</pre>\n<p>\nA Dylib represents a Mach-O load dynamic library command.\n</p>\n\n",name:"Dylib","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DylibCmd!\">DylibCmd</a></h2>\n<pre>type DylibCmd struct {\n\tCmd            LoadCmd\n\tLen            uint32\n\tName           uint32\n\tTime           uint32\n\tCurrentVersion uint32\n\tCompatVersion  uint32\n}</pre>\n<p>\nA DylibCmd is a Mach-O load dynamic library command.\n</p>\n\n",name:"DylibCmd","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Dysymtab!\">Dysymtab</a></h2>\n<pre>type Dysymtab struct {\n\tLoadBytes\n\tDysymtabCmd\n\tIndirectSyms []uint32 // indices into Symtab.Syms\n}</pre>\n<p>\nA Dysymtab represents a Mach-O dynamic symbol table command.\n</p>\n\n",name:"Dysymtab","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:DysymtabCmd!\">DysymtabCmd</a></h2>\n<pre>type DysymtabCmd struct {\n\tCmd            LoadCmd\n\tLen            uint32\n\tIlocalsym      uint32\n\tNlocalsym      uint32\n\tIextdefsym     uint32\n\tNextdefsym     uint32\n\tIundefsym      uint32\n\tNundefsym      uint32\n\tTocoffset      uint32\n\tNtoc           uint32\n\tModtaboff      uint32\n\tNmodtab        uint32\n\tExtrefsymoff   uint32\n\tNextrefsyms    uint32\n\tIndirectsymoff uint32\n\tNindirectsyms  uint32\n\tExtreloff      uint32\n\tNextrel        uint32\n\tLocreloff      uint32\n\tNlocrel        uint32\n}</pre>\n<p>\nA DysymtabCmd is a Mach-O dynamic symbol table command.\n</p>\n\n",name:"DysymtabCmd","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\n<pre>type File struct {\n\tFileHeader\n\tByteOrder binary.ByteOrder\n\tLoads     []Load\n\tSections  []*Section\n\n\tSymtab   *Symtab\n\tDysymtab *Dysymtab\n\t// contains unexported fields\n}</pre>\n<p>\nA File represents an open Mach-O file.\n</p>\n\n",name:"File","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Close!\">Close</a></h2>\n<code>func (f *File) Close() os.Error</code>\n<p>\nClose closes the File.\nIf the File was created using NewFile directly instead of Open,\nClose has no effect.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.DWARF!\">DWARF</a></h2>\n<code>func (f *File) DWARF() (*dwarf.Data, os.Error)</code>\n<p>\nDWARF returns the DWARF debug information for the Mach-O file.\n</p>\n\n",name:"DWARF"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.ImportedLibraries!\">ImportedLibraries</a></h2>\n<code>func (f *File) ImportedLibraries() ([]string, os.Error)</code>\n<p>\nImportedLibraries returns the paths of all libraries\nreferred to by the binary f that are expected to be\nlinked with the binary at dynamic link time.\n</p>\n\n",name:"ImportedLibraries"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.ImportedSymbols!\">ImportedSymbols</a></h2>\n<code>func (f *File) ImportedSymbols() ([]string, os.Error)</code>\n<p>\nImportedSymbols returns the names of all symbols\nreferred to by the binary f that are expected to be\nsatisfied by other libraries at dynamic load time.\n</p>\n\n",name:"ImportedSymbols"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Section!\">Section</a></h2>\n<code>func (f *File) Section(name string) *Section</code>\n<p>\nSection returns the first section with the given name, or nil if no such\nsection exists.\n</p>\n\n",name:"Section"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Segment!\">Segment</a></h2>\n<code>func (f *File) Segment(name string) *Segment</code>\n<p>\nSegment returns the first Segment with the given name, or nil if no such segment exists.\n</p>\n\n",name:"Segment"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FileHeader!\">FileHeader</a></h2>\n<pre>type FileHeader struct {\n\tMagic  uint32\n\tCpu    Cpu\n\tSubCpu uint32\n\tType   Type\n\tNcmd   uint32\n\tCmdsz  uint32\n\tFlags  uint32\n}</pre>\n<p>\nA FileHeader represents a Mach-O file header.\n</p>\n\n",name:"FileHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatError!\">FormatError</a></h2>\n<pre>type FormatError struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"FormatError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FormatError\">func (*FormatError)</a> <a href=\"?m:FormatError.String!\">String</a></h2>\n<code>func (e *FormatError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Load!\">Load</a></h2>\n<pre>type Load interface {\n\tRaw() []byte\n}</pre>\n<p>\nA Load represents any Mach-O load command.\n</p>\n\n",name:"Load","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LoadBytes!\">LoadBytes</a></h2>\n<pre>type LoadBytes []byte</pre>\n<p>\nA LoadBytes is the uninterpreted bytes of a Mach-O load command.\n</p>\n\n",name:"LoadBytes","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:LoadBytes\">func (LoadBytes)</a> <a href=\"?m:LoadBytes.Raw!\">Raw</a></h2>\n<code>func (b LoadBytes) Raw() []byte</code>\n\n",name:"Raw"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:LoadCmd!\">LoadCmd</a></h2>\n<pre>type LoadCmd uint32</pre>\n<p>\nA LoadCmd is a Mach-O load command.\n</p>\n\n",name:"LoadCmd","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:LoadCmd\">func (LoadCmd)</a> <a href=\"?m:LoadCmd.GoString!\">GoString</a></h2>\n<code>func (i LoadCmd) GoString() string</code>\n\n",name:"GoString"},{html:"\n<h2><a class=\"black\" href=\"?m:LoadCmd\">func (LoadCmd)</a> <a href=\"?m:LoadCmd.String!\">String</a></h2>\n<code>func (i LoadCmd) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Nlist32!\">Nlist32</a></h2>\n<pre>type Nlist32 struct {\n\tName  uint32\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint32\n}</pre>\n<p>\nAn Nlist32 is a Mach-O 32-bit symbol table entry.\n</p>\n\n",name:"Nlist32","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Nlist64!\">Nlist64</a></h2>\n<pre>type Nlist64 struct {\n\tName  uint32\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint64\n}</pre>\n<p>\nAn Nlist64 is a Mach-O 64-bit symbol table entry.\n</p>\n\n",name:"Nlist64","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Regs386!\">Regs386</a></h2>\n<pre>type Regs386 struct {\n\tAX    uint32\n\tBX    uint32\n\tCX    uint32\n\tDX    uint32\n\tDI    uint32\n\tSI    uint32\n\tBP    uint32\n\tSP    uint32\n\tSS    uint32\n\tFLAGS uint32\n\tIP    uint32\n\tCS    uint32\n\tDS    uint32\n\tES    uint32\n\tFS    uint32\n\tGS    uint32\n}</pre>\n<p>\nRegs386 is the Mach-O 386 register structure.\n</p>\n\n",name:"Regs386","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RegsAMD64!\">RegsAMD64</a></h2>\n<pre>type RegsAMD64 struct {\n\tAX    uint64\n\tBX    uint64\n\tCX    uint64\n\tDX    uint64\n\tDI    uint64\n\tSI    uint64\n\tBP    uint64\n\tSP    uint64\n\tR8    uint64\n\tR9    uint64\n\tR10   uint64\n\tR11   uint64\n\tR12   uint64\n\tR13   uint64\n\tR14   uint64\n\tR15   uint64\n\tIP    uint64\n\tFLAGS uint64\n\tCS    uint64\n\tFS    uint64\n\tGS    uint64\n}</pre>\n<p>\nRegsAMD64 is the Mach-O AMD64 register structure.\n</p>\n\n",name:"RegsAMD64","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Section!\">Section</a></h2>\n<pre>type Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// contains unexported fields\n}</pre>\n\n",name:"Section","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Section\">func (*Section)</a> <a href=\"?m:Section.Data!\">Data</a></h2>\n<code>func (s *Section) Data() ([]byte, os.Error)</code>\n<p>\nData reads and returns the contents of the Mach-O section.\n</p>\n\n",name:"Data"},{html:"\n<h2><a class=\"black\" href=\"?m:Section\">func (*Section)</a> <a href=\"?m:Section.Open!\">Open</a></h2>\n<code>func (s *Section) Open() io.ReadSeeker</code>\n<p>\nOpen returns a new ReadSeeker reading the Mach-O section.\n</p>\n\n",name:"Open"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Section32!\">Section32</a></h2>\n<pre>type Section32 struct {\n\tName     [16]byte\n\tSeg      [16]byte\n\tAddr     uint32\n\tSize     uint32\n\tOffset   uint32\n\tAlign    uint32\n\tReloff   uint32\n\tNreloc   uint32\n\tFlags    uint32\n\tReserve1 uint32\n\tReserve2 uint32\n}</pre>\n<p>\nA Section32 is a 32-bit Mach-O section header.\n</p>\n\n",name:"Section32","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Section64!\">Section64</a></h2>\n<pre>type Section64 struct {\n\tName     [16]byte\n\tSeg      [16]byte\n\tAddr     uint64\n\tSize     uint64\n\tOffset   uint32\n\tAlign    uint32\n\tReloff   uint32\n\tNreloc   uint32\n\tFlags    uint32\n\tReserve1 uint32\n\tReserve2 uint32\n\tReserve3 uint32\n}</pre>\n<p>\nA Section32 is a 64-bit Mach-O section header.\n</p>\n\n",name:"Section64","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SectionHeader!\">SectionHeader</a></h2>\n<pre>type SectionHeader struct {\n\tName   string\n\tSeg    string\n\tAddr   uint64\n\tSize   uint64\n\tOffset uint32\n\tAlign  uint32\n\tReloff uint32\n\tNreloc uint32\n\tFlags  uint32\n}</pre>\n\n",name:"SectionHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Segment!\">Segment</a></h2>\n<pre>type Segment struct {\n\tLoadBytes\n\tSegmentHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// contains unexported fields\n}</pre>\n<p>\nA Segment represents a Mach-O 32-bit or 64-bit load segment command.\n</p>\n\n",name:"Segment","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Segment\">func (*Segment)</a> <a href=\"?m:Segment.Data!\">Data</a></h2>\n<code>func (s *Segment) Data() ([]byte, os.Error)</code>\n<p>\nData reads and returns the contents of the segment.\n</p>\n\n",name:"Data"},{html:"\n<h2><a class=\"black\" href=\"?m:Segment\">func (*Segment)</a> <a href=\"?m:Segment.Open!\">Open</a></h2>\n<code>func (s *Segment) Open() io.ReadSeeker</code>\n<p>\nOpen returns a new ReadSeeker reading the segment.\n</p>\n\n",name:"Open"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Segment32!\">Segment32</a></h2>\n<pre>type Segment32 struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    [16]byte\n\tAddr    uint32\n\tMemsz   uint32\n\tOffset  uint32\n\tFilesz  uint32\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}</pre>\n<p>\nA Segment32 is a 32-bit Mach-O segment load command.\n</p>\n\n",name:"Segment32","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Segment64!\">Segment64</a></h2>\n<pre>type Segment64 struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    [16]byte\n\tAddr    uint64\n\tMemsz   uint64\n\tOffset  uint64\n\tFilesz  uint64\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}</pre>\n<p>\nA Segment64 is a 64-bit Mach-O segment load command.\n</p>\n\n",name:"Segment64","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SegmentHeader!\">SegmentHeader</a></h2>\n<pre>type SegmentHeader struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tName    string\n\tAddr    uint64\n\tMemsz   uint64\n\tOffset  uint64\n\tFilesz  uint64\n\tMaxprot uint32\n\tProt    uint32\n\tNsect   uint32\n\tFlag    uint32\n}</pre>\n<p>\nA SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command.\n</p>\n\n",name:"SegmentHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Symbol!\">Symbol</a></h2>\n<pre>type Symbol struct {\n\tName  string\n\tType  uint8\n\tSect  uint8\n\tDesc  uint16\n\tValue uint64\n}</pre>\n<p>\nA Symbol is a Mach-O 32-bit or 64-bit symbol table entry.\n</p>\n\n",name:"Symbol","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Symtab!\">Symtab</a></h2>\n<pre>type Symtab struct {\n\tLoadBytes\n\tSymtabCmd\n\tSyms []Symbol\n}</pre>\n<p>\nA Symtab represents a Mach-O symbol table command.\n</p>\n\n",name:"Symtab","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SymtabCmd!\">SymtabCmd</a></h2>\n<pre>type SymtabCmd struct {\n\tCmd     LoadCmd\n\tLen     uint32\n\tSymoff  uint32\n\tNsyms   uint32\n\tStroff  uint32\n\tStrsize uint32\n}</pre>\n<p>\nA SymtabCmd is a Mach-O symbol table command.\n</p>\n\n",name:"SymtabCmd","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Thread!\">Thread</a></h2>\n<pre>type Thread struct {\n\tCmd  LoadCmd\n\tLen  uint32\n\tType uint32\n\tData []uint32\n}</pre>\n<p>\nA Thread is a Mach-O thread state command.\n</p>\n\n",name:"Thread","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Type!\">Type</a></h2>\n<pre>type Type uint32</pre>\n<p>\nA Type is a Mach-O file type, either an object or an executable.\n</p>\n\n",name:"Type","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewFile!\">NewFile</a></h2>\n<code>func NewFile(r io.ReaderAt) (*File, os.Error)</code>\n<p>\nNewFile creates a new File for acecssing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n</p>\n\n",name:"NewFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Open!\">Open</a></h2>\n<code>func Open(name string) (*File, os.Error)</code>\n<p>\nOpen opens the named file using os.Open and prepares it for use as a Mach-O binary.\n</p>\n\n",name:"Open"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Magic32!\"><em>group</em></a></h2>\n<pre>const (\n\tMagic32 uint32 = 0xfeedface\n\tMagic64 uint32 = 0xfeedfacf\n)</pre>\n\n",names:["Magic32","Magic64"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Type!\">Type</a></h2>\n<pre>const (\n\tTypeObj  Type = 1\n\tTypeExec Type = 2\n)</pre>\n\n",names:["TypeObj","TypeExec"],type:"Type"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Cpu!\">Cpu</a></h2>\n<pre>const (\n\tCpu386   Cpu = 7\n\tCpuAmd64 Cpu = Cpu386 + 1&lt;&lt;24\n)</pre>\n\n",names:["Cpu386","CpuAmd64"],type:"Cpu"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:LoadCmd!\">LoadCmd</a></h2>\n<pre>const (\n\tLoadCmdSegment    LoadCmd = 1\n\tLoadCmdSymtab     LoadCmd = 2\n\tLoadCmdThread     LoadCmd = 4\n\tLoadCmdUnixThread LoadCmd = 5 // thread+stack\n\tLoadCmdDysymtab   LoadCmd = 11\n\tLoadCmdDylib      LoadCmd = 12\n\tLoadCmdDylinker   LoadCmd = 15\n\tLoadCmdSegment64  LoadCmd = 25\n)</pre>\n\n",names:["LoadCmdSegment","LoadCmdSymtab","LoadCmdThread","LoadCmdUnixThread","LoadCmdDysymtab","LoadCmdDylib","LoadCmdDylinker","LoadCmdSegment64"],type:"LoadCmd"}],vars:[]}