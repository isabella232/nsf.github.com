var gortfmData = {index:"index.html",html:"<p>\nA scanner and tokenizer for UTF-8-encoded text.  Takes an io.Reader\nproviding the source, which then can be tokenized through repeated calls\nto the Scan function.  For compatibility with existing tools, the NUL\ncharacter is not allowed (implementation restriction).\n</p>\n<p>\nBy default, a Scanner skips white space and Go comments and recognizes all\nliterals as defined by the Go language specification.  It may be\ncustomized to recognize only a subset of those literals and to recognize\ndifferent white space characters.\n</p>\n<p>\nBasic usage pattern:\n</p>\n<pre>var s scanner.Scanner\ns.Init(src)\ntok := s.Scan()\nfor tok != scanner.EOF {\n\t// do something with tok\n\ttok = s.Scan()\n}\n</pre>\n",name:"scanner",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Position!\">Position</a></h2>\n<pre>type Position struct {\n\tFilename string // filename, if any\n\tOffset   int    // byte offset, starting at 0\n\tLine     int    // line number, starting at 1\n\tColumn   int    // column number, starting at 0 (character count per line)\n}</pre>\n<p>\nA source position is represented by a Position value.\nA position is valid if Line &gt; 0.\n</p>\n\n",name:"Position","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.IsValid!\">IsValid</a></h2>\n<code>func (pos *Position) IsValid() bool</code>\n<p>\nIsValid returns true if the position is valid.\n</p>\n\n",name:"IsValid"},{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (Position)</a> <a href=\"?m:Position.String!\">String</a></h2>\n<code>func (pos Position) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Scanner!\">Scanner</a></h2>\n<pre>type Scanner struct {\n\n\t// Error is called for each error encountered. If no Error\n\t// function is set, the error is reported to os.Stderr.\n\tError func(s *Scanner, msg string)\n\n\t// ErrorCount is incremented by one for each error encountered.\n\tErrorCount int\n\n\t// The Mode field controls which tokens are recognized. For instance,\n\t// to recognize Ints, set the ScanInts bit in Mode. The field may be\n\t// changed at any time.\n\tMode uint\n\n\t// The Whitespace field controls which characters are recognized\n\t// as white space. To recognize a character ch &lt;= &#39; &#39; as white space,\n\t// set the ch&#39;th bit in Whitespace (the Scanner&#39;s behavior is undefined\n\t// for values ch &gt; &#39; &#39;). The field may be changed at any time.\n\tWhitespace uint64\n\n\t// Current token position. The Offset, Line, and Column fields\n\t// are set by Scan(); the Filename field is left untouched by the\n\t// Scanner.\n\tPosition\n\t// contains unexported fields\n}</pre>\n<p>\nA Scanner implements reading of Unicode characters and tokens from an io.Reader.\n</p>\n\n",name:"Scanner","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Init!\">Init</a></h2>\n<code>func (s *Scanner) Init(src io.Reader) *Scanner</code>\n<p>\nInit initializes a Scanner with a new source and returns itself.\nError is set to nil, ErrorCount is set to 0, Mode is set to GoTokens,\nand Whitespace is set to GoWhitespace.\n</p>\n\n",name:"Init"},{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Next!\">Next</a></h2>\n<code>func (s *Scanner) Next() int</code>\n<p>\nNext reads and returns the next Unicode character.\nIt returns EOF at the end of the source. It reports\na read error by calling s.Error, if set, or else\nprints an error message to os.Stderr. Next does not\nupdate the Scanner&#39;s Position field; use Pos() to\nget the current position.\n</p>\n\n",name:"Next"},{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Peek!\">Peek</a></h2>\n<code>func (s *Scanner) Peek() int</code>\n<p>\nPeek returns the next Unicode character in the source without advancing\nthe scanner. It returns EOF if the scanner&#39;s position is at the last\ncharacter of the source.\n</p>\n\n",name:"Peek"},{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Pos!\">Pos</a></h2>\n<code>func (s *Scanner) Pos() Position</code>\n<p>\nPosition returns the current source position. If called before Next()\nor Scan(), it returns the position of the next Unicode character or token\nreturned by these functions. If called afterwards, it returns the position\nimmediately after the last character of the most recent token or character\nscanned.\n</p>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.Scan!\">Scan</a></h2>\n<code>func (s *Scanner) Scan() int</code>\n<p>\nScan reads the next token or Unicode character from source and returns it.\nIt only recognizes tokens t for which the respective Mode bit (1&lt;&lt;-t) is set.\nIt returns EOF at the end of the source. It reports scanner errors (read and\ntoken errors) by calling s.Error, if set; otherwise it prints an error message\nto os.Stderr.\n</p>\n\n",name:"Scan"},{html:"\n<h2><a class=\"black\" href=\"?m:Scanner\">func (*Scanner)</a> <a href=\"?m:Scanner.TokenText!\">TokenText</a></h2>\n<code>func (s *Scanner) TokenText() string</code>\n<p>\nTokenText returns the string corresponding to the most recently scanned token.\nValid after calling Scan().\n</p>\n\n",name:"TokenText"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:TokenString!\">TokenString</a></h2>\n<code>func TokenString(tok int) string</code>\n<p>\nTokenString returns a (visible) string for a token or Unicode character.\n</p>\n\n",name:"TokenString"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:ScanIdents!\"><em>group</em></a></h2>\n<pre>const (\n\tScanIdents     = 1 &lt;&lt; -Ident\n\tScanInts       = 1 &lt;&lt; -Int\n\tScanFloats     = 1 &lt;&lt; -Float // includes Ints\n\tScanChars      = 1 &lt;&lt; -Char\n\tScanStrings    = 1 &lt;&lt; -String\n\tScanRawStrings = 1 &lt;&lt; -RawString\n\tScanComments   = 1 &lt;&lt; -Comment\n\tSkipComments   = 1 &lt;&lt; -skipComment // if set with ScanComments, comments become white space\n\tGoTokens       = ScanIdents | ScanFloats | ScanChars | ScanStrings | ScanRawStrings | ScanComments | SkipComments\n)</pre>\n<p>\nPredefined mode bits to control recognition of tokens. For instance,\nto configure a Scanner such that it only recognizes (Go) identifiers,\nintegers, and skips comments, set the Scanner&#39;s Mode field to:\n</p>\n<pre>ScanIdents | ScanInts | SkipComments\n</pre>\n\n",names:["ScanIdents","ScanInts","ScanFloats","ScanChars","ScanStrings","ScanRawStrings","ScanComments","SkipComments","GoTokens"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:EOF!\"><em>group</em></a></h2>\n<pre>const (\n\tEOF = -(iota + 1)\n\tIdent\n\tInt\n\tFloat\n\tChar\n\tString\n\tRawString\n\tComment\n)</pre>\n<p>\nThe result of Scan is one of the following tokens or a Unicode character.\n</p>\n\n",names:["EOF","Ident","Int","Float","Char","String","RawString","Comment"],type:""},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:GoWhitespace!\">GoWhitespace</a></h2>\n<pre>const GoWhitespace = 1&lt;&lt;&#39;\\t&#39; | 1&lt;&lt;&#39;\\n&#39; | 1&lt;&lt;&#39;\\r&#39; | 1&lt;&lt;&#39; &#39;</pre>\n<p>\nGoWhitespace is the default value for the Scanner&#39;s Whitespace field.\nIts value selects Go&#39;s white space characters.\n</p>\n\n",names:["GoWhitespace"],type:""}],vars:[]}