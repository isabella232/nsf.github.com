var gortfmData = {index:"index.html",html:"<p>\nPackage multipart implements MIME multipart parsing, as defined in RFC\n2046.\n</p>\n<p>\nThe implementation is sufficient for HTTP (RFC 2388) and the multipart\nbodies generated by popular browsers.\n</p>\n",name:"multipart",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\n<pre>type File interface {\n\tio.Reader\n\tio.ReaderAt\n\tio.Seeker\n\tio.Closer\n}</pre>\n<p>\nFile is an interface to access the file part of a multipart message.\nIts contents may be either stored in memory or on disk.\nIf stored on disk, the File&#39;s underlying concrete type will be an *os.File.\n</p>\n\n",name:"File","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FileHeader!\">FileHeader</a></h2>\n<pre>type FileHeader struct {\n\tFilename string\n\tHeader   textproto.MIMEHeader\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA FileHeader describes a file part of a multipart request.\n</p>\n\n",name:"FileHeader","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FileHeader\">func (*FileHeader)</a> <a href=\"?m:FileHeader.Open!\">Open</a></h2>\n<code>func (fh *FileHeader) Open() (File, os.Error)</code>\n<p>\nOpen opens and returns the FileHeader&#39;s associated File.\n</p>\n\n",name:"Open"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Form!\">Form</a></h2>\n<pre>type Form struct {\n\tValue map[string][]string\n\tFile  map[string][]*FileHeader\n}</pre>\n<p>\nForm is a parsed multipart form.\nIts File parts are stored either in memory or on disk,\nand are accessible via the *FileHeader&#39;s Open method.\nIts Value parts are stored as strings.\nBoth are keyed by field name.\n</p>\n\n",name:"Form","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Form\">func (*Form)</a> <a href=\"?m:Form.RemoveAll!\">RemoveAll</a></h2>\n<code>func (f *Form) RemoveAll() os.Error</code>\n<p>\nRemoveAll removes any temporary files associated with a Form.\n</p>\n\n",name:"RemoveAll"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Part!\">Part</a></h2>\n<pre>type Part struct {\n\t// The headers of the body, if any, with the keys canonicalized\n\t// in the same fashion that the Go http.Request headers are.\n\t// i.e. &#34;foo-bar&#34; changes case to &#34;Foo-Bar&#34;\n\tHeader textproto.MIMEHeader\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nA Part represents a single part in a multipart body.\n</p>\n\n",name:"Part","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Part\">func (*Part)</a> <a href=\"?m:Part.Close!\">Close</a></h2>\n<code>func (bp *Part) Close() os.Error</code>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Part\">func (*Part)</a> <a href=\"?m:Part.FileName!\">FileName</a></h2>\n<code>func (p *Part) FileName() string</code>\n<p>\nFileName returns the filename parameter of the Part&#39;s\nContent-Disposition header.\n</p>\n\n",name:"FileName"},{html:"\n<h2><a class=\"black\" href=\"?m:Part\">func (*Part)</a> <a href=\"?m:Part.FormName!\">FormName</a></h2>\n<code>func (p *Part) FormName() string</code>\n<p>\nFormName returns the name parameter if p has a Content-Disposition\nof type &#34;form-data&#34;.  Otherwise it returns the empty string.\n</p>\n\n",name:"FormName"},{html:"\n<h2><a class=\"black\" href=\"?m:Part\">func (*Part)</a> <a href=\"?m:Part.Read!\">Read</a></h2>\n<code>func (bp *Part) Read(p []byte) (n int, err os.Error)</code>\n<p>\nRead reads the body of a part, after its headers and before the\nnext part (if any) begins.\n</p>\n\n",name:"Read"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Reader!\">Reader</a></h2>\n<pre>type Reader interface {\n\t// NextPart returns the next part in the multipart or an error.\n\t// When there are no more parts, the error os.EOF is returned.\n\tNextPart() (*Part, os.Error)\n\n\t// ReadForm parses an entire multipart message whose parts have\n\t// a Content-Disposition of &#34;form-data&#34;.\n\t// It stores up to maxMemory bytes of the file parts in memory\n\t// and the remainder on disk in temporary files.\n\tReadForm(maxMemory int64) (*Form, os.Error)\n}</pre>\n<p>\nReader is an iterator over parts in a MIME multipart body.\nReader&#39;s underlying parser consumes its input as needed.  Seeking\nisn&#39;t supported.\n</p>\n\n",name:"Reader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Writer!\">Writer</a></h2>\n<pre>type Writer struct {\n\t// Boundary is the random boundary string between\n\t// parts. NewWriter will generate this but it must\n\t// not be changed after a part has been created.\n\t// Setting this to an invalid value will generate\n\t// malformed messages.\n\tBoundary string\n\t// contains filtered or unexported fields\n}</pre>\n<p>\nWriter is used to generate multipart messages.\n</p>\n\n",name:"Writer","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.Close!\">Close</a></h2>\n<code>func (w *Writer) Close() os.Error</code>\n<p>\nClose finishes the multipart message. It closes the previous part,\nif still open, and writes the trailing boundary end line to the\noutput.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.CreateFormField!\">CreateFormField</a></h2>\n<code>func (w *Writer) CreateFormField(fieldname string) (io.WriteCloser, os.Error)</code>\n<p>\nCreateFormField is a convenience wrapper around CreatePart. It creates\na new form-data header with the provided field name.\n</p>\n\n",name:"CreateFormField"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.CreateFormFile!\">CreateFormFile</a></h2>\n<code>func (w *Writer) CreateFormFile(fieldname, filename string) (io.WriteCloser, os.Error)</code>\n<p>\nCreateFormFile is a convenience wrapper around CreatePart. It creates\na new form-data header with the provided field name and file name.\n</p>\n\n",name:"CreateFormFile"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.CreatePart!\">CreatePart</a></h2>\n<code>func (w *Writer) CreatePart(header textproto.MIMEHeader) (io.WriteCloser, os.Error)</code>\n<p>\nCreatePart creates a new multipart section with the provided\nheader. The previous part, if still open, is closed. The body of\nthe part should be written to the returned WriteCloser. Closing the\nreturned WriteCloser after writing is optional.\n</p>\n\n",name:"CreatePart"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.FormDataContentType!\">FormDataContentType</a></h2>\n<code>func (w *Writer) FormDataContentType() string</code>\n<p>\nFormDataContentType returns the Content-Type for an HTTP\nmultipart/form-data with this Writer&#39;s Boundary.\n</p>\n\n",name:"FormDataContentType"},{html:"\n<h2><a class=\"black\" href=\"?m:Writer\">func (*Writer)</a> <a href=\"?m:Writer.WriteField!\">WriteField</a></h2>\n<code>func (w *Writer) WriteField(fieldname, value string) os.Error</code>\n<p>\nWriteField is a convenience wrapper around CreateFormField. It creates and\nwrites a part with the provided name and value.\n</p>\n\n",name:"WriteField"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewReader!\">NewReader</a></h2>\n<code>func NewReader(reader io.Reader, boundary string) Reader</code>\n<p>\nNewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n</p>\n\n",name:"NewReader"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewWriter!\">NewWriter</a></h2>\n<code>func NewWriter(w io.Writer) *Writer</code>\n<p>\nNewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n</p>\n\n",name:"NewWriter"}],consts:[],vars:[]}