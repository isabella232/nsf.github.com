var gortfmData = {index:"index.html",html:"<p>\nPackage gob manages streams of gobs - binary values exchanged between an\nEncoder (transmitter) and a Decoder (receiver).  A typical use is transporting\narguments and results of remote procedure calls (RPCs) such as those provided by\npackage &#34;rpc&#34;.\n</p>\n<p>\nA stream of gobs is self-describing.  Each data item in the stream is preceded by\na specification of its type, expressed in terms of a small set of predefined\ntypes.  Pointers are not transmitted, but the things they point to are\ntransmitted; that is, the values are flattened.  Recursive types work fine, but\nrecursive values (data with cycles) are problematic.  This may change.\n</p>\n<p>\nTo use gobs, create an Encoder and present it with a series of data items as\nvalues or addresses that can be dereferenced to values.  The Encoder makes sure\nall type information is sent before it is needed.  At the receive side, a\nDecoder retrieves values from the encoded stream and unpacks them into local\nvariables.\n</p>\n<p>\nThe source and destination values/types need not correspond exactly.  For structs,\nfields (identified by name) that are in the source but absent from the receiving\nvariable will be ignored.  Fields that are in the receiving variable but missing\nfrom the transmitted type or value will be ignored in the destination.  If a field\nwith the same name is present in both, their types must be compatible. Both the\nreceiver and transmitter will do all necessary indirection and dereferencing to\nconvert between gobs and actual Go values.  For instance, a gob type that is\nschematically,\n</p>\n<pre>struct { a, b int }\n</pre>\n<p>\ncan be sent from or received into any of these Go types:\n</p>\n<pre>struct { a, b int }\t// the same\n*struct { a, b int }\t// extra indirection of the struct\nstruct { *a, **b int }\t// extra indirection of the fields\nstruct { a, b int64 }\t// different concrete value type; see below\n</pre>\n<p>\nIt may also be received into any of these:\n</p>\n<pre>struct { a, b int }\t// the same\nstruct { b, a int }\t// ordering doesn&#39;t matter; matching is by name\nstruct { a, b, c int }\t// extra field (c) ignored\nstruct { b int }\t// missing field (a) ignored; data will be dropped\nstruct { b, c int }\t// missing field (a) ignored; extra field (c) ignored.\n</pre>\n<p>\nAttempting to receive into these types will draw a decode error:\n</p>\n<pre>struct { a int; b uint }\t// change of signedness for b\nstruct { a int; b float }\t// change of type for b\nstruct { }\t\t\t// no field names in common\nstruct { c, d int }\t\t// no field names in common\n</pre>\n<p>\nIntegers are transmitted two ways: arbitrary precision signed integers or\narbitrary precision unsigned integers.  There is no int8, int16 etc.\ndiscrimination in the gob format; there are only signed and unsigned integers.  As\ndescribed below, the transmitter sends the value in a variable-length encoding;\nthe receiver accepts the value and stores it in the destination variable.\nFloating-point numbers are always sent using IEEE-754 64-bit precision (see\nbelow).\n</p>\n<p>\nSigned integers may be received into any signed integer variable: int, int16, etc.;\nunsigned integers may be received into any unsigned integer variable; and floating\npoint values may be received into any floating point variable.  However,\nthe destination variable must be able to represent the value or the decode\noperation will fail.\n</p>\n<p>\nStructs, arrays and slices are also supported.  Strings and arrays of bytes are\nsupported with a special, efficient representation (see below).\n</p>\n<p>\nFunctions and channels cannot be sent in a gob.  Attempting\nto encode a value that contains one will fail.\n</p>\n<p>\nThe rest of this comment documents the encoding, details that are not important\nfor most users.  Details are presented bottom-up.\n</p>\n<p>\nAn unsigned integer is sent one of two ways.  If it is less than 128, it is sent\nas a byte with that value.  Otherwise it is sent as a minimal-length big-endian\n(high byte first) byte stream holding the value, preceded by one byte holding the\nbyte count, negated.  Thus 0 is transmitted as (00), 7 is transmitted as (07) and\n256 is transmitted as (FE 01 00).\n</p>\n<p>\nA boolean is encoded within an unsigned integer: 0 for false, 1 for true.\n</p>\n<p>\nA signed integer, i, is encoded within an unsigned integer, u.  Within u, bits 1\nupward contain the value; bit 0 says whether they should be complemented upon\nreceipt.  The encode algorithm looks like this:\n</p>\n<pre>uint u;\nif i &lt; 0 {\n\tu = (^i &lt;&lt; 1) | 1\t// complement i, bit 0 is 1\n} else {\n\tu = (i &lt;&lt; 1)\t// do not complement i, bit 0 is 0\n}\nencodeUnsigned(u)\n</pre>\n<p>\nThe low bit is therefore analogous to a sign bit, but making it the complement bit\ninstead guarantees that the largest negative integer is not a special case.  For\nexample, -129=^128=(^256&gt;&gt;1) encodes as (FE 01 01).\n</p>\n<p>\nFloating-point numbers are always sent as a representation of a float64 value.\nThat value is converted to a uint64 using math.Float64bits.  The uint64 is then\nbyte-reversed and sent as a regular unsigned integer.  The byte-reversal means the\nexponent and high-precision part of the mantissa go first.  Since the low bits are\noften zero, this can save encoding bytes.  For instance, 17.0 is encoded in only\nthree bytes (FE 31 40).\n</p>\n<p>\nStrings and slices of bytes are sent as an unsigned count followed by that many\nuninterpreted bytes of the value.\n</p>\n<p>\nAll other slices and arrays are sent as an unsigned count followed by that many\nelements using the standard gob encoding for their type, recursively.\n</p>\n<p>\nStructs are sent as a sequence of (field number, field value) pairs.  The field\nvalue is sent using the standard gob encoding for its type, recursively.  If a\nfield has the zero value for its type, it is omitted from the transmission.  The\nfield number is defined by the type of the encoded struct: the first field of the\nencoded type is field 0, the second is field 1, etc.  When encoding a value, the\nfield numbers are delta encoded for efficiency and the fields are always sent in\norder of increasing field number; the deltas are therefore unsigned.  The\ninitialization for the delta encoding sets the field number to -1, so an unsigned\ninteger field 0 with value 7 is transmitted as unsigned delta = 1, unsigned value\n= 7 or (01 07).  Finally, after all the fields have been sent a terminating mark\ndenotes the end of the struct.  That mark is a delta=0 value, which has\nrepresentation (00).\n</p>\n<p>\nInterface types are not checked for compatibility; all interface types are\ntreated, for transmission, as members of a single &#34;interface&#34; type, analogous to\nint or []byte - in effect they&#39;re all treated as interface{}.  Interface values\nare transmitted as a string identifying the concrete type being sent (a name\nthat must be pre-defined by calling Register), followed by a byte count of the\nlength of the following data (so the value can be skipped if it cannot be\nstored), followed by the usual encoding of concrete (dynamic) value stored in\nthe interface value.  (A nil interface value is identified by the empty string\nand transmits no value.) Upon receipt, the decoder verifies that the unpacked\nconcrete item satisfies the interface of the receiving variable.\n</p>\n<p>\nThe representation of types is described below.  When a type is defined on a given\nconnection between an Encoder and Decoder, it is assigned a signed integer type\nid.  When Encoder.Encode(v) is called, it makes sure there is an id assigned for\nthe type of v and all its elements and then it sends the pair (typeid, encoded-v)\nwhere typeid is the type id of the encoded type of v and encoded-v is the gob\nencoding of the value v.\n</p>\n<p>\nTo define a type, the encoder chooses an unused, positive type id and sends the\npair (-type id, encoded-type) where encoded-type is the gob encoding of a wireType\ndescription, constructed from these types:\n</p>\n<pre>type wireType struct {\n\tArrayT  *ArrayType\n\tSliceT  *SliceType\n\tStructT *StructType\n\tMapT    *MapType\n}\ntype ArrayType struct {\n\tCommonType\n\tElem typeId\n\tLen  int\n}\ntype CommonType {\n\tName string // the name of the struct type\n\tId  int    // the id of the type, repeated so it&#39;s inside the type\n}\ntype SliceType struct {\n\tCommonType\n\tElem typeId\n}\ntype StructType struct {\n\tCommonType\n\tField []*fieldType // the fields of the struct.\n}\ntype FieldType struct {\n\tName string // the name of the field.\n\tId   int    // the type id of the field, which must be already defined\n}\ntype MapType struct {\n\tCommonType\n\tKey  typeId\n\tElem typeId\n}\n</pre>\n<p>\nIf there are nested type ids, the types for all inner type ids must be defined\nbefore the top-level type id is used to describe an encoded-v.\n</p>\n<p>\nFor simplicity in setup, the connection is defined to understand these types a\npriori, as well as the basic gob types int, uint, etc.  Their ids are:\n</p>\n<pre>bool        1\nint         2\nuint        3\nfloat       4\n[]byte      5\nstring      6\ncomplex     7\ninterface   8\n// gap for reserved ids.\nWireType    16\nArrayType   17\nCommonType  18\nSliceType   19\nStructType  20\nFieldType   21\n// 22 is slice of fieldType.\nMapType     23\n</pre>\n<p>\nFinally, each message created by a call to Encode is preceded by an encoded\nunsigned integer count of the number of bytes remaining in the message.  After\nthe initial type name, interface values are wrapped the same way; in effect, the\ninterface value acts like a recursive invocation of Encode.\n</p>\n<p>\nIn summary, a gob stream looks like\n</p>\n<pre>(byteCount (-type id, encoding of a wireType)* (type id, encoding of a value))*\n</pre>\n<p>\nwhere * signifies zero or more repetitions and the type id of a value must\nbe predefined or be defined before the value in the stream.\n</p>\n",name:"gob",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CommonType!\">CommonType</a></h2>\n<pre>type CommonType struct {\n\tName string\n\tId   typeId\n}</pre>\n<p>\nCommon elements of all types.\n</p>\n\n",name:"CommonType","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Decoder!\">Decoder</a></h2>\n<pre>type Decoder struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA Decoder manages the receipt of type and data information read from the\nremote side of a connection.\n</p>\n\n",name:"Decoder","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.Decode!\">Decode</a></h2>\n<code>func (dec *Decoder) Decode(e interface{}) os.Error</code>\n<p>\nDecode reads the next value from the connection and stores\nit in the data represented by the empty interface value.\nIf e is nil, the value will be discarded. Otherwise,\nthe value underlying e must either be the correct type for the next\ndata item received, and must be a pointer.\n</p>\n\n",name:"Decode"},{html:"\n<h2><a class=\"black\" href=\"?m:Decoder\">func (*Decoder)</a> <a href=\"?m:Decoder.DecodeValue!\">DecodeValue</a></h2>\n<code>func (dec *Decoder) DecodeValue(v reflect.Value) os.Error</code>\n<p>\nDecodeValue reads the next value from the connection.\nIf v is the zero reflect.Value (v.Kind() == Invalid), DecodeValue discards the value.\nOtherwise, it stores the value into v.  In that case, v must represent\na non-nil pointer to data or be an assignable reflect.Value (v.CanSet())\n</p>\n\n",name:"DecodeValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Encoder!\">Encoder</a></h2>\n<pre>type Encoder struct {\n\t// contains unexported fields\n}</pre>\n<p>\nAn Encoder manages the transmission of type and data information to the\nother side of a connection.\n</p>\n\n",name:"Encoder","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.Encode!\">Encode</a></h2>\n<code>func (enc *Encoder) Encode(e interface{}) os.Error</code>\n<p>\nEncode transmits the data item represented by the empty interface value,\nguaranteeing that all necessary type information has been transmitted first.\n</p>\n\n",name:"Encode"},{html:"\n<h2><a class=\"black\" href=\"?m:Encoder\">func (*Encoder)</a> <a href=\"?m:Encoder.EncodeValue!\">EncodeValue</a></h2>\n<code>func (enc *Encoder) EncodeValue(value reflect.Value) os.Error</code>\n<p>\nEncodeValue transmits the data item represented by the reflection value,\nguaranteeing that all necessary type information has been transmitted first.\n</p>\n\n",name:"EncodeValue"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GobDecoder!\">GobDecoder</a></h2>\n<pre>type GobDecoder interface {\n\t// GobDecode overwrites the receiver, which must be a pointer,\n\t// with the value represented by the byte slice, which was written\n\t// by GobEncode, usually for the same concrete type.\n\tGobDecode([]byte) os.Error\n}</pre>\n<p>\nGobDecoder is the interface describing data that provides its own\nroutine for decoding transmitted values sent by a GobEncoder.\n</p>\n\n",name:"GobDecoder","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:GobEncoder!\">GobEncoder</a></h2>\n<pre>type GobEncoder interface {\n\t// GobEncode returns a byte slice representing the encoding of the\n\t// receiver for transmission to a GobDecoder, usually of the same\n\t// concrete type.\n\tGobEncode() ([]byte, os.Error)\n}</pre>\n<p>\nGobEncoder is the interface describing data that provides its own\nrepresentation for encoding values for transmission to a GobDecoder.\nA type that implements GobEncoder and GobDecoder has complete\ncontrol over the representation of its data and may therefore\ncontain things such as private fields, channels, and functions,\nwhich are not usually transmissable in gob streams.\n</p>\n<p>\nNote: Since gobs can be stored permanently, It is good design\nto guarantee the encoding used by a GobEncoder is stable as the\nsoftware evolves.  For instance, it might make sense for GobEncode\nto include a version number in the encoding.\n</p>\n\n",name:"GobEncoder","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewDecoder!\">NewDecoder</a></h2>\n<code>func NewDecoder(r io.Reader) *Decoder</code>\n<p>\nNewDecoder returns a new decoder that reads from the io.Reader.\n</p>\n\n",name:"NewDecoder"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewEncoder!\">NewEncoder</a></h2>\n<code>func NewEncoder(w io.Writer) *Encoder</code>\n<p>\nNewEncoder returns a new encoder that will transmit on the io.Writer.\n</p>\n\n",name:"NewEncoder"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Register!\">Register</a></h2>\n<code>func Register(value interface{})</code>\n<p>\nRegister records a type, identified by a value for that type, under its\ninternal type name.  That name will identify the concrete type of a value\nsent or received as an interface variable.  Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n</p>\n\n",name:"Register"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:RegisterName!\">RegisterName</a></h2>\n<code>func RegisterName(name string, value interface{})</code>\n<p>\nRegisterName is like Register but uses the provided name rather than the\ntype&#39;s default.\n</p>\n\n",name:"RegisterName"}],consts:[],vars:[]}