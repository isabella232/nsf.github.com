var gortfmData = {index:"index.html",html:"<p>\nThe elliptic package implements several standard elliptic curves over prime\nfields\n</p>\n",name:"elliptic",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Curve!\">Curve</a></h2>\n<pre>type Curve struct {\n\tP      *big.Int // the order of the underlying field\n\tB      *big.Int // the constant of the curve equation\n\tGx, Gy *big.Int // (x,y) of the base point\n}</pre>\n<p>\nA Curve represents a short-form Weierstrass curve with a=-3.\nSee <a href=\"http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\">http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html</a>\n</p>\n\n",name:"Curve","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Curve\">func (*Curve)</a> <a href=\"?m:Curve.Add!\">Add</a></h2>\n<code>func (curve *Curve) Add(x1, y1, x2, y2 *big.Int) (*big.Int, *big.Int)</code>\n<p>\nAdd returns the sum of (x1,y1) and (x2,y2)\n</p>\n\n",name:"Add"},{html:"\n<h2><a class=\"black\" href=\"?m:Curve\">func (*Curve)</a> <a href=\"?m:Curve.Double!\">Double</a></h2>\n<code>func (curve *Curve) Double(x1, y1 *big.Int) (*big.Int, *big.Int)</code>\n<p>\nDouble returns 2*(x,y)\n</p>\n\n",name:"Double"},{html:"\n<h2><a class=\"black\" href=\"?m:Curve\">func (*Curve)</a> <a href=\"?m:Curve.IsOnCurve!\">IsOnCurve</a></h2>\n<code>func (curve *Curve) IsOnCurve(x, y *big.Int) bool</code>\n<p>\nIsOnCurve returns true if the given (x,y) lies on the curve.\n</p>\n\n",name:"IsOnCurve"},{html:"\n<h2><a class=\"black\" href=\"?m:Curve\">func (*Curve)</a> <a href=\"?m:Curve.ScalarBaseMult!\">ScalarBaseMult</a></h2>\n<code>func (curve *Curve) ScalarBaseMult(k []byte) (*big.Int, *big.Int)</code>\n<p>\nScalarBaseMult returns k*G, where G is the base point of the group and k is\nan integer in big-endian form.\n</p>\n\n",name:"ScalarBaseMult"},{html:"\n<h2><a class=\"black\" href=\"?m:Curve\">func (*Curve)</a> <a href=\"?m:Curve.ScalarMult!\">ScalarMult</a></h2>\n<code>func (curve *Curve) ScalarMult(Bx, By *big.Int, k []byte) (*big.Int, *big.Int)</code>\n<p>\nScalarMult returns k*(Bx,By) where k is a number in big-endian form.\n</p>\n\n",name:"ScalarMult"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:P224!\">P224</a></h2>\n<code>func P224() *Curve</code>\n<p>\nP224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2)\n</p>\n\n",name:"P224"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:P256!\">P256</a></h2>\n<code>func P256() *Curve</code>\n<p>\nP256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n</p>\n\n",name:"P256"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:P384!\">P384</a></h2>\n<code>func P384() *Curve</code>\n<p>\nP384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n</p>\n\n",name:"P384"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:P521!\">P521</a></h2>\n<code>func P521() *Curve</code>\n<p>\nP256 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n</p>\n\n",name:"P521"}],consts:[],vars:[]}