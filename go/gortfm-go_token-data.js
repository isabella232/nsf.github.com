var gortfmData = {index:"index.html",html:"<p>\nThis package defines constants representing the lexical\ntokens of the Go programming language and basic operations\non tokens (printing, predicates).\n</p>\n",name:"token",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Position!\">Position</a></h2>\n<pre>type Position struct {\n\tFilename string // filename, if any\n\tOffset   int    // byte offset, starting at 0\n\tLine     int    // line number, starting at 1\n\tColumn   int    // column number, starting at 1 (character count)\n}</pre>\n<p>\nToken source positions are represented by a Position value.\nA Position is valid if the line number is &gt; 0.\n</p>\n\n",name:"Position","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.IsValid!\">IsValid</a></h2>\n<code>func (pos *Position) IsValid() bool</code>\n<p>\nIsValid returns true if the position is valid.\n</p>\n\n",name:"IsValid"},{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.Pos!\">Pos</a></h2>\n<code>func (pos *Position) Pos() Position</code>\n<p>\nPos is an accessor method for anonymous Position fields.\nIt returns its receiver.\n</p>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (Position)</a> <a href=\"?m:Position.String!\">String</a></h2>\n<code>func (pos Position) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Token!\">Token</a></h2>\n<pre>type Token int</pre>\n<p>\nToken is the set of lexical tokens of the Go programming language.\n</p>\n\n",name:"Token","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsKeyword!\">IsKeyword</a></h2>\n<code>func (tok Token) IsKeyword() bool</code>\n<p>\nIsKeyword returns true for tokens corresponding to keywords;\nreturns false otherwise.\n</p>\n\n",name:"IsKeyword"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsLiteral!\">IsLiteral</a></h2>\n<code>func (tok Token) IsLiteral() bool</code>\n<p>\nIsLiteral returns true for tokens corresponding to identifiers\nand basic type literals; returns false otherwise.\n</p>\n\n",name:"IsLiteral"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsOperator!\">IsOperator</a></h2>\n<code>func (tok Token) IsOperator() bool</code>\n<p>\nIsOperator returns true for tokens corresponding to operators and\ndelimiters; returns false otherwise.\n</p>\n\n",name:"IsOperator"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.Precedence!\">Precedence</a></h2>\n<code>func (op Token) Precedence() int</code>\n<p>\nPrecedence returns the operator precedence of the binary\noperator op. If op is not a binary operator, the result\nis LowestPrecedence.\n</p>\n\n",name:"Precedence"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.String!\">String</a></h2>\n<code>func (tok Token) String() string</code>\n<p>\nString returns the string corresponding to the token tok.\nFor operators, delimiters, and keywords the string is the actual\ntoken character sequence (e.g., for the token ADD, the string is\n&#34;+&#34;). For all other tokens the string corresponds to the token\nconstant name (e.g. for the token IDENT, the string is &#34;IDENT&#34;).\n</p>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lookup!\">Lookup</a></h2>\n<code>func Lookup(ident []byte) Token</code>\n<p>\nLookup maps an identifier to its keyword token or IDENT (if not a keyword).\n</p>\n\n",name:"Lookup"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Token!\">Token</a></h2>\n<pre>const (\n\t// Special tokens\n\tILLEGAL Token = iota\n\tEOF\n\tCOMMENT\n\n\t// Identifiers and basic type literals\n\t// (these tokens stand for classes of literals)\n\tIDENT  // main\n\tINT    // 12345\n\tFLOAT  // 123.45\n\tIMAG   // 123.45i\n\tCHAR   // &#39;a&#39;\n\tSTRING // &#34;abc&#34;\n\n\n\t// Operators and delimiters\n\tADD // +\n\tSUB // -\n\tMUL // *\n\tQUO // /\n\tREM // %\n\n\tAND     // &amp;\n\tOR      // |\n\tXOR     // ^\n\tSHL     // &lt;&lt;\n\tSHR     // &gt;&gt;\n\tAND_NOT // &amp;^\n\n\tADD_ASSIGN // +=\n\tSUB_ASSIGN // -=\n\tMUL_ASSIGN // *=\n\tQUO_ASSIGN // /=\n\tREM_ASSIGN // %=\n\n\tAND_ASSIGN     // &amp;=\n\tOR_ASSIGN      // |=\n\tXOR_ASSIGN     // ^=\n\tSHL_ASSIGN     // &lt;&lt;=\n\tSHR_ASSIGN     // &gt;&gt;=\n\tAND_NOT_ASSIGN // &amp;^=\n\n\tLAND  // &amp;&amp;\n\tLOR   // ||\n\tARROW // &lt;-\n\tINC   // ++\n\tDEC   // --\n\n\tEQL    // ==\n\tLSS    // &lt;\n\tGTR    // &gt;\n\tASSIGN // =\n\tNOT    // !\n\n\tNEQ      // !=\n\tLEQ      // &lt;=\n\tGEQ      // &gt;=\n\tDEFINE   // :=\n\tELLIPSIS // ...\n\n\tLPAREN // (\n\tLBRACK // [\n\tLBRACE // {\n\tCOMMA  // ,\n\tPERIOD // .\n\n\tRPAREN    // )\n\tRBRACK    // ]\n\tRBRACE    // }\n\tSEMICOLON // ;\n\tCOLON     // :\n\n\n\t// Keywords\n\tBREAK\n\tCASE\n\tCHAN\n\tCONST\n\tCONTINUE\n\n\tDEFAULT\n\tDEFER\n\tELSE\n\tFALLTHROUGH\n\tFOR\n\n\tFUNC\n\tGO\n\tGOTO\n\tIF\n\tIMPORT\n\n\tINTERFACE\n\tMAP\n\tPACKAGE\n\tRANGE\n\tRETURN\n\n\tSELECT\n\tSTRUCT\n\tSWITCH\n\tTYPE\n\tVAR\n)</pre>\n<p>\nThe list of tokens.\n</p>\n\n",names:["ILLEGAL","EOF","COMMENT","IDENT","INT","FLOAT","IMAG","CHAR","STRING","ADD","SUB","MUL","QUO","REM","AND","OR","XOR","SHL","SHR","AND_NOT","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","QUO_ASSIGN","REM_ASSIGN","AND_ASSIGN","OR_ASSIGN","XOR_ASSIGN","SHL_ASSIGN","SHR_ASSIGN","AND_NOT_ASSIGN","LAND","LOR","ARROW","INC","DEC","EQL","LSS","GTR","ASSIGN","NOT","NEQ","LEQ","GEQ","DEFINE","ELLIPSIS","LPAREN","LBRACK","LBRACE","COMMA","PERIOD","RPAREN","RBRACK","RBRACE","SEMICOLON","COLON","BREAK","CASE","CHAN","CONST","CONTINUE","DEFAULT","DEFER","ELSE","FALLTHROUGH","FOR","FUNC","GO","GOTO","IF","IMPORT","INTERFACE","MAP","PACKAGE","RANGE","RETURN","SELECT","STRUCT","SWITCH","TYPE","VAR"],type:"Token"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:LowestPrec!\"><em>group</em></a></h2>\n<pre>const (\n\tLowestPrec  = 0 // non-operators\n\tUnaryPrec   = 7\n\tHighestPrec = 8\n)</pre>\n<p>\nA set of constants for precedence-based expression parsing.\nNon-operators have lowest precedence, followed by operators\nstarting with precedence 1 up to unary operators. The highest\nprecedence corresponds serves as &#34;catch-all&#34; precedence for\nselector, indexing, and other operator and delimiter tokens.\n</p>\n\n",names:["LowestPrec","UnaryPrec","HighestPrec"],type:""}],vars:[]}