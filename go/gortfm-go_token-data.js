var gortfmData = {index:"index.html",html:"<p>\nThis package defines constants representing the lexical\ntokens of the Go programming language and basic operations\non tokens (printing, predicates).\n</p>\n",name:"token",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\n<pre>type File struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA File is a handle for a file belonging to a FileSet.\nA File has a name, size, and line offset table.\n</p>\n\n",name:"File","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.AddLine!\">AddLine</a></h2>\n<code>func (f *File) AddLine(offset int)</code>\n<p>\nAddLine adds the line offset for a new line.\nThe line offset must be larger than the offset for the previous line\nand not larger than the file size; otherwise the line offset is ignored.\n</p>\n\n",name:"AddLine"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.AddLineInfo!\">AddLineInfo</a></h2>\n<code>func (f *File) AddLineInfo(offset int, filename string, line int)</code>\n<p>\nAddLineInfo adds alternative file and line number information for\na given file offset. The offset must be larger than the offset for\nthe previously added alternative line info and not larger than the\nfile size; otherwise the information is ignored.\n</p>\n<p>\nAddLineInfo is typically used to register alternative position\ninformation for //line filename:line comments in source files.\n</p>\n\n",name:"AddLineInfo"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Base!\">Base</a></h2>\n<code>func (f *File) Base() int</code>\n<p>\nBase returns the base offset of file f as registered with AddFile.\n</p>\n\n",name:"Base"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.LineCount!\">LineCount</a></h2>\n<code>func (f *File) LineCount() int</code>\n<p>\nLineCount returns the number of lines in file f.\n</p>\n\n",name:"LineCount"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Name!\">Name</a></h2>\n<code>func (f *File) Name() string</code>\n<p>\nName returns the file name of file f as registered with AddFile.\n</p>\n\n",name:"Name"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Offset!\">Offset</a></h2>\n<code>func (f *File) Offset(p Pos) int</code>\n<p>\nOffset returns the offset for the given file position p;\np must be a Pos value in that file.\nf.Offset(f.Pos(offset)) == offset.\n</p>\n\n",name:"Offset"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Pos!\">Pos</a></h2>\n<code>func (f *File) Pos(offset int) Pos</code>\n<p>\nPos returns the Pos value for the given file offset;\nthe offset must be &lt;= f.Size().\nf.Pos(f.Offset(p)) == p.\n</p>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Position!\">Position</a></h2>\n<code>func (f *File) Position(offset int) Position</code>\n<p>\nPosition returns the Position value for the given file offset;\nthe offset must be &lt;= f.Size().\n</p>\n\n",name:"Position"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.SetLines!\">SetLines</a></h2>\n<code>func (f *File) SetLines(lines []int) bool</code>\n<p>\nSetLines sets all line offsets for a file and returns true if successful.\nEach line offset must be larger than the offset for the previous line\nand not larger than the file size; otherwise the SetLines fails and returns\nfalse.\n</p>\n\n",name:"SetLines"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Size!\">Size</a></h2>\n<code>func (f *File) Size() int</code>\n<p>\nSize returns the size of file f as registered with AddFile.\n</p>\n\n",name:"Size"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FileSet!\">FileSet</a></h2>\n<pre>type FileSet struct {\n\t// contains unexported fields\n}</pre>\n<p>\nA FileSet represents a set of source files.\n</p>\n\n",name:"FileSet","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FileSet\">func (*FileSet)</a> <a href=\"?m:FileSet.AddFile!\">AddFile</a></h2>\n<code>func (s *FileSet) AddFile(filename string, base, size int) *File</code>\n<p>\nAddFile adds a new file with a given filename, base offset, and file size\nto the file set s and returns the file. Multiple files may have the same\nname. The base offset must not be smaller than the FileSet&#39;s Base(), and\nsize must not be negative.\n</p>\n<p>\nAdding the file will set the file set&#39;s Base() value to base + size + 1\nas the minimum base value for the next file. The following relationship\nexists between a Pos value p for a given file offset offs:\n</p>\n<pre>int(p) = base + offs\n</pre>\n<p>\nwith offs in the range [0, size] and thus p in the range [base, base+size].\nFor convenience, File.Pos may be used to create file-specific position\nvalues from a file offset.\n</p>\n\n",name:"AddFile"},{html:"\n<h2><a class=\"black\" href=\"?m:FileSet\">func (*FileSet)</a> <a href=\"?m:FileSet.Base!\">Base</a></h2>\n<code>func (s *FileSet) Base() int</code>\n<p>\nBase returns the minimum base offset that must be provided to\nAddFile when adding the next file.\n</p>\n\n",name:"Base"},{html:"\n<h2><a class=\"black\" href=\"?m:FileSet\">func (*FileSet)</a> <a href=\"?m:FileSet.Position!\">Position</a></h2>\n<code>func (s *FileSet) Position(p Pos) (pos Position)</code>\n<p>\nPosition converts a Pos in the fileset into a general Position.\n</p>\n\n",name:"Position"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Pos!\">Pos</a></h2>\n<pre>type Pos int</pre>\n<p>\nPos is a compact encoding of a source position within a file set.\nIt can be converted into a Position for a more convenient, but much\nlarger, representation.\n</p>\n<p>\nThe Pos value for a given file is a number in the range [base, base+size],\nwhere base and size are specified when adding the file to the file set via\nAddFile.\n</p>\n<p>\nTo create the Pos value for a specific source offset, first add\nthe respective file to the current file set (via FileSet.AddFile)\nand then call File.Pos(offset) for that file. Given a Pos value p\nfor a specific file set fset, the corresponding Position value is\nobtained by calling fset.Position(p).\n</p>\n<p>\nPos values can be compared directly with the usual comparison operators:\nIf two Pos values p and q are in the same file, comparing p and q is\nequivalent to comparing the respective source file offsets. If p and q\nare in different files, p &lt; q is true if the file implied by p was added\nto the respective file set before the file implied by q.\n</p>\n\n",name:"Pos","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Pos\">func (Pos)</a> <a href=\"?m:Pos.IsValid!\">IsValid</a></h2>\n<code>func (p Pos) IsValid() bool</code>\n<p>\nIsValid returns true if the position is valid.\n</p>\n\n",name:"IsValid"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Position!\">Position</a></h2>\n<pre>type Position struct {\n\tFilename string // filename, if any\n\tOffset   int    // offset, starting at 0\n\tLine     int    // line number, starting at 1\n\tColumn   int    // column number, starting at 1 (character count)\n}</pre>\n<p>\nPosition describes an arbitrary source position\nincluding the file, line, and column location.\nA Position is valid if the line number is &gt; 0.\n</p>\n\n",name:"Position","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.IsValid!\">IsValid</a></h2>\n<code>func (pos *Position) IsValid() bool</code>\n<p>\nIsValid returns true if the position is valid.\n</p>\n\n",name:"IsValid"},{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (*Position)</a> <a href=\"?m:Position.Pos!\">Pos</a></h2>\n<code>func (pos *Position) Pos() Position</code>\n<p>\nPos is an accessor method for anonymous Position fields.\nIt returns its receiver.\n</p>\n\n",name:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?m:Position\">func (Position)</a> <a href=\"?m:Position.String!\">String</a></h2>\n<code>func (pos Position) String() string</code>\n<p>\nString returns a string in one of several forms:\n</p>\n<pre>\tfile:line:column    valid position with file name\n     line:column         valid position without file name\n     file                invalid position with file name\n     -                   invalid position without file name\n</pre>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Token!\">Token</a></h2>\n<pre>type Token int</pre>\n<p>\nToken is the set of lexical tokens of the Go programming language.\n</p>\n\n",name:"Token","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsKeyword!\">IsKeyword</a></h2>\n<code>func (tok Token) IsKeyword() bool</code>\n<p>\nIsKeyword returns true for tokens corresponding to keywords;\nreturns false otherwise.\n</p>\n\n",name:"IsKeyword"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsLiteral!\">IsLiteral</a></h2>\n<code>func (tok Token) IsLiteral() bool</code>\n<p>\nIsLiteral returns true for tokens corresponding to identifiers\nand basic type literals; returns false otherwise.\n</p>\n\n",name:"IsLiteral"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.IsOperator!\">IsOperator</a></h2>\n<code>func (tok Token) IsOperator() bool</code>\n<p>\nIsOperator returns true for tokens corresponding to operators and\ndelimiters; returns false otherwise.\n</p>\n\n",name:"IsOperator"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.Precedence!\">Precedence</a></h2>\n<code>func (op Token) Precedence() int</code>\n<p>\nPrecedence returns the operator precedence of the binary\noperator op. If op is not a binary operator, the result\nis LowestPrecedence.\n</p>\n\n",name:"Precedence"},{html:"\n<h2><a class=\"black\" href=\"?m:Token\">func (Token)</a> <a href=\"?m:Token.String!\">String</a></h2>\n<code>func (tok Token) String() string</code>\n<p>\nString returns the string corresponding to the token tok.\nFor operators, delimiters, and keywords the string is the actual\ntoken character sequence (e.g., for the token ADD, the string is\n&#34;+&#34;). For all other tokens the string corresponds to the token\nconstant name (e.g. for the token IDENT, the string is &#34;IDENT&#34;).\n</p>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Lookup!\">Lookup</a></h2>\n<code>func Lookup(ident []byte) Token</code>\n<p>\nLookup maps an identifier to its keyword token or IDENT (if not a keyword).\n</p>\n\n",name:"Lookup"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewFileSet!\">NewFileSet</a></h2>\n<code>func NewFileSet() *FileSet</code>\n<p>\nNewFileSet creates a new file set.\n</p>\n\n",name:"NewFileSet"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Pos!\">NoPos</a></h2>\n<pre>const NoPos Pos = 0</pre>\n<p>\nThe zero value for Pos is NoPos; there is no file and line information\nassociated with it, and NoPos().IsValid() is false. NoPos is always\nsmaller than any other Pos value. The corresponding Position value\nfor NoPos is the zero value for Position.\n</p>\n\n",names:["NoPos"],type:"Pos"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:Token!\">Token</a></h2>\n<pre>const (\n\t// Special tokens\n\tILLEGAL Token = iota\n\tEOF\n\tCOMMENT\n\n\t// Identifiers and basic type literals\n\t// (these tokens stand for classes of literals)\n\tIDENT  // main\n\tINT    // 12345\n\tFLOAT  // 123.45\n\tIMAG   // 123.45i\n\tCHAR   // &#39;a&#39;\n\tSTRING // &#34;abc&#34;\n\n\n\t// Operators and delimiters\n\tADD // +\n\tSUB // -\n\tMUL // *\n\tQUO // /\n\tREM // %\n\n\tAND     // &amp;\n\tOR      // |\n\tXOR     // ^\n\tSHL     // &lt;&lt;\n\tSHR     // &gt;&gt;\n\tAND_NOT // &amp;^\n\n\tADD_ASSIGN // +=\n\tSUB_ASSIGN // -=\n\tMUL_ASSIGN // *=\n\tQUO_ASSIGN // /=\n\tREM_ASSIGN // %=\n\n\tAND_ASSIGN     // &amp;=\n\tOR_ASSIGN      // |=\n\tXOR_ASSIGN     // ^=\n\tSHL_ASSIGN     // &lt;&lt;=\n\tSHR_ASSIGN     // &gt;&gt;=\n\tAND_NOT_ASSIGN // &amp;^=\n\n\tLAND  // &amp;&amp;\n\tLOR   // ||\n\tARROW // &lt;-\n\tINC   // ++\n\tDEC   // --\n\n\tEQL    // ==\n\tLSS    // &lt;\n\tGTR    // &gt;\n\tASSIGN // =\n\tNOT    // !\n\n\tNEQ      // !=\n\tLEQ      // &lt;=\n\tGEQ      // &gt;=\n\tDEFINE   // :=\n\tELLIPSIS // ...\n\n\tLPAREN // (\n\tLBRACK // [\n\tLBRACE // {\n\tCOMMA  // ,\n\tPERIOD // .\n\n\tRPAREN    // )\n\tRBRACK    // ]\n\tRBRACE    // }\n\tSEMICOLON // ;\n\tCOLON     // :\n\n\n\t// Keywords\n\tBREAK\n\tCASE\n\tCHAN\n\tCONST\n\tCONTINUE\n\n\tDEFAULT\n\tDEFER\n\tELSE\n\tFALLTHROUGH\n\tFOR\n\n\tFUNC\n\tGO\n\tGOTO\n\tIF\n\tIMPORT\n\n\tINTERFACE\n\tMAP\n\tPACKAGE\n\tRANGE\n\tRETURN\n\n\tSELECT\n\tSTRUCT\n\tSWITCH\n\tTYPE\n\tVAR\n)</pre>\n<p>\nThe list of tokens.\n</p>\n\n",names:["ILLEGAL","EOF","COMMENT","IDENT","INT","FLOAT","IMAG","CHAR","STRING","ADD","SUB","MUL","QUO","REM","AND","OR","XOR","SHL","SHR","AND_NOT","ADD_ASSIGN","SUB_ASSIGN","MUL_ASSIGN","QUO_ASSIGN","REM_ASSIGN","AND_ASSIGN","OR_ASSIGN","XOR_ASSIGN","SHL_ASSIGN","SHR_ASSIGN","AND_NOT_ASSIGN","LAND","LOR","ARROW","INC","DEC","EQL","LSS","GTR","ASSIGN","NOT","NEQ","LEQ","GEQ","DEFINE","ELLIPSIS","LPAREN","LBRACK","LBRACE","COMMA","PERIOD","RPAREN","RBRACK","RBRACE","SEMICOLON","COLON","BREAK","CASE","CHAN","CONST","CONTINUE","DEFAULT","DEFER","ELSE","FALLTHROUGH","FOR","FUNC","GO","GOTO","IF","IMPORT","INTERFACE","MAP","PACKAGE","RANGE","RETURN","SELECT","STRUCT","SWITCH","TYPE","VAR"],type:"Token"},{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:LowestPrec!\"><em>group</em></a></h2>\n<pre>const (\n\tLowestPrec  = 0 // non-operators\n\tUnaryPrec   = 7\n\tHighestPrec = 8\n)</pre>\n<p>\nA set of constants for precedence-based expression parsing.\nNon-operators have lowest precedence, followed by operators\nstarting with precedence 1 up to unary operators. The highest\nprecedence corresponds serves as &#34;catch-all&#34; precedence for\nselector, indexing, and other operator and delimiter tokens.\n</p>\n\n",names:["LowestPrec","UnaryPrec","HighestPrec"],type:""}],vars:[]}