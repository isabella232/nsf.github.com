var gortfmData = {index:"index.html",html:"<p>\nPackage crl exposes low-level details of PKIX Certificate Revocation Lists\nas specified in RFC 5280, section 5.\n</p>\n",name:"crl",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:AlgorithmIdentifier!\">AlgorithmIdentifier</a></h2>\n<pre>type AlgorithmIdentifier struct {\n\tAlgo   asn1.ObjectIdentifier\n\tParams asn1.RawValue &#34;optional&#34;\n}</pre>\n<p>\nAlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n5280, section 4.1.1.2.\n</p>\n\n",name:"AlgorithmIdentifier","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:CertificateList!\">CertificateList</a></h2>\n<pre>type CertificateList struct {\n\tTBSCertList        TBSCertificateList\n\tSignatureAlgorithm AlgorithmIdentifier\n\tSignatureValue     asn1.BitString\n}</pre>\n<p>\nCertificateList represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1. Use crypto/x509/Certificate.CheckCRLSignature to verify\nthe signature.\n</p>\n\n",name:"CertificateList","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:CertificateList\">func (*CertificateList)</a> <a href=\"?m:CertificateList.HasExpired!\">HasExpired</a></h2>\n<code>func (certList *CertificateList) HasExpired(currentTimeSeconds int64) bool</code>\n<p>\nHasExpired returns true iff currentTimeSeconds is past the expiry time of\ncertList.\n</p>\n\n",name:"HasExpired"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Extension!\">Extension</a></h2>\n<pre>type Extension struct {\n\tId        asn1.ObjectIdentifier\n\tIsCritial bool &#34;optional&#34;\n\tValue     []byte\n}</pre>\n<p>\nAlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n5280, section 4.2.\n</p>\n\n",name:"Extension","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:RevokedCertificate!\">RevokedCertificate</a></h2>\n<pre>type RevokedCertificate struct {\n\tSerialNumber   asn1.RawValue\n\tRevocationTime *time.Time\n\tExtensions     []Extension &#34;optional&#34;\n}</pre>\n<p>\nAlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1.\n</p>\n\n",name:"RevokedCertificate","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:TBSCertificateList!\">TBSCertificateList</a></h2>\n<pre>type TBSCertificateList struct {\n\tRaw                 asn1.RawContent\n\tVersion             int &#34;optional,default:2&#34;\n\tSignature           AlgorithmIdentifier\n\tIssuer              asn1.RawValue\n\tThisUpdate          *time.Time\n\tNextUpdate          *time.Time\n\tRevokedCertificates []RevokedCertificate &#34;optional&#34;\n\tExtensions          []Extension          &#34;tag:0,optional,explicit&#34;\n}</pre>\n<p>\nTBSCertificateList represents the ASN.1 structure of the same name. See RFC\n5280, section 5.1.\n</p>\n\n",name:"TBSCertificateList","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Parse!\">Parse</a></h2>\n<code>func Parse(crlBytes []byte) (certList *CertificateList, err os.Error)</code>\n<p>\nParse parses a CRL from the given bytes. It&#39;s often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn&#39;t any leading\ngarbage.\n</p>\n\n",name:"Parse"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:ParseDER!\">ParseDER</a></h2>\n<code>func ParseDER(derBytes []byte) (certList *CertificateList, err os.Error)</code>\n<p>\nParseDER parses a DER encoded CRL from the given bytes.\n</p>\n\n",name:"ParseDER"}],consts:[],vars:[]}