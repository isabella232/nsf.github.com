var gortfmData = {index:"index.html",html:"<p>\nThe exec package runs external commands.\n</p>\n",name:"exec",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Cmd!\">Cmd</a></h2>\n<pre>type Cmd struct {\n\tStdin   *os.File\n\tStdout  *os.File\n\tStderr  *os.File\n\tProcess *os.Process\n}</pre>\n<p>\nA Cmd represents a running command.\nStdin, Stdout, and Stderr are Files representing pipes\nconnected to the running command&#39;s standard input, output, and error,\nor else nil, depending on the arguments to Run.\nProcess represents the underlying operating system process.\n</p>\n\n",name:"Cmd","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Cmd\">func (*Cmd)</a> <a href=\"?m:Cmd.Close!\">Close</a></h2>\n<code>func (c *Cmd) Close() os.Error</code>\n<p>\nClose waits for the running command c to exit,\nif it hasn&#39;t already, and then closes the non-nil file descriptors\nc.Stdin, c.Stdout, and c.Stderr.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:Cmd\">func (*Cmd)</a> <a href=\"?m:Cmd.Wait!\">Wait</a></h2>\n<code>func (c *Cmd) Wait(options int) (*os.Waitmsg, os.Error)</code>\n<p>\nWait waits for the running command c,\nreturning the Waitmsg returned when the process exits.\nThe options are passed to the process&#39;s Wait method.\nSetting options to 0 waits for c to exit;\nother options cause Wait to return for other\nprocess events; see package os for details.\n</p>\n\n",name:"Wait"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:PathError!\">PathError</a></h2>\n<pre>type PathError struct {\n\tName string\n}</pre>\n<p>\nPathError records the name of a binary that was not\nfound on the current $PATH.\n</p>\n\n",name:"PathError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:PathError\">func (*PathError)</a> <a href=\"?m:PathError.String!\">String</a></h2>\n<code>func (e *PathError) String() string</code>\n\n",name:"String"}]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:LookPath!\">LookPath</a></h2>\n<code>func LookPath(file string) (string, os.Error)</code>\n<p>\nLookPath searches for an executable binary named file\nin the directories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\n</p>\n\n",name:"LookPath"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Run!\">Run</a></h2>\n<code>func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int) (c *Cmd, err os.Error)</code>\n<p>\nRun starts the named binary running with\narguments argv and environment envv.\nIt returns a pointer to a new Cmd representing\nthe command or an error.\n</p>\n<p>\nThe parameters stdin, stdout, and stderr\nspecify how to handle standard input, output, and error.\nThe choices are DevNull (connect to /dev/null),\nPassThrough (connect to the current process&#39;s standard stream),\nPipe (connect to an operating system pipe), and\nMergeWithStdout (only for standard error; use the same\nfile descriptor as was used for standard output).\nIf a parameter is Pipe, then the corresponding field (Stdin, Stdout, Stderr)\nof the returned Cmd is the other end of the pipe.\nOtherwise the field in Cmd is nil.\n</p>\n\n",name:"Run"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:DevNull!\"><em>group</em></a></h2>\n<pre>const (\n\tDevNull = iota\n\tPassThrough\n\tPipe\n\tMergeWithStdout\n)</pre>\n<p>\nArguments to Run.\n</p>\n\n",names:["DevNull","PassThrough","Pipe","MergeWithStdout"],type:""}],vars:[]}