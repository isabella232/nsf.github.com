var gortfmData = {index:"index.html",html:"<p>\nPackage pe implements access to PE (Microsoft Windows Portable Executable) files.\n</p>\n",name:"pe",types:[{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:File!\">File</a></h2>\n<pre>type File struct {\n\tFileHeader\n\tSections []*Section\n\t// contains unexported fields\n}</pre>\n<p>\nA File represents an open PE file.\n</p>\n\n",name:"File","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Close!\">Close</a></h2>\n<code>func (f *File) Close() os.Error</code>\n<p>\nClose closes the File.\nIf the File was created using NewFile directly instead of Open,\nClose has no effect.\n</p>\n\n",name:"Close"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.DWARF!\">DWARF</a></h2>\n<code>func (f *File) DWARF() (*dwarf.Data, os.Error)</code>\n\n",name:"DWARF"},{html:"\n<h2><a class=\"black\" href=\"?m:File\">func (*File)</a> <a href=\"?m:File.Section!\">Section</a></h2>\n<code>func (f *File) Section(name string) *Section</code>\n<p>\nSection returns the first section with the given name, or nil if no such\nsection exists.\n</p>\n\n",name:"Section"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FileHeader!\">FileHeader</a></h2>\n<pre>type FileHeader struct {\n\tMachine              uint16\n\tNumberOfSections     uint16\n\tTimeDateStamp        uint32\n\tPointerToSymbolTable uint32\n\tNumberOfSymbols      uint32\n\tSizeOfOptionalHeader uint16\n\tCharacteristics      uint16\n}</pre>\n\n",name:"FileHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:FormatError!\">FormatError</a></h2>\n<pre>type FormatError struct {\n\t// contains unexported fields\n}</pre>\n\n",name:"FormatError","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:FormatError\">func (*FormatError)</a> <a href=\"?m:FormatError.String!\">String</a></h2>\n<code>func (e *FormatError) String() string</code>\n\n",name:"String"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:Section!\">Section</a></h2>\n<pre>type Section struct {\n\tSectionHeader\n\n\t// Embed ReaderAt for ReadAt method.\n\t// Do not embed SectionReader directly\n\t// to avoid having Read and Seek.\n\t// If a client wants Read and Seek it must use\n\t// Open() to avoid fighting over the seek offset\n\t// with other clients.\n\tio.ReaderAt\n\t// contains unexported fields\n}</pre>\n\n",name:"Section","methods":[{html:"\n<h2><a class=\"black\" href=\"?m:Section\">func (*Section)</a> <a href=\"?m:Section.Data!\">Data</a></h2>\n<code>func (s *Section) Data() ([]byte, os.Error)</code>\n<p>\nData reads and returns the contents of the PE section.\n</p>\n\n",name:"Data"},{html:"\n<h2><a class=\"black\" href=\"?m:Section\">func (*Section)</a> <a href=\"?m:Section.Open!\">Open</a></h2>\n<code>func (s *Section) Open() io.ReadSeeker</code>\n<p>\nOpen returns a new ReadSeeker reading the PE section.\n</p>\n\n",name:"Open"}]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SectionHeader!\">SectionHeader</a></h2>\n<pre>type SectionHeader struct {\n\tName                 string\n\tVirtualSize          uint32\n\tVirtualAddress       uint32\n\tSize                 uint32\n\tOffset               uint32\n\tPointerToRelocations uint32\n\tPointerToLineNumbers uint32\n\tNumberOfRelocations  uint16\n\tNumberOfLineNumbers  uint16\n\tCharacteristics      uint32\n}</pre>\n\n",name:"SectionHeader","methods":[]},{html:"\n<h2><a class=\"black\" href=\"?t:\">type</a> <a href=\"?t:SectionHeader32!\">SectionHeader32</a></h2>\n<pre>type SectionHeader32 struct {\n\tName                 [8]uint8\n\tVirtualSize          uint32\n\tVirtualAddress       uint32\n\tSizeOfRawData        uint32\n\tPointerToRawData     uint32\n\tPointerToRelocations uint32\n\tPointerToLineNumbers uint32\n\tNumberOfRelocations  uint16\n\tNumberOfLineNumbers  uint16\n\tCharacteristics      uint32\n}</pre>\n\n",name:"SectionHeader32","methods":[]}],funcs:[{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:NewFile!\">NewFile</a></h2>\n<code>func NewFile(r io.ReaderAt) (*File, os.Error)</code>\n<p>\nNewFile creates a new File for acecssing a PE binary in an underlying reader.\n</p>\n\n",name:"NewFile"},{html:"\n<h2><a class=\"black\" href=\"?f:\">func</a> <a href=\"?f:Open!\">Open</a></h2>\n<code>func Open(name string) (*File, os.Error)</code>\n<p>\nOpen opens the named file using os.Open and prepares it for use as a PE binary.\n</p>\n\n",name:"Open"}],consts:[{html:"\n<h2><a class=\"black\" href=\"?c:\">const</a> <a href=\"?c:IMAGE_FILE_MACHINE_UNKNOWN!\"><em>group</em></a></h2>\n<pre>const (\n\tIMAGE_FILE_MACHINE_UNKNOWN   = 0x0\n\tIMAGE_FILE_MACHINE_AM33      = 0x1d3\n\tIMAGE_FILE_MACHINE_AMD64     = 0x8664\n\tIMAGE_FILE_MACHINE_ARM       = 0x1c0\n\tIMAGE_FILE_MACHINE_EBC       = 0xebc\n\tIMAGE_FILE_MACHINE_I386      = 0x14c\n\tIMAGE_FILE_MACHINE_IA64      = 0x200\n\tIMAGE_FILE_MACHINE_M32R      = 0x9041\n\tIMAGE_FILE_MACHINE_MIPS16    = 0x266\n\tIMAGE_FILE_MACHINE_MIPSFPU   = 0x366\n\tIMAGE_FILE_MACHINE_MIPSFPU16 = 0x466\n\tIMAGE_FILE_MACHINE_POWERPC   = 0x1f0\n\tIMAGE_FILE_MACHINE_POWERPCFP = 0x1f1\n\tIMAGE_FILE_MACHINE_R4000     = 0x166\n\tIMAGE_FILE_MACHINE_SH3       = 0x1a2\n\tIMAGE_FILE_MACHINE_SH3DSP    = 0x1a3\n\tIMAGE_FILE_MACHINE_SH4       = 0x1a6\n\tIMAGE_FILE_MACHINE_SH5       = 0x1a8\n\tIMAGE_FILE_MACHINE_THUMB     = 0x1c2\n\tIMAGE_FILE_MACHINE_WCEMIPSV2 = 0x169\n)</pre>\n\n",names:["IMAGE_FILE_MACHINE_UNKNOWN","IMAGE_FILE_MACHINE_AM33","IMAGE_FILE_MACHINE_AMD64","IMAGE_FILE_MACHINE_ARM","IMAGE_FILE_MACHINE_EBC","IMAGE_FILE_MACHINE_I386","IMAGE_FILE_MACHINE_IA64","IMAGE_FILE_MACHINE_M32R","IMAGE_FILE_MACHINE_MIPS16","IMAGE_FILE_MACHINE_MIPSFPU","IMAGE_FILE_MACHINE_MIPSFPU16","IMAGE_FILE_MACHINE_POWERPC","IMAGE_FILE_MACHINE_POWERPCFP","IMAGE_FILE_MACHINE_R4000","IMAGE_FILE_MACHINE_SH3","IMAGE_FILE_MACHINE_SH3DSP","IMAGE_FILE_MACHINE_SH4","IMAGE_FILE_MACHINE_SH5","IMAGE_FILE_MACHINE_THUMB","IMAGE_FILE_MACHINE_WCEMIPSV2"],type:""}],vars:[]}